<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>嵌入式开发-STM32标准库学习：新建Keil工程 | Eddy&#39;s blog</title>
<meta name="keywords" content="STM32, embedded, Embedded development, MCU, ARM Cortex-M, Development Board, 开发板, STM32简介, STM32标准库, 嵌入式开发, Keil uVision">
<meta name="description" content="本文档旨在指导STM32平台的新手开发者如何建立工程项目，并有效地运用标准库和HAL库来提高开发效率。首先，文档强调了基于寄存器、标准库和HAL库三种不同的STM32开发方式，并推荐初学者优先考虑使用标准库进行开发。其次，它详细介绍了在STM32环境中添加启动文件、设置头文件路径以及创建用户自定义函数的基本步骤，同时给出了基于寄存器进行开发的示例。文章还说明了如何通过库函数更方便地配置GPIO和控制LED，从而简化了对硬件的操作。此外，文档涵盖了如何新建工程、选择合适的启动文件以及调试器设置，旨在帮助开发者有效下载和运行程序。最后，通过一系列实例，文章阐述了基于库函数的STM32工程构建和理解，突出了中断服务函数的重要性和在工程中的应用。整体而言，本文档为STM32平台的开发者提供了一套完整且实用的开发指导，从基础设置到高级应用应有尽有。">
<meta name="author" content="Eddy">
<link rel="canonical" href="https://eddyblog.cn/posts/tech/stm32-standard-library-learning-jkd-p4/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://eddyblog.cn/img/logo3.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://eddyblog.cn/img/logo3.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://eddyblog.cn/img/logo3.jpg">
<link rel="apple-touch-icon" href="https://eddyblog.cn/img/logo3.jpg">
<link rel="mask-icon" href="https://eddyblog.cn/img/logo3.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://eddyblog.cn/posts/tech/stm32-standard-library-learning-jkd-p4/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>


<link rel="stylesheet" href="https://registry.npmmirror.com/lxgw-wenkai-screen-web/latest/files/style.css" />





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  

<meta property="og:title" content="嵌入式开发-STM32标准库学习：新建Keil工程" />
<meta property="og:description" content="本文档旨在指导STM32平台的新手开发者如何建立工程项目，并有效地运用标准库和HAL库来提高开发效率。首先，文档强调了基于寄存器、标准库和HAL库三种不同的STM32开发方式，并推荐初学者优先考虑使用标准库进行开发。其次，它详细介绍了在STM32环境中添加启动文件、设置头文件路径以及创建用户自定义函数的基本步骤，同时给出了基于寄存器进行开发的示例。文章还说明了如何通过库函数更方便地配置GPIO和控制LED，从而简化了对硬件的操作。此外，文档涵盖了如何新建工程、选择合适的启动文件以及调试器设置，旨在帮助开发者有效下载和运行程序。最后，通过一系列实例，文章阐述了基于库函数的STM32工程构建和理解，突出了中断服务函数的重要性和在工程中的应用。整体而言，本文档为STM32平台的开发者提供了一套完整且实用的开发指导，从基础设置到高级应用应有尽有。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://eddyblog.cn/posts/tech/stm32-standard-library-learning-jkd-p4/" />
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/BlogCover/pc9.jpg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-05-12T00:17:58+08:00" />
<meta property="article:modified_time" content="2024-05-12T00:17:58+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/BlogCover/pc9.jpg" />
<meta name="twitter:title" content="嵌入式开发-STM32标准库学习：新建Keil工程"/>
<meta name="twitter:description" content="本文档旨在指导STM32平台的新手开发者如何建立工程项目，并有效地运用标准库和HAL库来提高开发效率。首先，文档强调了基于寄存器、标准库和HAL库三种不同的STM32开发方式，并推荐初学者优先考虑使用标准库进行开发。其次，它详细介绍了在STM32环境中添加启动文件、设置头文件路径以及创建用户自定义函数的基本步骤，同时给出了基于寄存器进行开发的示例。文章还说明了如何通过库函数更方便地配置GPIO和控制LED，从而简化了对硬件的操作。此外，文档涵盖了如何新建工程、选择合适的启动文件以及调试器设置，旨在帮助开发者有效下载和运行程序。最后，通过一系列实例，文章阐述了基于库函数的STM32工程构建和理解，突出了中断服务函数的重要性和在工程中的应用。整体而言，本文档为STM32平台的开发者提供了一套完整且实用的开发指导，从基础设置到高级应用应有尽有。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://eddyblog.cn/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "👨🏻‍💻 技术",
          "item": "https://eddyblog.cn/posts/tech/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "嵌入式开发-STM32标准库学习：新建Keil工程",
      "item": "https://eddyblog.cn/posts/tech/stm32-standard-library-learning-jkd-p4/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "嵌入式开发-STM32标准库学习：新建Keil工程",
  "name": "嵌入式开发-STM32标准库学习：新建Keil工程",
  "description": "本文档旨在指导STM32平台的新手开发者如何建立工程项目，并有效地运用标准库和HAL库来提高开发效率。首先，文档强调了基于寄存器、标准库和HAL库三种不同的STM32开发方式，并推荐初学者优先考虑使用标准库进行开发。其次，它详细介绍了在STM32环境中添加启动文件、设置头文件路径以及创建用户自定义函数的基本步骤，同时给出了基于寄存器进行开发的示例。文章还说明了如何通过库函数更方便地配置GPIO和控制LED，从而简化了对硬件的操作。此外，文档涵盖了如何新建工程、选择合适的启动文件以及调试器设置，旨在帮助开发者有效下载和运行程序。最后，通过一系列实例，文章阐述了基于库函数的STM32工程构建和理解，突出了中断服务函数的重要性和在工程中的应用。整体而言，本文档为STM32平台的开发者提供了一套完整且实用的开发指导，从基础设置到高级应用应有尽有。",
  "keywords": [
    "STM32", "embedded", "Embedded development", "MCU", "ARM Cortex-M", "Development Board", "开发板", "STM32简介", "STM32标准库", "嵌入式开发", "Keil uVision"
  ],
  "articleBody": "INIT INIT：本节内容正式开始。action!\n本小节我们来建立一个STM32的工程，这个STM32的工程结构还是比较复杂的，需要用到很多文件，之后我们的代码也都是需要建立在工程结构上的。\n所以，在开始学习后续内容之前，我们先来学习一下如何新建STM32的工程。目前STM32的开发方式主要有基于寄存器的方式、基于标准库也就是库函数的方式和基于HAL库的方式。\n基于寄存器的方式和我们51单片机的开发方式一样，是用程序直接配置寄存器，来达到我们想要的功能。这种方式最底层最直接，效率会更高一些。但是由于STM32的结构复杂，寄存器太多，所以基于寄存器的方式目前是不推荐的。\n基于库函数的方式是使用ST官方提供用的封装好的函数，通过调用这些函数来间接的配置寄存器。由于ST对寄存器封装的比较好，所以这种方式既能满足对寄存器的配置，对开发人员也比较友好，有利于提高开发效率。我们本课程使用的就是库函数的开发方式。\n最后一个基于HAL库的方式，可以用图形化界面快速配置STM32。这个比较适合快速上手STM32的情况。但是这种方式隐藏了底层逻辑。\n如果你对STM32不熟悉，基本只能停留在很浅的水平。所以目前暂时不推荐HAL库。但是推荐你学过标准库之后，去了解一下这个方式，毕竟这个HAL库还是非常方便的。\n那使用库函数的方式，我们需要准备一个STM32库函数的压缩包。大家可以在我提供的资料链接里找到固件库的文件，然后可以看到STM32F10x标准外设库这个压缩包，我们先把它解压。打开解压后的文件夹，在这里就是酷函数的文件夹目录了。\n好，那接下来我们就正式开始新建一个基于标准库的工程。首先我们需要先建立一个存放工程的文件夹，比如在D盘、E盘等位置。那我这里方便起见，就在桌面新建了，起个名字，可以叫STM32Project。以后我们的工程都存在这个文件夹下，这样比较方便管理。\n下面开始新建工程。\n一、选择对应芯片的器件支持包 选择器件支持包为ST32F103C8\n二、添加工程所需的必要文件 1. 复制STM32的启动文件 现在这个工程还是不能直接用的，我们需要给他添加一些工程的必要文件。\nD:\\江科大 STM32\\固件库\\STM32F10x_StdPeriph_Lib_V3.5.0\\STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x\\startup\\arm 图：STM32的启动文件\n那这些就是STM32的启动文件，STM32的程序就是从启动文件开始执行的。\n我们把这些文件全部都复制下来，然后回到工程模板文件夹里，可以看到这些就是我们刚才新建工程自动生成的文件。\n图：刚才新建工程自动生成的文件\n2. 在工程目录中新建Start文件夹用来存放工程所需文件 2.1 复制复制STM32的启动文件到工程目录的Start文件夹 那如果直接把启动文件也放在这里，就有点太乱了，是吧？所以我们需要新建一个文件夹，可以叫做Start。然后把启动文件粘贴到这里面。\n图：把启动文件粘贴到Start文件夹\n2.2 复制外设寄存器描述文件stm32Ff10x.h和用于配置时钟的system文件 接着我们回到固件库的STM32F10x文件夹，可以看到stm32Ff10x.h和两个system开头的文件。\n这个stm32Ff10x.h，就是STM32的外设寄存器描述文件。它的作用就跟51单片机的头文件REGX52.H一样。是用来描述STM32有哪些寄存器和它对应的地址的。\n这两个system文件是用来配置时钟的。STM32主频72MHz，就是system文件里的函数配置的。\n那我们把这三个文件复制下来，也粘贴到start文件夹下。\n图：D:\\江科大 STM32\\固件库\\固件库\\STM32F10x_StdPeriph_Lib_V3.5.0\\STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x\n图：D:\\Keil5Project\\STM32Project\\2-1 STM32工程模板\\Start\n2.3 复制内核寄存器描述文件core_cm3.h和内核的配置函数core_cm3.c 接下来，因为这个STM32是内核和内核外围的设备组成的，而且这个内核的寄存器描述和外围设备的描述文件不是在一起的。所以我们还需要添加一个内核寄存器的描述文件。\n我们可以打开CM3 CoreSupport，这2个CM3(Cortex-M3)文件就是内核的寄存器描述，当然它还带了一些内核的配置函数，所以多了个点儿.c文件。我们把它俩一并复制下来，也粘贴到Start文件夹下。\n到此为止，我们工程的必要文件就复制完成了。\n图：D:\\江科大 STM32\\固件库\\STM32F10x_StdPeriph_Lib_V3.5.0\\STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\CoreSupport\n图：D:\\Keil5Project\\STM32Project\\2-1 STM32工程模板\\Start\n3. 在Keil工程中新建Start文件夹并将Start所需文件加入进来 3.1 在Keil工程中新建Start文件夹 然后我们回到Keil软件，把我们刚才复制的那些文件添加到工程里来。我们可以点击选中这个Source Group，然后再单击一下，把这个组改一下名字，也叫Start。\n图：将Source Group改名为Start\n3.2 将Start文件夹所需的文件添加进来 接着右键，选择添加已经存在的文件到组里，打开Start文件夹，把下面这个文件过滤器选择all files，这样我们就能看到文件夹里的所有文件了。\n我们首先添加一下启动文件，这个启动文件有很多分类，我们只能添加其中一个。我们视频所用型号需要选择这个后缀为md.s的启动文件，至于启动文件怎么选择，我等会再讲。\n我们选中它，点击add。然后剩下的.c和.h文件都要添加进来。我们可以按住Ctrl键，然后依次选择它们，点击Add，然后Close，这样我们Start文件夹里面的文件就添加好了。\n图：添加完启动文件之后的Project目录\n这里的文件都是STM32里最基本的文件，是不需要我们修改的，我们添加进来即可。大家可以看到这个文件图标上带了个小钥匙，这个意思是他是个只读文件，我们可以打开试一下，这些信息都是不让我们修改的。\n3.3 在Keil工程中添加头文件路径 最后我们还需要在工程选项里添加上这个文件夹的头文件路径，要不然软件是找不到.h文件的。\n我们点击这个魔术棒按钮，打开工程选项，在C/C++里找到这个Include Paths栏，然后点击右边三个点的按钮，在这里新建路径，然后再点三个点的按钮，把Start的路径添加进来，点击ok，这样就把这个文件夹的头文件路径添加进来了。\n图：添加头文件路径\n图：新建 头文件路径\n图：添加Start文件夹头文件路径成功\n三、在Keil工程中新建User文件夹存放.c代码并编写代码 1. 在Keil工程中新建User文件夹 接下来我们再新建一个main函数，看看这个工程是不是可行。我们打开工程文件夹，然后新建一个文件夹。叫做User，我们的main函数就放在这个文件夹里。\n图：在工程文件夹目录下新建User文件夹\n然后Keil里，在Target这里右键，点击添加组，改个名字叫User。\n图：在Keil里添加组\n图：将新添加的组命名为User\n2. 在Keil工程中User文件夹新建main.c 然后在User上右键，点击添加新文件，选择.c文件，名字叫main。\n图：在User文件夹 添加新文件\n下面的路径注意一下，要选择User文件夹，要不然默认是放在文件夹外面的。然后点击Add，这样我们就有了main.c文件了。\n那在工程文件夹的User目录下也可以看到我们新建的main.c文件。\n图：选择路径为User文件夹 添加main.c。\n图：添加main.c成功\n3. 编写main.c，插入头文件 在这个main.c里，我们先右键，插入头文件，选择stm32f10x.h。\n图：在main.c中插入头文件\n然后写一个main函数。 按Tab键可以进行缩进，里面写一个while(1)死循环。 这里注意main函数是一个int型返回值，void参数的函数。还有文件的最后一 行必须要是空行，要不然会报警告。\n图：在main.c中编写代码\n四、编译工程 然后我们点击这个按钮，编译并建立工程。\n图：编译\n图：编译结果 显示1警告 0错误\n为什么这里会显示1警告呢？\n点击“魔法棒”，点击“output”，将“Create HEX File”勾选上。\n这样就不会出现警告了。\n可以看到下面提示的是零错误，零警告，那这就说明我们建立的工程是没问题的。\n这个工程目前还没有添加STM32的库函数，所以它还是一个基于寄存器开发的工程。如果你想用寄存器开发STM32，那工程建到这里就可以了。\n五、编程前期准备 接下来我给大家演示一下如何通过配置寄存器来完成点灯的操作。当然直接操作寄存器的方式不是我们本课程的重点，大家了解一下即可。\n1. 调大字体 那我们先把这个界面的字体调大点，现在的字体太小，看着不舒服。\n我们可以点击这个扳手工具。\n图：点击这个扳手工具\n选择颜色和字体，选择C/C++编辑器的选项。然后点击这个按钮把字号调成14。\n图：将C/C++编辑器的 Text 字体调整为Size：14\n这个Asm编辑器的字体，我们也把它调成14号了，然后OK，这样字体就变大了。\n图：将Asm编辑器的 Default 字体调整为Size：14\n图：调大字体后的效果\n2. 设置编码格式 另外我们再点一下这个扳手工具，把这个编码格式选成UTF8这一项，这样可以防止一些中文乱码的问题。\n图：设置编码格式为UTF8\n当然你要打开我的工程，也要把编码格式选为UTF8，否则中文显示就会出现问题。\n如果你打开别人的工程，看到中文是乱码的话，可能还需要再改一下这个编码格式。\n3. 设置Tab键的size 下面这个Tab键的大小，选择4，这个缩进大小我比较习惯，然后点击ok，这样界面看起来就舒服一些。\n图：设置Tab size为4\n图：设置Tab size为4后的效果\n4. 将STM32最小系统板通过STLINK连接电脑 接着我们需要拿出STM32的最小系统板，STLINK和4根母对母的杜邦线，按照插针边上的标识，把3.3V、SWDIO、SWCLK、GND对应连接好，插好之后就是这个样子的。\n图：将STM32的最小系统板连线\n然后把STLINK插在电脑上。插上电之后，这个板子上的电源灯应该会常亮，另一个连接在PC13口上的灯默认应该是闪烁状态，这是芯片里的一个测试程序。\n图：把STLINK插在电脑上\n5. 在Keil里面配置STLINK的调试器 然后我们再在Keil里面配置一下调试器，点击魔术棒按钮，选择Debug。这个调试器默认是ULINK，我们用的是STLINK，所以选择ST-Link Debugger。\n图：在Keil中选择调试器为ST-Link Debugger\n然后再点击右边的设置按钮，在Flash下载这一项，把这个Reset and Run这一项勾上，勾上这一项之后，我们下载程序后会立马复位并执行，这样方便一些。\n否则每次下载之后，还需要按一下板子上的复位按键才能执行程序。那配置好调试器之后，点击确认，ok。\n图：勾选Reset and Run这一项\n然后重新编译一下没有错误，再点击这个LOAD按钮，如果一切正常的话，这个程序就会下载到STM32里面了。\n图：下载程序到开发板\n我们看一下板子，可以看到这个灯已经不闪了，因为我们目前的程序啥都没有。\n图：下载程序到开发板后，灯不闪了\n六、寄存器编程实现点灯 那接下来，我们就配置一下寄存器，来点亮这个灯。我们只需要配置3个寄存器就可以点灯了，我们可以打开STM32的参考手册。\n手册为：《STM32F10xxx参考手册（中文）》\n1. 使能GPIOC的时钟 首先是RCC的一个寄存器，来使能GPIOC的时钟。GPIO都是APB2的外设，所以在这个APB2外设时钟使能寄存器RCC_APB2ENR里面配置。\n可以看到，这里有个IOPCEN，这一位就是使能GPIOC的时钟的。下面的解释是，这一位写1，就是打开GPIOC的时钟，那这一位写1，其他的无关项我们先都给0。\n图：APB2外设时钟使能寄存器 位4 IOPCEN\n图：APB2外设时钟使能寄存器 位4 IOPCEN 解释\n那整个寄存器的2进制数据换成16进制，就是4个一分组，也就是00000010。\n图：寄存器的2进制数据换成16进制，就是4个一分组：0 0 0 0 0 0 1 0\n然后我们回到Keil，在while死循环之前，写上RCC的APB2ENR寄存器=0x00000010，这样就可以打开GPIOC的时钟了。\n图：寄存器编程打开GPIOC的时钟\n2. 配置PC13口的模式 然后第二个寄存器，我们需要配置一下PC13口的模式。\n我们可以找到端口配置高寄存器，寄存器GPIOLx_CRH，这个x可以是A到E的任意一个字母。\n然后右边的CNF13和MODE13就是用来配置13号口的。\n图：端口配置高寄存器GPIOLx_CRH，CNF13和MODE13用来配置13号口\n下面的说明我们看一下，这个CNF我们需要配置为通用推挽输出模式，也就是这两位为00。MODE要配置为输出模式，最大速度可以给50MHz，也就是这两位为11。\n图：CNF为00 MODE为11\n最后我们对照上面的寄存器，这四位为0011，其他的我们也都给它配置为0。这样整个寄存器的值换算成16进制就是0 0 3 0 0 0 0 0。\n图：整个寄存器的值换算成16进制就是0 0 3 0 0 0 0 0\n然后我们回到Keil，在这里写上GPIOC的CRH=0x00300000。\n图：寄存器编程配置PC13口的模式\n3. 给PC13口输出数据 接下来我们就可以给PC13口输出数据了。我们可以看到这个端口输出数据寄存器GPIOx_ODR中间有一位ODR13，这一位写1，13号口就是高电平，写0就是低电平。\n图：端口输出数据寄存器GPIOx_ODR\n如果写1的话，ODR的值就是00002000。\n在这里我们写上GPIOC的ODR=0x00002000。\n因为这个灯是低电平点亮的，所以我们给ODR全为0，就是亮。给ODR 0x00002000就是灭。\n那我们试一下，先给ODR全0，编译，下载。这时可以看到这个PC13的灯已经亮起来了。\n图：给GPIOC-\u003eODR 全0\n图：给GPIOC-\u003eODR 全0 PC13灯亮\n如果我们给ODR 2000的话，编译，下载。此时灯就灭了。\n图：给GPIOC-\u003eODR 2000\n图：给GPIOC-\u003eODR 2000 PC13灯灭\n这就是配置寄存器的方式进行点灯的操作。可以看出来，这种方式需要不断地查手册来了解每个寄存器的每一位都是干啥的。\n而且这个操作方式也有个弊端，就是我们把除了PC13之外的位都配置成了0，这样会影响到其他端口的原有配置，如果要做到只配置PC13而不影响其他位，那还需要\u0026=和|=的操作，这个在51单片机的视频里我们也经常遇到。\n那这样配置就会更加麻烦。所以这种寄存器的操作方式，虽然代码简洁，但是还是不太方便。\n七、库函数编程实现点灯 那接下来我们就要为这个工程添加库函数了，看看库函数数和寄存器的操作方式有哪些区别。\n1. 在工程文件夹新建Library文件夹用来存放库函数 我们打开工程文件夹，在这里新建一个文件夹叫Library，用来存放库函数。\n图：D:\\Keil5Project\\STM32Project\\2-1 STM32工程模板\n接着打开固件库的文件夹，打开Libraries，STM32标准外设驱动，src，这些就是库函数的源文件。\n图：库函数的源文件 D:\\江科大 STM32\\固件库\\固件库\\STM32F10x_StdPeriph_Lib_V3.5.0\\STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\STM32F10x_StdPeriph_Driver\\src\n这个misc是内核的库函数，其他的就是内核外的外设库函数了。这个misc就是混杂的意思，看来这个ST公司还是不厚道，把内核的库函数都发配到杂项里面去。开个玩笑。\n那我们按Ctrl+A全选，然后复制，在Library文件夹下粘贴。\n然后再打开固件库的inc文件夹，这些是库函数的头文件。我们继续Ctrl+A全选，然后复制，在Library文件夹下粘贴。\n图：加入库函数文件的Library文件夹 D:\\Keil5Project\\STM32Project\\2-1 STM32工程模板\\Library\n2. Keil工程中新建组Library并导入库函数文件 接着回到Keil软件，同样在Target处右键，然后添加组，改个名字叫Library。再右键添加已经存在的文件，把Library文件夹下所有文件加进来。\n图：Keil工程中新建组Library\n图：Keil工程中Library导入库函数文件\n这样就把所有的库函数文件都添加进来了。但是对于这个库函数来说，现在还不能直接使用，我们需要再添加一个文件。\n我们打开固件库文件夹，打开Project，STM32Template，可以看到stm32f10x_conf.h和两个it结尾的文件。\n图：stm32f10x_conf.h和两个it结尾的文件 D:\\江科大 STM32\\固件库\\STM32F10x_StdPeriph_Lib_V3.5.0\\STM32F10x_StdPeriph_Lib_V3.5.0\\Project\\STM32F10x_StdPeriph_Template\n这个conf(configuration)文件是用来配置库函数头文件的包含关系的。另外这里面还有一个用来参数检查的函数定义，这是所有库函数都需要的.\n两个it(interrupt)文件是用来存放中断函数的。我们把这三个文件复制下来，然后粘贴到工程的User目录下。\n图：将三个文件粘贴到工程的User目录下 D:\\Keil5Project\\STM32Project\\2-1 STM32工程模板\\User\n接着回到Keil软件，在User组里把刚才那三个文件添加进来。\n图：Keil工程中在User组里把刚才那三个文件添加进来\n3. Keil工程中设置宏定义以及头文件路径 最后还需要一个宏定义，我们可以在这个头文件右键，打开文件。\n图：进入头文件\n然后滑到最下面。\n图：stm32f10x.h中的 一个条件编译\n看到这个语句，这是一个条件编译，意思是如果你定义了使用标准外设驱动USE_STDPERIPH_DRIVER这个字符串，下面这个include conf.h语句才有效。\n所以我们还需要复制一下这个字符串，然后打开工程选项，在C/C++的Define栏目粘贴这个字符串，这样才能包含标准外设库，也就是库函数。\n当然还有下面的头文件路径，也不要忘了把这个User和Library目录的路径也都添加上。\n图：设置工程宏定义，设置头文件路径\n然后OK，这样我们基于库函数的工程就建好了。\n我们可以看一下这个Library里面的库函数也都带了钥匙，不需要我们更改。我们唯一需要更改的就是User组里面的这些文件。\n4. 整理工程目录 我们点一下这个三个箱子的按钮，把这个Library往上挪下，把这些不用改的都放到最上面，这样看着舒服一下。\n图：三个箱子 按钮\n图：把Library移上去\n图：把Library移上去的效果\n那我们编译看一下。这个第一次编译会比较慢，以后就快一些。\n可以看到是0错误，0警告，这说明我们的工程建立是成功的。\n然后我们再用库函数来实现点灯的操作。我们先把这三句删了，库函数其实也是间接的配置寄存器，所以它们的步骤也是一样的。\n5. 使用RCC_APB2外设时钟控制函数 RCC_APB2PeriphClockCmd()来开启时钟 首先是使能时钟，那库函数就有这样一个函数来开启时钟，叫RCC_APB2外设时钟控制 RCC_APB2PeriphClockCmd()。然后这里提示有两个参数，第一个是选择外设，第二个是选择新的状态。\n图：RCC_APB2外设时钟控制函数 RCC_APB2PeriphClockCmd()\n我们可以右键跳到函数定义 Go To Definition of ，这上面有函数的简介和参数说明。简介说这个函数是用来使能或者失能APB2的外设时钟。\n第一个参数可以是下面这些值。那我们可以找到APB2外设GPIOC这一项，然后复制，直接作为第一个参数即可。\n然后我们再回过去看第二个参数，NewState的值可以是ENABLE或者DISABLE。那我们复制ENABLE，放在第二个参数的位置。\n最后别忘了括号和分号，这样GPIOC的外设时钟就配置好了。\n图：在main.c中，使用库函数配置GPIOC的外设时钟\n我们可以看一下这个函数，它的内部其实还是配置RCC_APB2ENR这个寄存器。但是经过函数的包装，我们不需要再去查手册，来确认哪一位是干啥的了。\n函数定义：RCC_APB2PeriphClockCmd()\n/** * @brief Enables or disables the High Speed APB (APB2) peripheral clock. * @param RCC_APB2Periph: specifies the APB2 peripheral to gates its clock. * This parameter can be any combination of the following values: * @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB, * RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE, * RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1, * RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1, * RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3, * RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17, * RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11 * @param NewState: new state of the specified peripheral clock. * This parameter can be: ENABLE or DISABLE. * @retval None */ void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState != DISABLE) { RCC-\u003eAPB2ENR |= RCC_APB2Periph; } else { RCC-\u003eAPB2ENR \u0026= ~RCC_APB2Periph; } } 而且这里他已经帮我们用|=和\u0026=来操作了。或者这个库函数的配置是不会影响到寄存器的其他位的，这就是库函数和寄存器的区别。\n我们看到这个代码虽然比寄存器长，但是语义更加明确，也不需要我们再查表计算这个寄存器的值了。我们只需要调用库函数，按照它的提示把参数填好就行了。所以说从这点对比上来看，库函数是比寄存器有更大优势的。\n好，那我们继续来配置。\n6. 使用GPIO_Init()函数配置端口模式 第二步是配置端口模式，我们需要用到GPIO_Init这个函数。然后有两个参数，第一个是选择哪个GPIO，第二个是参数的结构体。\n这个比上一个函数要麻烦一些，但也是一个套路，我们根据提示来配置参数即可。那我这里来操作一下，这里使用了结构体来配置参数，代码逻辑还是有些复杂的，这个我们下节还会继续讲，大家先跟着我操作就行了。\n我们首先还是去到这个函数的定义，可以看到这个函数的介绍是根据GPIO_Init结构体的参数来配置GPIO。\n/** * @brief Initializes the GPIOx peripheral according to the specified * parameters in the GPIO_InitStruct. * @param GPIOx: where x can be (A..G) to select the GPIO peripheral. * @param GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that * contains the configuration information for the specified GPIO peripheral. * @retval None */ void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct) { uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00; uint32_t tmpreg = 0x00, pinmask = 0x00; /* Check the parameters */ assert_param(IS_GPIO_ALL_PERIPH(GPIOx)); assert_param(IS_GPIO_MODE(GPIO_InitStruct-\u003eGPIO_Mode)); assert_param(IS_GPIO_PIN(GPIO_InitStruct-\u003eGPIO_Pin)); /*---------------------------- GPIO Mode Configuration -----------------------*/ currentmode = ((uint32_t)GPIO_InitStruct-\u003eGPIO_Mode) \u0026 ((uint32_t)0x0F); if ((((uint32_t)GPIO_InitStruct-\u003eGPIO_Mode) \u0026 ((uint32_t)0x10)) != 0x00) { /* Check the parameters */ assert_param(IS_GPIO_SPEED(GPIO_InitStruct-\u003eGPIO_Speed)); /* Output mode */ currentmode |= (uint32_t)GPIO_InitStruct-\u003eGPIO_Speed; } /*---------------------------- GPIO CRL Configuration ------------------------*/ /* Configure the eight low port pins */ if (((uint32_t)GPIO_InitStruct-\u003eGPIO_Pin \u0026 ((uint32_t)0x00FF)) != 0x00) { tmpreg = GPIOx-\u003eCRL; for (pinpos = 0x00; pinpos \u003c 0x08; pinpos++) { pos = ((uint32_t)0x01) \u003c\u003c pinpos; /* Get the port pins position */ currentpin = (GPIO_InitStruct-\u003eGPIO_Pin) \u0026 pos; if (currentpin == pos) { pos = pinpos \u003c\u003c 2; /* Clear the corresponding low control register bits */ pinmask = ((uint32_t)0x0F) \u003c\u003c pos; tmpreg \u0026= ~pinmask; /* Write the mode configuration in the corresponding bits */ tmpreg |= (currentmode \u003c\u003c pos); /* Reset the corresponding ODR bit */ if (GPIO_InitStruct-\u003eGPIO_Mode == GPIO_Mode_IPD) { GPIOx-\u003eBRR = (((uint32_t)0x01) \u003c\u003c pinpos); } else { /* Set the corresponding ODR bit */ if (GPIO_InitStruct-\u003eGPIO_Mode == GPIO_Mode_IPU) { GPIOx-\u003eBSRR = (((uint32_t)0x01) \u003c\u003c pinpos); } } } } GPIOx-\u003eCRL = tmpreg; } /*---------------------------- GPIO CRH Configuration ------------------------*/ /* Configure the eight high port pins */ if (GPIO_InitStruct-\u003eGPIO_Pin \u003e 0x00FF) { tmpreg = GPIOx-\u003eCRH; for (pinpos = 0x00; pinpos \u003c 0x08; pinpos++) { pos = (((uint32_t)0x01) \u003c\u003c (pinpos + 0x08)); /* Get the port pins position */ currentpin = ((GPIO_InitStruct-\u003eGPIO_Pin) \u0026 pos); if (currentpin == pos) { pos = pinpos \u003c\u003c 2; /* Clear the corresponding high control register bits */ pinmask = ((uint32_t)0x0F) \u003c\u003c pos; tmpreg \u0026= ~pinmask; /* Write the mode configuration in the corresponding bits */ tmpreg |= (currentmode \u003c\u003c pos); /* Reset the corresponding ODR bit */ if (GPIO_InitStruct-\u003eGPIO_Mode == GPIO_Mode_IPD) { GPIOx-\u003eBRR = (((uint32_t)0x01) \u003c\u003c (pinpos + 0x08)); } /* Set the corresponding ODR bit */ if (GPIO_InitStruct-\u003eGPIO_Mode == GPIO_Mode_IPU) { GPIOx-\u003eBSRR = (((uint32_t)0x01) \u003c\u003c (pinpos + 0x08)); } } } GPIOx-\u003eCRH = tmpreg; } } GPIO_Init()函数分析 这个函数是STM32微控制器的库函数，用于初始化GPIO（通用输入输出）端口。GPIO端口可以被配置为不同的模式，用于输入、输出或者作为其他功能的接口。\n函数的原型是： void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct); 参数说明： GPIOx: 一个指向GPIO端口的指针，其中x可以是A到G之间的字母，代表不同的GPIO端口。 GPIO_InitStruct: 一个指向GPIO_InitTypeDef结构体的指针，该结构体包含了要初始化的GPIO端口的配置信息。 GPIOA 是一个指向GPIOA端口的指针，所以它本身就是一个地址，不需要加上\u0026。 GPIO_InitStructure 是一个GPIO_InitTypeDef类型的结构体变量，当你想传递这个结构体到函数中时，你需要传递它的地址，因此前面需要加上\u0026。 函数功能： 初始化指定的GPIO端口，根据GPIO_InitStruct中提供的配置信息。 配置GPIO端口的工作模式（如输入、输出、上拉/下拉等）。 配置输出速度（如果端口被配置为输出）。 使用方法： 定义一个GPIO_InitTypeDef类型的变量(结构体实例)，并设置其成员，以指定要初始化的GPIO端口的配置。 调用GPIO_Init函数，传入GPIO端口的地址和配置结构体的地址。 GPIO_InitTypeDef：\nGPIO_InitTypeDef 是一个结构体类型，用于定义GPIO端口的初始化参数。当您需要初始化一个GPIO端口时，您需要创建一个这种类型的变量（通常称为结构体实例），我们一般命名这个结构体实例为GPIO_InitStructure，并设置其成员变量，以指定您希望如何配置GPIO端口。\n示例： GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; // 设置要初始化的引脚，这里以GPIO的第0个引脚为例 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // 设置为推挽输出模式 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // 设置输出速度 GPIO_Init(GPIOA, \u0026GPIO_InitStructure); // 对GPIOA的第0个引脚进行初始化 函数内部分析： 函数首先通过断言（assert_param）检查传入的参数是否有效。 然后，它根据GPIO_InitStruct中的模式和速度设置，计算出当前模式的值，并根据引脚是低8位还是高8位来配置相应的控制寄存器（CRL或CRH）。 如果模式是输入且带有上拉或下拉，则会设置或重置ODR（输出数据寄存器）相应的位。 对小白的讲解： 想象一下，GPIO端口就像你家的电灯开关，你可以通过不同的方式控制它。这个函数就是用来告诉你的STM32微控制器，如何正确地设置这个开关。你需要告诉微控制器，你想要控制的是哪一个开关（通过GPIOx指定），以及你想要如何控制它（通过GPIO_InitStruct中的配置）。\n例如，如果你想要一个开关可以控制LED灯的亮和灭，你就需要设置这个开关为输出模式，并且告诉微控制器，当输出高电平时LED亮，输出低电平时LED灭。\nGPIO_Init()函数代码使用 第一个参数GPIOx 第一个参数GPIOx，其中x可以是A到G，来选择你要配置哪个GPLIO，那我们是PC13口的LED，所以第一个参数就写GPIOC。\n@param GPIOx: where x can be (A..G) to select the GPIO peripheral. 第二个参数是一个GPIO_InitTypeDef类型的结构体变量 第二个参数是一个GPIO_InitTypeDef类型的结构体变量。\n@param GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that * contains the configuration information for the specified GPIO peripheral. 我们需要先定义一个结构体，在上面我们先把这个结构体的类型写上，然后给结构体起个名字。这个名字可以随便起，但是根据官方的推荐，我们最好起这样的名字，叫GPIO_InitStructure。\n然后我们把结构体的每一个参数填上，复制粘贴结构体的名字，然后用点来引出结构体的参数。可以看到这个结构体有三个参数，分别是GPIO模式、GPIO端口、GPIO速度。我们先把这三个参数都罗列出来。\nGPIO_InitTypeDef (结构体类型)的定义： typedef struct { uint16_t GPIO_Pin; /*!\u003c Specifies the GPIO pins to be configured. This parameter can be any value of @ref GPIO_pins_define */ GPIOSpeed_TypeDef GPIO_Speed; /*!\u003c Specifies the speed for the selected pins. This parameter can be a value of @ref GPIOSpeed_TypeDef */ GPIOMode_TypeDef GPIO_Mode; /*!\u003c Specifies the operating mode for the selected pins. This parameter can be a value of @ref GPIOMode_TypeDef */ }GPIO_InitTypeDef; 💡知识回顾：C语言中typedef结构体的用法\n在C语言中，typedef 结合结构体定义是一种非常实用的特性，用于为结构体创建一个更简洁、更易读的别名。这不仅让代码更加清晰，也使得程序员在声明和使用结构体变量时更为便捷。下面详细介绍其用法：\n一、基本语法\n基本的 typedef 结构体定义语法如下：\ntypedef struct tag { // 结构体成员定义 数据类型 成员名1; 数据类型 成员名2; ... } 自定义类型名; tag：这是结构体的标签，可选的，用于指明结构体的类型。在 typedef 语句中，这个标签有时会被省略，特别是在你不需要直接通过结构体标签来声明变量时。 自定义类型名：这是通过 typedef 关键字创建的新类型名称，之后可以用这个名称直接声明结构体变量，无需再写 struct 关键字。 二、简化定义与使用\n1、完整示例\ntypedef struct Point { int x; int y; } PointType; PointType p1, p2; // 直接使用PointType声明变量p1和p2 在这个例子中，struct Point 定义了一个包含两个整型成员 x 和 y 的结构体，typedef 则为这个结构体定义了一个别名 PointType。之后就可以直接使用 PointType 来声明结构体变量，而不需要写成 struct Point 形式。\n2、匿名结构体与typedef\n有时，结构体定义中不提供标签，这时 typedef 更显得尤为重要，因为它允许你为匿名结构体提供一个类型名：\ntypedef struct { int a; char b; } MyStruct; MyStruct example; // 使用MyStruct声明变量 三、优点\n提高代码可读性：通过给复杂的结构体类型起一个有意义的名字，可以让其他阅读代码的人更容易理解其用途。 简化声明：直接使用类型别名声明变量，代码更简洁，减少出错机会。 便于维护和扩展：修改结构体定义时，只需更改一处即可全局生效，尤其是当该类型被广泛使用时。 四、注意事项\n当定义结构体成员时，注意对齐和大小端问题，可能影响内存使用效率。 如果结构体较大，考虑使用指针而非直接实例化，以节省栈空间。 虽然 typedef 可以让代码更易读，过度使用也可能导致代码难以理解，特别是当类型名没有清晰表达其含义时。 通过合理利用 typedef 结构体定义，可以使C语言的编程更加高效、清晰。\n所以在这里，GPIO_InitTypeDef等价为struct，代表结构体类型。\nGPIO_InitTypeDef GPIO_InitStructure; 也就意味着创建了一个结构体实例GPIO_InitStructure。\nGPIO_InitStructure.GPIO_Mode 代码：GPIO_Mode的定义\ntypedef struct { uint16_t GPIO_Pin; /*!\u003c Specifies the GPIO pins to be configured. This parameter can be any value of @ref GPIO_pins_define */ GPIOSpeed_TypeDef GPIO_Speed; /*!\u003c Specifies the speed for the selected pins. This parameter can be a value of @ref GPIOSpeed_TypeDef */ GPIOMode_TypeDef GPIO_Mode; /*!\u003c Specifies the operating mode for the selected pins. This parameter can be a value of @ref GPIOMode_TypeDef */ }GPIO_InitTypeDef; 这右边的介绍说，这个参数可以是GPIOMode_TypeDef里面的一个值。因为这是注释里面的东西，所以没办法用右键跳转了。\n那这里我们需要选中GPIOMode_TypeDef这个字符，按一下Ctrl+F，搜索一下这个定义的位置。点击find next，可以看到这是个枚举。GPIOMode就是这里的其中一个值。\n图：搜索GPIOMode_TypeDef\n代码：GPIOMode_TypeDef 的定义\ntypedef enum { GPIO_Mode_AIN = 0x0, GPIO_Mode_IN_FLOATING = 0x04, GPIO_Mode_IPD = 0x28, GPIO_Mode_IPU = 0x48, GPIO_Mode_Out_OD = 0x14, GPIO_Mode_Out_PP = 0x10, GPIO_Mode_AF_OD = 0x1C, GPIO_Mode_AF_PP = 0x18 }GPIOMode_TypeDef; 然后我们选择Out_PP这一项，复制，这个就是通用推挽输出。\n然后在这里写上GPIO_Mode_Out_PP，这样这个参数就配置好了。\n编写代码：main.c中配置好了GPIO_InitStructure.GPIO_Mode\n#include \"stm32f10x.h\" // Device header int main(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = ; GPIO_InitStructure.GPIO_Speed = ; GPIO_Init(GPIOC,); while(1) { } } GPIO_InitStructure.GPIO_Pin 然后我们继续看一下下一个参数，转到它的定义这里下面出现了一个框，这个是说它的定义有很多个。\n图：GPIO_Pin的定义有很多个\n我们来看一下，我们选择这个member这一项，双击，然后跳转的其实还是刚才那个位置。\n图：双击 GPIO_Pin的member这一项\n代码：GPIO_Pin的定义\ntypedef struct { uint16_t GPIO_Pin; /*!\u003c Specifies the GPIO pins to be configured. This parameter can be any value of @ref GPIO_pins_define */ GPIOSpeed_TypeDef GPIO_Speed; /*!\u003c Specifies the speed for the selected pins. This parameter can be a value of @ref GPIOSpeed_TypeDef */ GPIOMode_TypeDef GPIO_Mode; /*!\u003c Specifies the operating mode for the selected pins. This parameter can be a value of @ref GPIOMode_TypeDef */ }GPIO_InitTypeDef; 然后看一下这个GPIO_Pin的说明，他说这个参数在GPIO_pins_define里面定义了，我们还是一样选中，Ctrl+F，find next。\n可以看到这里有个宏定义的列表，我们选择GPIO_Pin_13，复制，然后填在第二个位置。\n代码：stm32f10x_gpio.h中GPIO_pins_define\n/** @defgroup GPIO_pins_define * @{ */ #define GPIO_Pin_0 ((uint16_t)0x0001) /*!\u003c Pin 0 selected */ #define GPIO_Pin_1 ((uint16_t)0x0002) /*!\u003c Pin 1 selected */ #define GPIO_Pin_2 ((uint16_t)0x0004) /*!\u003c Pin 2 selected */ #define GPIO_Pin_3 ((uint16_t)0x0008) /*!\u003c Pin 3 selected */ #define GPIO_Pin_4 ((uint16_t)0x0010) /*!\u003c Pin 4 selected */ #define GPIO_Pin_5 ((uint16_t)0x0020) /*!\u003c Pin 5 selected */ #define GPIO_Pin_6 ((uint16_t)0x0040) /*!\u003c Pin 6 selected */ #define GPIO_Pin_7 ((uint16_t)0x0080) /*!\u003c Pin 7 selected */ #define GPIO_Pin_8 ((uint16_t)0x0100) /*!\u003c Pin 8 selected */ #define GPIO_Pin_9 ((uint16_t)0x0200) /*!\u003c Pin 9 selected */ #define GPIO_Pin_10 ((uint16_t)0x0400) /*!\u003c Pin 10 selected */ #define GPIO_Pin_11 ((uint16_t)0x0800) /*!\u003c Pin 11 selected */ #define GPIO_Pin_12 ((uint16_t)0x1000) /*!\u003c Pin 12 selected */ #define GPIO_Pin_13 ((uint16_t)0x2000) /*!\u003c Pin 13 selected */ #define GPIO_Pin_14 ((uint16_t)0x4000) /*!\u003c Pin 14 selected */ #define GPIO_Pin_15 ((uint16_t)0x8000) /*!\u003c Pin 15 selected */ #define GPIO_Pin_All ((uint16_t)0xFFFF) /*!\u003c All pins selected */ #define IS_GPIO_PIN(PIN) ((((PIN) \u0026 (uint16_t)0x00) == 0x00) \u0026\u0026 ((PIN) != (uint16_t)0x00)) #define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \\ ((PIN) == GPIO_Pin_1) || \\ ((PIN) == GPIO_Pin_2) || \\ ((PIN) == GPIO_Pin_3) || \\ ((PIN) == GPIO_Pin_4) || \\ ((PIN) == GPIO_Pin_5) || \\ ((PIN) == GPIO_Pin_6) || \\ ((PIN) == GPIO_Pin_7) || \\ ((PIN) == GPIO_Pin_8) || \\ ((PIN) == GPIO_Pin_9) || \\ ((PIN) == GPIO_Pin_10) || \\ ((PIN) == GPIO_Pin_11) || \\ ((PIN) == GPIO_Pin_12) || \\ ((PIN) == GPIO_Pin_13) || \\ ((PIN) == GPIO_Pin_14) || \\ ((PIN) == GPIO_Pin_15)) /** * @} */ 编写代码：main.c中配置好了GPIO_InitStructure.GPIO_Pin\n#include \"stm32f10x.h\" // Device header int main(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_InitStructure.GPIO_Speed = ; GPIO_Init(GPIOC,); while(1) { } } GPIO_InitStructure.GPIO_Speed 第三个参数也是一样，右键，跳到定义，选中，Ctrl+F， find next。\n代码：stm32f10x_gpio.h中GPIOSpeed_TypeDef\ntypedef enum { GPIO_Speed_10MHz = 1, GPIO_Speed_2MHz, GPIO_Speed_50MHz }GPIOSpeed_TypeDef; 在这里选中50MHz的速度复制，在这里粘贴，最后别忘了分号。\n编写代码：main.c中配置好了GPIO_InitStructure.GPIO_Speed\n#include \"stm32f10x.h\" // Device header int main(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC,); while(1) { } } 那结构体变量就有了，我们就可以填这个GPIO_Init的第二个参数了。在这里有说明，这个第二个参数是一个指向结构体的指针，所以这里我们需要传递结构体的地址。\n那我们复制结构体的名字粘贴到这个位置，然后前面加上一个取地址(\u0026)的符号，最后打成一个右括号，分号，这个GPIO模式配置就完成了。\n编写代码：GPIO模式配置完成\n#include \"stm32f10x.h\" // Device header int main(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC,\u0026GPIO_InitStructure); while(1) { } } 这个配置的操作方式看上去比较难理解，但是STM32的这种方式都是固定的，大家多打几次就知道怎么用了。\n最后我们设置端口的高低电平来进行点灯。这里有个函数GPIO_SetBits，这个就可以把指定端口设置为高电平。大家也可以右键去看一下参数的说明，那这里我就直接填了。\n第一个是GPIOC，第二个是GPIO_Pin_13。这一句就可以将PC13号口置为高电平，接下来自低电瓶也有函数叫GPIO_ResetBits。参数同样是GPIO_Pin_13，这一句就可以将PC13号口置为低电平。\n那我们依次试一下，我们先把高电平的注释掉。编译。下载。\n编写代码：设置PC13号口为低电平，点亮LED灯\n#include \"stm32f10x.h\" // Device header int main(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC,\u0026GPIO_InitStructure); //GPIO_SetBits(GPIOC,GPIO_Pin_13); GPIO_ResetBits(GPIOC,GPIO_Pin_13); while(1) { } } 可以看到灯已经亮了。\n图：PC13号口的LED灯亮\n再把低电平的注释掉，编译。\n编写代码：设置PC13号口为高电平，熄灭LED灯\n#include \"stm32f10x.h\" // Device header int main(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC,\u0026GPIO_InitStructure); GPIO_SetBits(GPIOC,GPIO_Pin_13); //GPIO_ResetBits(GPIOC,GPIO_Pin_13); while(1) { } } 可以看到灯就灭了。\n图：PC13号口的LED灯灭\n这就是使用库函数的基本操作了。这节把下节的课也带着讲了。这至于STM32 GPIO口的结构，结构体和库函数的操作，这些我们下节再详细解释。\n本节我们先来用一下，来测试一下我们的工程。\n有关新建工程的部分，我们这节大概就介绍完了。最后还要补充几点，来看一下PPT。\n新建工程里启动文件的选择 首先是新建工程里的启动文件选择，我们新建工程第一个加的就是启动文件。这个启动文件有很多类型，至于选择哪一个，我们要根据芯片型号来选择。\n图：STM32F1系列的启动文件一览\nSTM32F1系列型号分类表 我们看到这个表，这里是STM32F1系列中的型号分类。\n其中根据Flash的大小，分为了小容量产品，Flash为16~32K，简写为LD(Low Density)。\n中容量产品，Flash为16~128K，简写为MD(Medium Density)。\n大容量产品，Flash为256~512克，简写为HD(High Density)。\n加大容量产品，Flash大于512K，简写为XL(EXtra Large)。\n那STM32F100的系列，ST把它叫做超值系列，简写为VL(Value Line)。\nSDM32F105和107。ST把它叫做互联型产品(CL, Connectivity Line)。这个就没有根据Flash大小再分类了。\n所以就有了这个表。\nSTM32F1系列型号分类表的使用 1、STM32F100型号\n如果你使用STM32F100的型号，就选择带VL的启动文件，然后再根据Flash的大小选择LD、MD还是HD。\n2、STM32F101/102/103的型号\n如果你使用STM32F101/102/103的型号，就选择不带VL的，然后根据Flash的大小选择LD、MD、HD还是XL。\n3、STM3F105/107的型号\n如果你使用STM3F105/107的型号，直接选择CL的启动文件即可。\n那在这里我们可以看一下，这个启动文件后面带的字母和我这个表的字母都是对应的。\n这样我们就知道了我们这个STM32F103的芯片就需要选择这四列(LD、MD、HD还是XL)。又因为C8T6的Flash是64K所以选择MD的启动文件(也就是startup_stm32f10x_md.s)。\n这就是STM32F1系列的型号分类和启动文件的选取。\n新建工程步骤 接下来我们再总结一下新建工程的步骤。\n第一步 第一步、建立工程文件夹，Keil中新建工程，选择型号。\n第二步 第二步、工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹。\n这一步是为了添加工程文件准备的。建文件夹是因为文件比较多，需要分类管理一下。\n这个文件夹的名称和数量没有限制，大家也可以根据自己的理解来建，这都是可以的。\n另外需要用的文件一定要复制到工程文件夹里面来，不要添加工程文件夹外面的文件，要不然你外面的文件一旦挪位置，工程里就找不到文件了。所以我们要复制文件到工程里来，保持工程的独立性。\n第三步 第三步、工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里。\n这一步的原因是在Keil里方便管理文件，因为Keil没法直接添加文件夹，所以还得重复一下。\n这个添加文件我是把所有的.h文件和.c文件都添加进来了。因为.h文件是不参与编译的，所以其他很多工程都是不添加.h文件的。\n但是我认为把.h文件加进来比较方便，而且.h文件也是需要经常打开看的，所以我比较习惯把所有的文件都添加进来。\n第四步 第四步、工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹\n这一步是因为你这个Start、Library等文件夹是你自己建的，Keil软件它并不知道。所以你要用自己文件夹里面的.h文件，就必须声明一下这个路径，那最好就是你自己建的所有文件夹都声明一下，这样就不会出现.h文件找不到的问题了。\n第五步 第五步、工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER(标准外设驱动)，使用标准外设驱动这个字符串。\n这是使用库函数的条件编译，使用库函数就必须定义这个。另外其他的工程在这个位置还声明了一个STM32F10X_MD的字符串。\n那根据我的调查，Keil5在新建工程后自动就帮我们声明好了，这个不需要再额外申请声明了。所以在这个位置只需要声明使用USE_STDPERIPH_DRIVER(标准外设驱动)的字符串即可。\n第六步 第六步、工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download里勾选Reset and Run。\n这个就是选择调试器来进行下载的选项了。我们用STLINK就选择STLINK的那一项即可。\n结束 这就是新建工程的基本步骤。新建工程也是很灵活的，大家只要符合要求，都可以编译通过。每个人建工程的风格也不同，大家学会了之后也可以建立一个属于自己风格的工程。\n工程架构 最后我再额外的讲一下这个工程的架构，来看一下这个工程的每个文件都是干啥的，为啥需要这些文件？\n图：工程架构\nstartup启动文件 我们看到这个图，首先是startup启动文件，这个是程序执行的最基本的文件。\n图：Keil中启动文件\n我们可以看到Keil中启动文件是用汇编写的，启动文件内定义了中断向量表、中断服务函数等。\n这个中断服务函数中有个复位中断，这就是整个程序的入口，当STM32上电复位或者按下复位按键之后，程序就会进入复位中断函数执行。\n复位中断函数主要就做了两件事情。第一个是调用SystemInit函数，第二个是调用main函数。\n图：复位中断函数\n对应启动文件的这里。\n图：startup_stm32f10x_md.s中 复位中断函数\n这里可以看到这是复位的中断函数，然后调用SystemInit，再调用main，然后程序就结束了。\n当然实际上单片机的程序永远也不会结束，所以在main函数的最后一定是一个死循环。\n图：main.c中 while(1)死循环\nSystemInit函数就是定义在这个system开头的.c文件里的。\n那在Keil里我们也可以看到这个函数的定义。\n这里的简介写了这个函数的作用，是设置微控制器的启动，初始化嵌入式闪存接口、锁相环、更新系统内核的时钟变量。\n下面的note写的是这个函数仅在复位后需要调用。\n那下面这些就是用来配置这些东西的，这个也不需要我们更改，我们只需要知道在main函数之前，单片机就已经执行了一堆东西了。\n帮我们把这个闪存接口、时钟等一系列杂碎的东西都配置好了。\n代码：system_stm32f10x.c中SystemInit函数定义\n/** * @brief Setup the microcontroller system * Initialize the Embedded Flash Interface, the PLL and update the * SystemCoreClock variable. * @note This function should be used only after reset. * @param None * @retval None */ void SystemInit (void) { /* Reset the RCC clock configuration to the default reset state(for debug purpose) */ /* Set HSION bit */ RCC-\u003eCR |= (uint32_t)0x00000001; /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */ #ifndef STM32F10X_CL RCC-\u003eCFGR \u0026= (uint32_t)0xF8FF0000; #else RCC-\u003eCFGR \u0026= (uint32_t)0xF0FF0000; #endif /* STM32F10X_CL */ /* Reset HSEON, CSSON and PLLON bits */ RCC-\u003eCR \u0026= (uint32_t)0xFEF6FFFF; /* Reset HSEBYP bit */ RCC-\u003eCR \u0026= (uint32_t)0xFFFBFFFF; /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */ RCC-\u003eCFGR \u0026= (uint32_t)0xFF80FFFF; #ifdef STM32F10X_CL /* Reset PLL2ON and PLL3ON bits */ RCC-\u003eCR \u0026= (uint32_t)0xEBFFFFFF; /* Disable all interrupts and clear pending bits */ RCC-\u003eCIR = 0x00FF0000; /* Reset CFGR2 register */ RCC-\u003eCFGR2 = 0x00000000; #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL) /* Disable all interrupts and clear pending bits */ RCC-\u003eCIR = 0x009F0000; /* Reset CFGR2 register */ RCC-\u003eCFGR2 = 0x00000000; #else /* Disable all interrupts and clear pending bits */ RCC-\u003eCIR = 0x009F0000; #endif /* STM32F10X_CL */ #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL) #ifdef DATA_IN_ExtSRAM SystemInit_ExtMemCtl(); #endif /* DATA_IN_ExtSRAM */ #endif /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */ /* Configure the Flash Latency cycles and enable prefetch buffer */ SetSysClock(); #ifdef VECT_TAB_SRAM SCB-\u003eVTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */ #else SCB-\u003eVTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */ #endif } 另外在启动文件还定义了STM32所有的其他中断，这些中断达到触发条件后就会自动执行。那在启动文件(system_stm32f10x.c)这下面，这都是其他的中断调用了。\n图：STM32所有的其他中断\n这个中转函数的定义，就是在stm32f10x_it.c里面。\n图：中断函数的定义在stm32f10x_it.c里面\n我们打开Keil可以看到。这些就是中转函数的定义。\n最后ST还建议我们把自己的中断写在这个位置上。当然我们还是习惯在哪用中断就写在哪里，写在别的地方也是可以的。\n图：stm32f10x_it.c里 ST还建议我们把自己的中断写在这个位置上\n那这些就是中断部分的执行逻辑了。\n另外你也可以自己定义一些用户文件，来封装一些模块供主函数和中断调用，这些也都是没问题的，同时也有利于我们程序结构的模块化，要不然所有的程序都堆在主函数里，那主函数也太长了，是吧？\nSTM32的资源：外设和内核外设的寄存器描述+库函数文件 到此为止，这个工程结构主动执行的部分就介绍完了。剩下右边的就是被动执行的东西了，相当于STM32的资源。我们在主函数或者中断函数里就可以调用这些资源。\n右上角这2个stm32f10x.h和core_cm3这些文件就是外设和内核外设的寄存器描述。\n图：工程架构中stm32f10x.h和core_cm3这些文件\n在Keil中我们可以看到。这里面都是寄存器和寄存器每一位的名字，还有地址信息等，如果直接调用这些寄存器来使用STM32，那就是寄存器的开发方式。\n我们已经试过了，这种方式会有一些弊端，也比较麻烦。\n所以ST公司就提供了下面这两个文件，这个就是库函数的文件。\n图：ST公司提供的库函数文件\n在Keil中可以看到这每个外设都提供了一大堆的函数，这些函数封装了寄存器的操作，给我们提供更加人性化的函数调用方式。只要学会了操作套路，那配置一个外设就是很简单的，连手册都不需要看一下。\n这个conf文件就是用来配置头文件的包含关系的。\n在Keil中我们可以看到在这里conf文件include了所有的库函数头文件。同时我们在stm32f10x.h的最后又包含了conf。\n图：stm32f10x.h的最后又包含了conf\n所以在使用这些库函数时，我们只需要包含stm32f10x.h这一个头文件，就相当于包含了所有的库函数头文件。这样我们就可以任意的调用库函数了。\n这些就是整个工程的结构和每个文件的作用。好，以上就是我们我们本节课的所有内容。本节课我们建好了基于库函数的STM32工程，我们下一节就开始从这个工程上学习STM32的第一个外设GPIO了。\n临时解决一个小问题：头文件报错 1.点击魔术棒 在Target栏目下，将ARM Compiler的级别选为如下图所示。\nEND END：本节内容到此结束。\n个人提升之余，别忘了和小伙伴积极交流，很多人觉得他们在思考，而实际上他们只是在重新整理自己的偏见。请珍惜和他人交流讨论的机会。\n希望你每一天都有所收获，进步up up up。今天的我们并不比昨天更聪明，但一定要比昨天更睿智。\n",
  "wordCount" : "17851",
  "inLanguage": "zh",
  "image":"https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/BlogCover/pc9.jpg","datePublished": "2024-05-12T00:17:58+08:00",
  "dateModified": "2024-05-12T00:17:58+08:00",
  "author":[{
    "@type": "Person",
    "name": "Eddy"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://eddyblog.cn/posts/tech/stm32-standard-library-learning-jkd-p4/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Eddy's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://eddyblog.cn/img/logo3.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://eddyblog.cn/" accesskey="h" title="Eddy&#39;s Blog (Alt + H)">
            <img src="https://eddyblog.cn/img/logo3.jpg" alt="logo" aria-label="logo"
                 height="35">Eddy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://eddyblog.cn/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://eddyblog.cn/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://eddyblog.cn/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://eddyblog.cn/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://eddyblog.cn/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://eddyblog.cn/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://eddyblog.cn/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://eddyblog.cn/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://eddyblog.cn/posts/tech/">👨🏻‍💻 技术</a></div>
            <h1 class="post-title">
                嵌入式开发-STM32标准库学习：新建Keil工程
            </h1>
            <div class="post-description">
                本文档旨在指导STM32平台的新手开发者如何建立工程项目，并有效地运用标准库和HAL库来提高开发效率。首先，文档强调了基于寄存器、标准库和HAL库三种不同的STM32开发方式，并推荐初学者优先考虑使用标准库进行开发。其次，它详细介绍了在STM32环境中添加启动文件、设置头文件路径以及创建用户自定义函数的基本步骤，同时给出了基于寄存器进行开发的示例。文章还说明了如何通过库函数更方便地配置GPIO和控制LED，从而简化了对硬件的操作。此外，文档涵盖了如何新建工程、选择合适的启动文件以及调试器设置，旨在帮助开发者有效下载和运行程序。最后，通过一系列实例，文章阐述了基于库函数的STM32工程构建和理解，突出了中断服务函数的重要性和在工程中的应用。整体而言，本文档为STM32平台的开发者提供了一套完整且实用的开发指导，从基础设置到高级应用应有尽有。
            </div>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2024-05-12
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>17851字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>36分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Eddy
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://eddyblog.cn/tags/stm32/" style="color: var(--secondary)!important;">STM32</a>
                &nbsp;<a href="https://eddyblog.cn/tags/mcu/" style="color: var(--secondary)!important;">MCU</a>
                &nbsp;<a href="https://eddyblog.cn/tags/arm-cortex-m/" style="color: var(--secondary)!important;">ARM Cortex-M</a>
                &nbsp;<a href="https://eddyblog.cn/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/" style="color: var(--secondary)!important;">开发板</a>
                &nbsp;<a href="https://eddyblog.cn/tags/stm32%E6%A0%87%E5%87%86%E5%BA%93%E5%BC%80%E5%8F%91/" style="color: var(--secondary)!important;">STM32标准库开发</a>
                &nbsp;<a href="https://eddyblog.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" style="color: var(--secondary)!important;">嵌入式开发</a>
                &nbsp;<a href="https://eddyblog.cn/tags/keil-uvision/" style="color: var(--secondary)!important;">Keil UVision</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://eddyblog.cn/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> 
<figure class="entry-cover1"><img style="zoom:;" loading="lazy" src="https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/BlogCover/pc9.jpg" alt="">
    
</figure><aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#init" aria-label="INIT">INIT</a></li>
                <li>
                    <a href="#%e4%b8%80%e9%80%89%e6%8b%a9%e5%af%b9%e5%ba%94%e8%8a%af%e7%89%87%e7%9a%84%e5%99%a8%e4%bb%b6%e6%94%af%e6%8c%81%e5%8c%85" aria-label="一、选择对应芯片的器件支持包">一、选择对应芯片的器件支持包</a></li>
                <li>
                    <a href="#%e4%ba%8c%e6%b7%bb%e5%8a%a0%e5%b7%a5%e7%a8%8b%e6%89%80%e9%9c%80%e7%9a%84%e5%bf%85%e8%a6%81%e6%96%87%e4%bb%b6" aria-label="二、添加工程所需的必要文件">二、添加工程所需的必要文件</a><ul>
                        
                <li>
                    <a href="#1-%e5%a4%8d%e5%88%b6stm32%e7%9a%84%e5%90%af%e5%8a%a8%e6%96%87%e4%bb%b6" aria-label="1. 复制STM32的启动文件">1. 复制STM32的启动文件</a></li>
                <li>
                    <a href="#2-%e5%9c%a8%e5%b7%a5%e7%a8%8b%e7%9b%ae%e5%bd%95%e4%b8%ad%e6%96%b0%e5%bb%bastart%e6%96%87%e4%bb%b6%e5%a4%b9%e7%94%a8%e6%9d%a5%e5%ad%98%e6%94%be%e5%b7%a5%e7%a8%8b%e6%89%80%e9%9c%80%e6%96%87%e4%bb%b6" aria-label="2. 在工程目录中新建Start文件夹用来存放工程所需文件">2. 在工程目录中新建Start文件夹用来存放工程所需文件</a><ul>
                        
                <li>
                    <a href="#21-%e5%a4%8d%e5%88%b6%e5%a4%8d%e5%88%b6stm32%e7%9a%84%e5%90%af%e5%8a%a8%e6%96%87%e4%bb%b6%e5%88%b0%e5%b7%a5%e7%a8%8b%e7%9b%ae%e5%bd%95%e7%9a%84start%e6%96%87%e4%bb%b6%e5%a4%b9" aria-label="2.1 复制复制STM32的启动文件到工程目录的Start文件夹">2.1 复制复制STM32的启动文件到工程目录的Start文件夹</a></li>
                <li>
                    <a href="#22-%e5%a4%8d%e5%88%b6%e5%a4%96%e8%ae%be%e5%af%84%e5%ad%98%e5%99%a8%e6%8f%8f%e8%bf%b0%e6%96%87%e4%bb%b6stm32ff10xh%e5%92%8c%e7%94%a8%e4%ba%8e%e9%85%8d%e7%bd%ae%e6%97%b6%e9%92%9f%e7%9a%84system%e6%96%87%e4%bb%b6" aria-label="2.2 复制外设寄存器描述文件stm32Ff10x.h和用于配置时钟的system文件">2.2 复制外设寄存器描述文件stm32Ff10x.h和用于配置时钟的system文件</a></li>
                <li>
                    <a href="#23-%e5%a4%8d%e5%88%b6%e5%86%85%e6%a0%b8%e5%af%84%e5%ad%98%e5%99%a8%e6%8f%8f%e8%bf%b0%e6%96%87%e4%bb%b6core_cm3h%e5%92%8c%e5%86%85%e6%a0%b8%e7%9a%84%e9%85%8d%e7%bd%ae%e5%87%bd%e6%95%b0core_cm3c" aria-label="2.3 复制内核寄存器描述文件core_cm3.h和内核的配置函数core_cm3.c">2.3 复制内核寄存器描述文件core_cm3.h和内核的配置函数core_cm3.c</a></li></ul>
                </li>
                <li>
                    <a href="#3-%e5%9c%a8keil%e5%b7%a5%e7%a8%8b%e4%b8%ad%e6%96%b0%e5%bb%bastart%e6%96%87%e4%bb%b6%e5%a4%b9%e5%b9%b6%e5%b0%86start%e6%89%80%e9%9c%80%e6%96%87%e4%bb%b6%e5%8a%a0%e5%85%a5%e8%bf%9b%e6%9d%a5" aria-label="3. 在Keil工程中新建Start文件夹并将Start所需文件加入进来">3. 在Keil工程中新建Start文件夹并将Start所需文件加入进来</a><ul>
                        
                <li>
                    <a href="#31-%e5%9c%a8keil%e5%b7%a5%e7%a8%8b%e4%b8%ad%e6%96%b0%e5%bb%bastart%e6%96%87%e4%bb%b6%e5%a4%b9" aria-label="3.1 在Keil工程中新建Start文件夹">3.1 在Keil工程中新建Start文件夹</a></li>
                <li>
                    <a href="#32-%e5%b0%86start%e6%96%87%e4%bb%b6%e5%a4%b9%e6%89%80%e9%9c%80%e7%9a%84%e6%96%87%e4%bb%b6%e6%b7%bb%e5%8a%a0%e8%bf%9b%e6%9d%a5" aria-label="3.2 将Start文件夹所需的文件添加进来">3.2 将Start文件夹所需的文件添加进来</a></li>
                <li>
                    <a href="#33-%e5%9c%a8keil%e5%b7%a5%e7%a8%8b%e4%b8%ad%e6%b7%bb%e5%8a%a0%e5%a4%b4%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84" aria-label="3.3 在Keil工程中添加头文件路径">3.3 在Keil工程中添加头文件路径</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%89%e5%9c%a8keil%e5%b7%a5%e7%a8%8b%e4%b8%ad%e6%96%b0%e5%bb%bauser%e6%96%87%e4%bb%b6%e5%a4%b9%e5%ad%98%e6%94%bec%e4%bb%a3%e7%a0%81%e5%b9%b6%e7%bc%96%e5%86%99%e4%bb%a3%e7%a0%81" aria-label="三、在Keil工程中新建User文件夹存放.c代码并编写代码">三、在Keil工程中新建User文件夹存放.c代码并编写代码</a><ul>
                        
                <li>
                    <a href="#1-%e5%9c%a8keil%e5%b7%a5%e7%a8%8b%e4%b8%ad%e6%96%b0%e5%bb%bauser%e6%96%87%e4%bb%b6%e5%a4%b9" aria-label="1. 在Keil工程中新建User文件夹">1. 在Keil工程中新建User文件夹</a></li>
                <li>
                    <a href="#2-%e5%9c%a8keil%e5%b7%a5%e7%a8%8b%e4%b8%aduser%e6%96%87%e4%bb%b6%e5%a4%b9%e6%96%b0%e5%bb%bamainc" aria-label="2. 在Keil工程中User文件夹新建main.c">2. 在Keil工程中User文件夹新建main.c</a></li>
                <li>
                    <a href="#3-%e7%bc%96%e5%86%99mainc%e6%8f%92%e5%85%a5%e5%a4%b4%e6%96%87%e4%bb%b6" aria-label="3. 编写main.c，插入头文件">3. 编写main.c，插入头文件</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%9b%e7%bc%96%e8%af%91%e5%b7%a5%e7%a8%8b" aria-label="四、编译工程">四、编译工程</a></li>
                <li>
                    <a href="#%e4%ba%94%e7%bc%96%e7%a8%8b%e5%89%8d%e6%9c%9f%e5%87%86%e5%a4%87" aria-label="五、编程前期准备">五、编程前期准备</a><ul>
                        
                <li>
                    <a href="#1-%e8%b0%83%e5%a4%a7%e5%ad%97%e4%bd%93" aria-label="1. 调大字体">1. 调大字体</a></li>
                <li>
                    <a href="#2-%e8%ae%be%e7%bd%ae%e7%bc%96%e7%a0%81%e6%a0%bc%e5%bc%8f" aria-label="2. 设置编码格式">2. 设置编码格式</a></li>
                <li>
                    <a href="#3-%e8%ae%be%e7%bd%aetab%e9%94%ae%e7%9a%84size" aria-label="3. 设置Tab键的size">3. 设置Tab键的size</a></li>
                <li>
                    <a href="#4-%e5%b0%86stm32%e6%9c%80%e5%b0%8f%e7%b3%bb%e7%bb%9f%e6%9d%bf%e9%80%9a%e8%bf%87stlink%e8%bf%9e%e6%8e%a5%e7%94%b5%e8%84%91" aria-label="4. 将STM32最小系统板通过STLINK连接电脑">4. 将STM32最小系统板通过STLINK连接电脑</a></li>
                <li>
                    <a href="#5-%e5%9c%a8keil%e9%87%8c%e9%9d%a2%e9%85%8d%e7%bd%aestlink%e7%9a%84%e8%b0%83%e8%af%95%e5%99%a8" aria-label="5. 在Keil里面配置STLINK的调试器">5. 在Keil里面配置STLINK的调试器</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%ad%e5%af%84%e5%ad%98%e5%99%a8%e7%bc%96%e7%a8%8b%e5%ae%9e%e7%8e%b0%e7%82%b9%e7%81%af" aria-label="六、寄存器编程实现点灯">六、寄存器编程实现点灯</a><ul>
                        
                <li>
                    <a href="#1-%e4%bd%bf%e8%83%bdgpioc%e7%9a%84%e6%97%b6%e9%92%9f" aria-label="1. 使能GPIOC的时钟">1. 使能GPIOC的时钟</a></li>
                <li>
                    <a href="#2-%e9%85%8d%e7%bd%aepc13%e5%8f%a3%e7%9a%84%e6%a8%a1%e5%bc%8f" aria-label="2. 配置PC13口的模式">2. 配置PC13口的模式</a></li>
                <li>
                    <a href="#3-%e7%bb%99pc13%e5%8f%a3%e8%be%93%e5%87%ba%e6%95%b0%e6%8d%ae" aria-label="3. 给PC13口输出数据">3. 给PC13口输出数据</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%83%e5%ba%93%e5%87%bd%e6%95%b0%e7%bc%96%e7%a8%8b%e5%ae%9e%e7%8e%b0%e7%82%b9%e7%81%af" aria-label="七、库函数编程实现点灯">七、库函数编程实现点灯</a><ul>
                        
                <li>
                    <a href="#1-%e5%9c%a8%e5%b7%a5%e7%a8%8b%e6%96%87%e4%bb%b6%e5%a4%b9%e6%96%b0%e5%bb%balibrary%e6%96%87%e4%bb%b6%e5%a4%b9%e7%94%a8%e6%9d%a5%e5%ad%98%e6%94%be%e5%ba%93%e5%87%bd%e6%95%b0" aria-label="1. 在工程文件夹新建Library文件夹用来存放库函数">1. 在工程文件夹新建Library文件夹用来存放库函数</a></li>
                <li>
                    <a href="#2-keil%e5%b7%a5%e7%a8%8b%e4%b8%ad%e6%96%b0%e5%bb%ba%e7%bb%84library%e5%b9%b6%e5%af%bc%e5%85%a5%e5%ba%93%e5%87%bd%e6%95%b0%e6%96%87%e4%bb%b6" aria-label="2. Keil工程中新建组Library并导入库函数文件">2. Keil工程中新建组Library并导入库函数文件</a></li>
                <li>
                    <a href="#3-keil%e5%b7%a5%e7%a8%8b%e4%b8%ad%e8%ae%be%e7%bd%ae%e5%ae%8f%e5%ae%9a%e4%b9%89%e4%bb%a5%e5%8f%8a%e5%a4%b4%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84" aria-label="3. Keil工程中设置宏定义以及头文件路径">3. Keil工程中设置宏定义以及头文件路径</a></li>
                <li>
                    <a href="#4-%e6%95%b4%e7%90%86%e5%b7%a5%e7%a8%8b%e7%9b%ae%e5%bd%95" aria-label="4. 整理工程目录">4. 整理工程目录</a></li>
                <li>
                    <a href="#5-%e4%bd%bf%e7%94%a8rcc_apb2%e5%a4%96%e8%ae%be%e6%97%b6%e9%92%9f%e6%8e%a7%e5%88%b6%e5%87%bd%e6%95%b0-rcc_apb2periphclockcmd%e6%9d%a5%e5%bc%80%e5%90%af%e6%97%b6%e9%92%9f" aria-label="5. 使用RCC_APB2外设时钟控制函数 RCC_APB2PeriphClockCmd()来开启时钟">5. 使用RCC_APB2外设时钟控制函数 RCC_APB2PeriphClockCmd()来开启时钟</a></li>
                <li>
                    <a href="#6-%e4%bd%bf%e7%94%a8gpio_init%e5%87%bd%e6%95%b0%e9%85%8d%e7%bd%ae%e7%ab%af%e5%8f%a3%e6%a8%a1%e5%bc%8f" aria-label="6. 使用GPIO_Init()函数配置端口模式">6. 使用GPIO_Init()函数配置端口模式</a><ul>
                        
                <li>
                    <a href="#gpio_init%e5%87%bd%e6%95%b0%e5%88%86%e6%9e%90" aria-label="GPIO_Init()函数分析">GPIO_Init()函数分析</a><ul>
                        
                <li>
                    <a href="#%e5%87%bd%e6%95%b0%e7%9a%84%e5%8e%9f%e5%9e%8b%e6%98%af" aria-label="函数的原型是：">函数的原型是：</a></li>
                <li>
                    <a href="#%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e" aria-label="参数说明：">参数说明：</a></li>
                <li>
                    <a href="#%e5%87%bd%e6%95%b0%e5%8a%9f%e8%83%bd" aria-label="函数功能：">函数功能：</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="使用方法：">使用方法：</a></li>
                <li>
                    <a href="#%e7%a4%ba%e4%be%8b" aria-label="示例：">示例：</a></li>
                <li>
                    <a href="#%e5%87%bd%e6%95%b0%e5%86%85%e9%83%a8%e5%88%86%e6%9e%90" aria-label="函数内部分析：">函数内部分析：</a></li>
                <li>
                    <a href="#%e5%af%b9%e5%b0%8f%e7%99%bd%e7%9a%84%e8%ae%b2%e8%a7%a3" aria-label="对小白的讲解：">对小白的讲解：</a></li></ul>
                </li>
                <li>
                    <a href="#gpio_init%e5%87%bd%e6%95%b0%e4%bb%a3%e7%a0%81%e4%bd%bf%e7%94%a8" aria-label="GPIO_Init()函数代码使用">GPIO_Init()函数代码使用</a><ul>
                        
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%8f%82%e6%95%b0gpiox" aria-label="第一个参数GPIOx">第一个参数GPIOx</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%8c%e4%b8%aa%e5%8f%82%e6%95%b0%e6%98%af%e4%b8%80%e4%b8%aagpio_inittypedef%e7%b1%bb%e5%9e%8b%e7%9a%84%e7%bb%93%e6%9e%84%e4%bd%93%e5%8f%98%e9%87%8f" aria-label="第二个参数是一个GPIO_InitTypeDef类型的结构体变量">第二个参数是一个GPIO_InitTypeDef类型的结构体变量</a><ul>
                        
                <li>
                    <a href="#gpio_inittypedef-%e7%bb%93%e6%9e%84%e4%bd%93%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ae%9a%e4%b9%89" aria-label="GPIO_InitTypeDef (结构体类型)的定义：">GPIO_InitTypeDef (结构体类型)的定义：</a></li>
                <li>
                    <a href="#gpio_initstructuregpio_mode" aria-label="GPIO_InitStructure.GPIO_Mode">GPIO_InitStructure.GPIO_Mode</a></li>
                <li>
                    <a href="#gpio_initstructuregpio_pin" aria-label="GPIO_InitStructure.GPIO_Pin">GPIO_InitStructure.GPIO_Pin</a></li>
                <li>
                    <a href="#gpio_initstructuregpio_speed" aria-label="GPIO_InitStructure.GPIO_Speed">GPIO_InitStructure.GPIO_Speed</a></li></ul>
                </li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%96%b0%e5%bb%ba%e5%b7%a5%e7%a8%8b%e9%87%8c%e5%90%af%e5%8a%a8%e6%96%87%e4%bb%b6%e7%9a%84%e9%80%89%e6%8b%a9" aria-label="新建工程里启动文件的选择">新建工程里启动文件的选择</a><ul>
                        
                <li>
                    <a href="#stm32f1%e7%b3%bb%e5%88%97%e5%9e%8b%e5%8f%b7%e5%88%86%e7%b1%bb%e8%a1%a8" aria-label="STM32F1系列型号分类表">STM32F1系列型号分类表</a></li>
                <li>
                    <a href="#stm32f1%e7%b3%bb%e5%88%97%e5%9e%8b%e5%8f%b7%e5%88%86%e7%b1%bb%e8%a1%a8%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="STM32F1系列型号分类表的使用">STM32F1系列型号分类表的使用</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%96%b0%e5%bb%ba%e5%b7%a5%e7%a8%8b%e6%ad%a5%e9%aa%a4" aria-label="新建工程步骤">新建工程步骤</a><ul>
                        
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e6%ad%a5" aria-label="第一步">第一步</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%8c%e6%ad%a5" aria-label="第二步">第二步</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%89%e6%ad%a5" aria-label="第三步">第三步</a></li>
                <li>
                    <a href="#%e7%ac%ac%e5%9b%9b%e6%ad%a5" aria-label="第四步">第四步</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%94%e6%ad%a5" aria-label="第五步">第五步</a></li>
                <li>
                    <a href="#%e7%ac%ac%e5%85%ad%e6%ad%a5" aria-label="第六步">第六步</a></li>
                <li>
                    <a href="#%e7%bb%93%e6%9d%9f" aria-label="结束">结束</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b7%a5%e7%a8%8b%e6%9e%b6%e6%9e%84" aria-label="工程架构">工程架构</a><ul>
                        
                <li>
                    <a href="#startup%e5%90%af%e5%8a%a8%e6%96%87%e4%bb%b6" aria-label="startup启动文件">startup启动文件</a></li>
                <li>
                    <a href="#stm32%e7%9a%84%e8%b5%84%e6%ba%90%e5%a4%96%e8%ae%be%e5%92%8c%e5%86%85%e6%a0%b8%e5%a4%96%e8%ae%be%e7%9a%84%e5%af%84%e5%ad%98%e5%99%a8%e6%8f%8f%e8%bf%b0%e5%ba%93%e5%87%bd%e6%95%b0%e6%96%87%e4%bb%b6" aria-label="STM32的资源：外设和内核外设的寄存器描述&#43;库函数文件">STM32的资源：外设和内核外设的寄存器描述+库函数文件</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%b4%e6%97%b6%e8%a7%a3%e5%86%b3%e4%b8%80%e4%b8%aa%e5%b0%8f%e9%97%ae%e9%a2%98%e5%a4%b4%e6%96%87%e4%bb%b6%e6%8a%a5%e9%94%99" aria-label="临时解决一个小问题：头文件报错">临时解决一个小问题：头文件报错</a><ul>
                        
                <li>
                    <a href="#1%e7%82%b9%e5%87%bb%e9%ad%94%e6%9c%af%e6%a3%92" aria-label="1.点击魔术棒">1.点击魔术棒</a></li></ul>
                </li>
                <li>
                    <a href="#end" aria-label="END">END</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h2 id="init">INIT<a hidden class="anchor" aria-hidden="true" href="#init">#</a></h2>
<div align = "center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/Blog-Common-Images/INIT.jpg" alt = "INIT.jpg" width = "70%" height = "auto">
</div>
<br>
<blockquote>
<p><strong>INIT：本节内容正式开始。action!</strong></p>
</blockquote>
<p>本小节我们来建立一个STM32的工程，这个STM32的工程结构还是比较复杂的，需要用到很多文件，之后我们的代码也都是需要建立在工程结构上的。</p>
<p>所以，在开始学习后续内容之前，我们先来学习一下如何新建STM32的工程。目前STM32的开发方式主要有基于寄存器的方式、基于标准库也就是库函数的方式和基于HAL库的方式。</p>
<p>基于寄存器的方式和我们51单片机的开发方式一样，是用程序直接配置寄存器，来达到我们想要的功能。这种方式最底层最直接，效率会更高一些。但是由于STM32的结构复杂，寄存器太多，所以基于寄存器的方式目前是不推荐的。</p>
<p>基于库函数的方式是使用ST官方提供用的封装好的函数，通过调用这些函数来间接的配置寄存器。由于ST对寄存器封装的比较好，所以这种方式既能满足对寄存器的配置，对开发人员也比较友好，有利于提高开发效率。我们本课程使用的就是库函数的开发方式。</p>
<p>最后一个基于HAL库的方式，可以用图形化界面快速配置STM32。这个比较适合快速上手STM32的情况。但是这种方式隐藏了底层逻辑。<br>
如果你对STM32不熟悉，基本只能停留在很浅的水平。所以目前暂时不推荐HAL库。但是推荐你学过标准库之后，去了解一下这个方式，毕竟这个HAL库还是非常方便的。</p>
<p>那使用库函数的方式，我们需要准备一个STM32库函数的压缩包。大家可以在我提供的资料链接里找到固件库的文件，然后可以看到STM32F10x标准外设库这个压缩包，我们先把它解压。打开解压后的文件夹，在这里就是酷函数的文件夹目录了。</p>
<p>好，那接下来我们就正式开始新建一个基于标准库的工程。首先我们需要先建立一个存放工程的文件夹，比如在D盘、E盘等位置。那我这里方便起见，就在桌面新建了，起个名字，可以叫STM32Project。以后我们的工程都存在这个文件夹下，这样比较方便管理。</p>
<p>下面开始新建工程。</p>
<h2 id="一选择对应芯片的器件支持包">一、选择对应芯片的器件支持包<a hidden class="anchor" aria-hidden="true" href="#一选择对应芯片的器件支持包">#</a></h2>
<p>选择器件支持包为ST32F103C8</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B.png" alt = "P4-新建工程.png" width = "70%" height = "auto">
</div>
<br>
<h2 id="二添加工程所需的必要文件">二、添加工程所需的必要文件<a hidden class="anchor" aria-hidden="true" href="#二添加工程所需的必要文件">#</a></h2>
<h3 id="1-复制stm32的启动文件">1. 复制STM32的启动文件<a hidden class="anchor" aria-hidden="true" href="#1-复制stm32的启动文件">#</a></h3>
<p>现在这个工程还是不能直接用的，我们需要给他添加一些工程的必要文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>D:\江科大 STM32\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm
</span></span></code></pre></div><p>图：STM32的启动文件</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-1.png" alt = "P4-新建工程-1.png" width = "70%" height = "auto">
</div>
<br>
<p>那这些就是STM32的启动文件，STM32的程序就是从启动文件开始执行的。</p>
<p>我们把这些文件全部都复制下来，然后回到工程模板文件夹里，可以看到这些就是我们刚才新建工程自动生成的文件。</p>
<p>图：刚才新建工程自动生成的文件</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-2.png" alt = "P4-新建工程-2.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="2-在工程目录中新建start文件夹用来存放工程所需文件">2. 在工程目录中新建Start文件夹用来存放工程所需文件<a hidden class="anchor" aria-hidden="true" href="#2-在工程目录中新建start文件夹用来存放工程所需文件">#</a></h3>
<h4 id="21-复制复制stm32的启动文件到工程目录的start文件夹">2.1 复制复制STM32的启动文件到工程目录的Start文件夹<a hidden class="anchor" aria-hidden="true" href="#21-复制复制stm32的启动文件到工程目录的start文件夹">#</a></h4>
<p>那如果直接把启动文件也放在这里，就有点太乱了，是吧？所以我们需要新建一个文件夹，可以叫做Start。然后把启动文件粘贴到这里面。</p>
<p>图：把启动文件粘贴到Start文件夹</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-3.png" alt = "P4-新建工程-3.png" width = "70%" height = "auto">
</div>
<br>
<h4 id="22-复制外设寄存器描述文件stm32ff10xh和用于配置时钟的system文件">2.2 复制外设寄存器描述文件stm32Ff10x.h和用于配置时钟的system文件<a hidden class="anchor" aria-hidden="true" href="#22-复制外设寄存器描述文件stm32ff10xh和用于配置时钟的system文件">#</a></h4>
<p>接着我们回到固件库的STM32F10x文件夹，可以看到stm32Ff10x.h和两个system开头的文件。</p>
<p>这个stm32Ff10x.h，就是STM32的外设寄存器描述文件。它的作用就跟51单片机的头文件REGX52.H一样。是用来描述STM32有哪些寄存器和它对应的地址的。</p>
<p>这两个system文件是用来配置时钟的。STM32主频72MHz，就是system文件里的函数配置的。</p>
<p>那我们把这三个文件复制下来，也粘贴到start文件夹下。</p>
<p>图：<code>D:\江科大 STM32\固件库\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x</code></p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-4.png" alt = "P4-新建工程-4.png" width = "70%" height = "auto">
</div>
<br>
<p>图：<code>D:\Keil5Project\STM32Project\2-1 STM32工程模板\Start</code></p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-5.png" alt = "P4-新建工程-5.png" width = "70%" height = "auto">
</div>
<br>
<h4 id="23-复制内核寄存器描述文件core_cm3h和内核的配置函数core_cm3c">2.3 复制内核寄存器描述文件core_cm3.h和内核的配置函数core_cm3.c<a hidden class="anchor" aria-hidden="true" href="#23-复制内核寄存器描述文件core_cm3h和内核的配置函数core_cm3c">#</a></h4>
<p>接下来，因为这个STM32是内核和内核外围的设备组成的，而且这个内核的寄存器描述和外围设备的描述文件不是在一起的。所以我们还需要添加一个内核寄存器的描述文件。</p>
<p>我们可以打开CM3 CoreSupport，这2个CM3(Cortex-M3)文件就是内核的寄存器描述，当然它还带了一些内核的配置函数，所以多了个点儿.c文件。我们把它俩一并复制下来，也粘贴到Start文件夹下。</p>
<p>到此为止，我们工程的必要文件就复制完成了。</p>
<p>图：<code>D:\江科大 STM32\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport</code></p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-6.png" alt = "P4-新建工程-6.png" width = "70%" height = "auto">
</div>
<br>
<p>图：<code>D:\Keil5Project\STM32Project\2-1 STM32工程模板\Start</code></p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-7.png" alt = "P4-新建工程-7.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="3-在keil工程中新建start文件夹并将start所需文件加入进来">3. 在Keil工程中新建Start文件夹并将Start所需文件加入进来<a hidden class="anchor" aria-hidden="true" href="#3-在keil工程中新建start文件夹并将start所需文件加入进来">#</a></h3>
<h4 id="31-在keil工程中新建start文件夹">3.1 在Keil工程中新建Start文件夹<a hidden class="anchor" aria-hidden="true" href="#31-在keil工程中新建start文件夹">#</a></h4>
<p>然后我们回到Keil软件，把我们刚才复制的那些文件添加到工程里来。我们可以点击选中这个Source Group，然后再单击一下，把这个组改一下名字，也叫Start。</p>
<p>图：将Source Group改名为Start</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-9.png" alt = "P4-新建工程-9.png" width = "70%" height = "auto">
</div>
<br>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-8.png" alt = "P4-新建工程-8.png" width = "70%" height = "auto">
</div>
<br>
<h4 id="32-将start文件夹所需的文件添加进来">3.2 将Start文件夹所需的文件添加进来<a hidden class="anchor" aria-hidden="true" href="#32-将start文件夹所需的文件添加进来">#</a></h4>
<p>接着右键，选择添加已经存在的文件到组里，打开Start文件夹，把下面这个文件过滤器选择all files，这样我们就能看到文件夹里的所有文件了。</p>
<p>我们首先添加一下启动文件，这个启动文件有很多分类，我们只能添加其中一个。我们视频所用型号需要选择这个后缀为md.s的启动文件，至于启动文件怎么选择，我等会再讲。</p>
<p>我们选中它，点击add。然后剩下的.c和.h文件都要添加进来。我们可以按住Ctrl键，然后依次选择它们，点击Add，然后Close，这样我们Start文件夹里面的文件就添加好了。</p>
<p>图：添加完启动文件之后的Project目录</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-10.png" alt = "P4-新建工程-10.png" width = "70%" height = "auto">
</div>
<br>
<p>这里的文件都是STM32里最基本的文件，是不需要我们修改的，我们添加进来即可。大家可以看到这个文件图标上带了个小钥匙，这个意思是他是个只读文件，我们可以打开试一下，这些信息都是不让我们修改的。</p>
<h4 id="33-在keil工程中添加头文件路径">3.3 在Keil工程中添加头文件路径<a hidden class="anchor" aria-hidden="true" href="#33-在keil工程中添加头文件路径">#</a></h4>
<p>最后我们还需要在工程选项里添加上这个文件夹的头文件路径，要不然软件是找不到.h文件的。</p>
<p>我们点击这个魔术棒按钮，打开工程选项，在C/C++里找到这个Include Paths栏，然后点击右边三个点的按钮，在这里新建路径，然后再点三个点的按钮，把Start的路径添加进来，点击ok，这样就把这个文件夹的头文件路径添加进来了。</p>
<p>图：添加头文件路径</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-11.png" alt = "P4-新建工程-11.png" width = "70%" height = "auto">
</div>
<br>
<p>图：新建 头文件路径</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-12.png" alt = "P4-新建工程-12.png" width = "70%" height = "auto">
</div>
<br>
<p>图：添加Start文件夹头文件路径成功</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-13.png" alt = "P4-新建工程-13.png" width = "70%" height = "auto">
</div>
<br>
<h2 id="三在keil工程中新建user文件夹存放c代码并编写代码">三、在Keil工程中新建User文件夹存放.c代码并编写代码<a hidden class="anchor" aria-hidden="true" href="#三在keil工程中新建user文件夹存放c代码并编写代码">#</a></h2>
<h3 id="1-在keil工程中新建user文件夹">1. 在Keil工程中新建User文件夹<a hidden class="anchor" aria-hidden="true" href="#1-在keil工程中新建user文件夹">#</a></h3>
<p>接下来我们再新建一个main函数，看看这个工程是不是可行。我们打开工程文件夹，然后新建一个文件夹。叫做User，我们的main函数就放在这个文件夹里。</p>
<p>图：在工程文件夹目录下新建User文件夹</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-14.png" alt = "P4-新建工程-14.png" width = "70%" height = "auto">
</div>
<br>
<p>然后Keil里，在Target这里右键，点击添加组，改个名字叫User。</p>
<p>图：在Keil里添加组</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-15.png" alt = "P4-新建工程-15.png" width = "70%" height = "auto">
</div>
<br>
<p>图：将新添加的组命名为User</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-16.png" alt = "P4-新建工程-16.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="2-在keil工程中user文件夹新建mainc">2. 在Keil工程中User文件夹新建main.c<a hidden class="anchor" aria-hidden="true" href="#2-在keil工程中user文件夹新建mainc">#</a></h3>
<p>然后在User上右键，点击添加新文件，选择.c文件，名字叫main。</p>
<p>图：在User文件夹 添加新文件</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-17.png" alt = "P4-新建工程-17.png" width = "70%" height = "auto">
</div>
<br>
<p>下面的路径注意一下，要选择User文件夹，要不然默认是放在文件夹外面的。然后点击Add，这样我们就有了main.c文件了。</p>
<p>那在工程文件夹的User目录下也可以看到我们新建的main.c文件。</p>
<p>图：选择路径为User文件夹 添加main.c。</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-19.png" alt = "P4-新建工程-19.png" width = "70%" height = "auto">
</div>
<br>
<p>图：添加main.c成功</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-20.png" alt = "P4-新建工程-20.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="3-编写mainc插入头文件">3. 编写main.c，插入头文件<a hidden class="anchor" aria-hidden="true" href="#3-编写mainc插入头文件">#</a></h3>
<p>在这个main.c里，我们先右键，插入头文件，选择stm32f10x.h。</p>
<p>图：在main.c中插入头文件</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-21.png" alt = "P4-新建工程-21.png" width = "70%" height = "auto">
</div>
<br>
<p>然后写一个main函数。
按Tab键可以进行缩进，里面写一个while(1)死循环。
这里注意main函数是一个int型返回值，void参数的函数。还有文件的最后一
行必须要是空行，要不然会报警告。</p>
<p>图：在main.c中编写代码</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-22.png" alt = "P4-新建工程-22.png" width = "70%" height = "auto">
</div>
<br>
<h2 id="四编译工程">四、编译工程<a hidden class="anchor" aria-hidden="true" href="#四编译工程">#</a></h2>
<p>然后我们点击这个按钮，编译并建立工程。</p>
<p>图：编译</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-23.png" alt = "P4-新建工程-23.png" width = "70%" height = "auto">
</div>
<br>
<p>图：编译结果 显示1警告 0错误</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-25.png" alt = "P4-新建工程-25.png" width = "70%" height = "auto">
</div>
<br>
<p>为什么这里会显示1警告呢？</p>
<p>点击“魔法棒”，点击“output”，将“Create HEX File”勾选上。</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-24.png" alt = "P4-新建工程-24.png" width = "70%" height = "auto">
</div>
<br>
<p>这样就不会出现警告了。</p>
<p>可以看到下面提示的是零错误，零警告，那这就说明我们建立的工程是没问题的。</p>
<p>这个工程目前还没有添加STM32的库函数，所以它还是一个基于寄存器开发的工程。如果你想用寄存器开发STM32，那工程建到这里就可以了。</p>
<h2 id="五编程前期准备">五、编程前期准备<a hidden class="anchor" aria-hidden="true" href="#五编程前期准备">#</a></h2>
<p>接下来我给大家演示一下如何通过配置寄存器来完成点灯的操作。当然直接操作寄存器的方式不是我们本课程的重点，大家了解一下即可。</p>
<h3 id="1-调大字体">1. 调大字体<a hidden class="anchor" aria-hidden="true" href="#1-调大字体">#</a></h3>
<p>那我们先把这个界面的字体调大点，现在的字体太小，看着不舒服。</p>
<p>我们可以点击这个扳手工具。</p>
<p>图：点击这个扳手工具</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-26.png" alt = "P4-新建工程-26.png" width = "70%" height = "auto">
</div>
<br>
<p>选择颜色和字体，选择C/C++编辑器的选项。然后点击这个按钮把字号调成14。</p>
<p>图：将C/C++编辑器的 Text 字体调整为Size：14</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-28.png" alt = "P4-新建工程-28.png" width = "70%" height = "auto">
</div>
<br>
<p>这个Asm编辑器的字体，我们也把它调成14号了，然后OK，这样字体就变大了。</p>
<p>图：将Asm编辑器的 Default 字体调整为Size：14</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-29.png" alt = "P4-新建工程-29.png" width = "70%" height = "auto">
</div>
<br>
<p>图：调大字体后的效果</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-30.png" alt = "P4-新建工程-30.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="2-设置编码格式">2. 设置编码格式<a hidden class="anchor" aria-hidden="true" href="#2-设置编码格式">#</a></h3>
<p>另外我们再点一下这个扳手工具，把这个编码格式选成UTF8这一项，这样可以防止一些中文乱码的问题。</p>
<p>图：设置编码格式为UTF8</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-31.png" alt = "P4-新建工程-31.png" width = "70%" height = "auto">
</div>
<br>
<p>当然你要打开我的工程，也要把编码格式选为UTF8，否则中文显示就会出现问题。</p>
<p>如果你打开别人的工程，看到中文是乱码的话，可能还需要再改一下这个编码格式。</p>
<h3 id="3-设置tab键的size">3. 设置Tab键的size<a hidden class="anchor" aria-hidden="true" href="#3-设置tab键的size">#</a></h3>
<p>下面这个Tab键的大小，选择4，这个缩进大小我比较习惯，然后点击ok，这样界面看起来就舒服一些。</p>
<p>图：设置Tab size为4</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-32.png" alt = "P4-新建工程-32.png" width = "70%" height = "auto">
</div>
<br>
<p>图：设置Tab size为4后的效果</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-33.png" alt = "P4-新建工程-33.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="4-将stm32最小系统板通过stlink连接电脑">4. 将STM32最小系统板通过STLINK连接电脑<a hidden class="anchor" aria-hidden="true" href="#4-将stm32最小系统板通过stlink连接电脑">#</a></h3>
<p>接着我们需要拿出STM32的最小系统板，STLINK和4根母对母的杜邦线，按照插针边上的标识，把3.3V、SWDIO、SWCLK、GND对应连接好，插好之后就是这个样子的。</p>
<p>图：将STM32的最小系统板连线</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-34.png" alt = "P4-新建工程-34.png" width = "70%" height = "auto">
</div>
<br>
<p>然后把STLINK插在电脑上。插上电之后，这个板子上的电源灯应该会常亮，另一个连接在PC13口上的灯默认应该是闪烁状态，这是芯片里的一个测试程序。</p>
<p>图：把STLINK插在电脑上</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-36.png" alt = "P4-新建工程-36.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="5-在keil里面配置stlink的调试器">5. 在Keil里面配置STLINK的调试器<a hidden class="anchor" aria-hidden="true" href="#5-在keil里面配置stlink的调试器">#</a></h3>
<p>然后我们再在Keil里面配置一下调试器，点击魔术棒按钮，选择Debug。这个调试器默认是ULINK，我们用的是STLINK，所以选择ST-Link Debugger。</p>
<p>图：在Keil中选择调试器为ST-Link Debugger</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-38.png" alt = "P4-新建工程-38.png" width = "70%" height = "auto">
</div>
<br>
<p>然后再点击右边的设置按钮，在Flash下载这一项，把这个Reset and Run这一项勾上，勾上这一项之后，我们下载程序后会立马复位并执行，这样方便一些。</p>
<p>否则每次下载之后，还需要按一下板子上的复位按键才能执行程序。那配置好调试器之后，点击确认，ok。</p>
<p>图：勾选Reset and Run这一项</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-39.png" alt = "P4-新建工程-39.png" width = "70%" height = "auto">
</div>
<br>
<p>然后重新编译一下没有错误，再点击这个LOAD按钮，如果一切正常的话，这个程序就会下载到STM32里面了。</p>
<p>图：下载程序到开发板</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-40.png" alt = "P4-新建工程-40.png" width = "70%" height = "auto">
</div>
<br>
<p>我们看一下板子，可以看到这个灯已经不闪了，因为我们目前的程序啥都没有。</p>
<p>图：下载程序到开发板后，灯不闪了</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-41.png" alt = "P4-新建工程-41.png" width = "70%" height = "auto">
</div>
<br>
<h2 id="六寄存器编程实现点灯">六、寄存器编程实现点灯<a hidden class="anchor" aria-hidden="true" href="#六寄存器编程实现点灯">#</a></h2>
<p>那接下来，我们就配置一下寄存器，来点亮这个灯。我们只需要配置3个寄存器就可以点灯了，我们可以打开STM32的参考手册。</p>
<p>手册为：《STM32F10xxx参考手册（中文）》</p>
<h3 id="1-使能gpioc的时钟">1. 使能GPIOC的时钟<a hidden class="anchor" aria-hidden="true" href="#1-使能gpioc的时钟">#</a></h3>
<p>首先是RCC的一个寄存器，来使能GPIOC的时钟。GPIO都是APB2的外设，所以在这个APB2外设时钟使能寄存器RCC_APB2ENR里面配置。</p>
<p>可以看到，这里有个IOPCEN，这一位就是使能GPIOC的时钟的。下面的解释是，这一位写1，就是打开GPIOC的时钟，那这一位写1，其他的无关项我们先都给0。</p>
<p>图：APB2外设时钟使能寄存器 位4 IOPCEN</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-42.png" alt = "P4-新建工程-42.png" width = "70%" height = "auto">
</div>
<br>
<p>图：APB2外设时钟使能寄存器 位4 IOPCEN 解释</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-43.png" alt = "P4-新建工程-43.png" width = "70%" height = "auto">
</div>
<br>
<p>那整个寄存器的2进制数据换成16进制，就是4个一分组，也就是00000010。</p>
<p>图：寄存器的2进制数据换成16进制，就是4个一分组：0 0 0 0 0 0 1 0</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-44.png" alt = "P4-新建工程-44.png" width = "70%" height = "auto">
</div>
<br>
<p>然后我们回到Keil，在while死循环之前，写上RCC的APB2ENR寄存器=0x00000010，这样就可以打开GPIOC的时钟了。</p>
<p>图：寄存器编程打开GPIOC的时钟</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-45.png" alt = "P4-新建工程-45.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="2-配置pc13口的模式">2. 配置PC13口的模式<a hidden class="anchor" aria-hidden="true" href="#2-配置pc13口的模式">#</a></h3>
<p>然后第二个寄存器，我们需要配置一下PC13口的模式。</p>
<p>我们可以找到端口配置高寄存器，寄存器GPIOLx_CRH，这个x可以是A到E的任意一个字母。</p>
<p>然后右边的CNF13和MODE13就是用来配置13号口的。</p>
<p>图：端口配置高寄存器GPIOLx_CRH，CNF13和MODE13用来配置13号口</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-46.png" alt = "P4-新建工程-46.png" width = "70%" height = "auto">
</div>
<br>
<p>下面的说明我们看一下，这个CNF我们需要配置为通用推挽输出模式，也就是这两位为00。MODE要配置为输出模式，最大速度可以给50MHz，也就是这两位为11。</p>
<p>图：CNF为00 MODE为11</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-47.png" alt = "P4-新建工程-47.png" width = "70%" height = "auto">
</div>
<br>
<p>最后我们对照上面的寄存器，这四位为0011，其他的我们也都给它配置为0。这样整个寄存器的值换算成16进制就是0 0 3 0 0 0 0 0。</p>
<p>图：整个寄存器的值换算成16进制就是0 0 3 0 0 0 0 0</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-48.png" alt = "P4-新建工程-48.png" width = "70%" height = "auto">
</div>
<br>
<p>然后我们回到Keil，在这里写上GPIOC的CRH=0x00300000。</p>
<p>图：寄存器编程配置PC13口的模式</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-49.png" alt = "P4-新建工程-49.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="3-给pc13口输出数据">3. 给PC13口输出数据<a hidden class="anchor" aria-hidden="true" href="#3-给pc13口输出数据">#</a></h3>
<p>接下来我们就可以给PC13口输出数据了。我们可以看到这个端口输出数据寄存器GPIOx_ODR中间有一位ODR13，这一位写1，13号口就是高电平，写0就是低电平。</p>
<p>图：端口输出数据寄存器GPIOx_ODR</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-50.png" alt = "P4-新建工程-50.png" width = "70%" height = "auto">
</div>
<br>
<p>如果写1的话，ODR的值就是00002000。</p>
<p>在这里我们写上GPIOC的ODR=0x00002000。</p>
<p>因为这个灯是低电平点亮的，所以我们给ODR全为0，就是亮。给ODR 0x00002000就是灭。</p>
<p>那我们试一下，先给ODR全0，编译，下载。这时可以看到这个PC13的灯已经亮起来了。</p>
<p>图：给GPIOC-&gt;ODR 全0</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-51.png" alt = "P4-新建工程-51.png" width = "70%" height = "auto">
</div>
<br>
<p>图：给GPIOC-&gt;ODR 全0 PC13灯亮</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-52.png" alt = "P4-新建工程-52.png" width = "70%" height = "auto">
</div>
<br>
<p>如果我们给ODR 2000的话，编译，下载。此时灯就灭了。</p>
<p>图：给GPIOC-&gt;ODR 2000</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-53.png" alt = "P4-新建工程-53.png" width = "70%" height = "auto">
</div>
<br>
<p>图：给GPIOC-&gt;ODR 2000 PC13灯灭</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-54.png" alt = "P4-新建工程-54.png" width = "70%" height = "auto">
</div>
<br>
<p>这就是配置寄存器的方式进行点灯的操作。可以看出来，这种方式需要不断地查手册来了解每个寄存器的每一位都是干啥的。</p>
<p>而且这个操作方式也有个弊端，就是我们把除了PC13之外的位都配置成了0，这样会影响到其他端口的原有配置，如果要做到只配置PC13而不影响其他位，那还需要&amp;=和|=的操作，这个在51单片机的视频里我们也经常遇到。</p>
<p>那这样配置就会更加麻烦。所以这种寄存器的操作方式，虽然代码简洁，但是还是不太方便。</p>
<h2 id="七库函数编程实现点灯">七、库函数编程实现点灯<a hidden class="anchor" aria-hidden="true" href="#七库函数编程实现点灯">#</a></h2>
<p>那接下来我们就要为这个工程添加库函数了，看看库函数数和寄存器的操作方式有哪些区别。</p>
<h3 id="1-在工程文件夹新建library文件夹用来存放库函数">1. 在工程文件夹新建Library文件夹用来存放库函数<a hidden class="anchor" aria-hidden="true" href="#1-在工程文件夹新建library文件夹用来存放库函数">#</a></h3>
<p>我们打开工程文件夹，在这里新建一个文件夹叫Library，用来存放库函数。</p>
<p>图：<code>D:\Keil5Project\STM32Project\2-1 STM32工程模板</code></p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-55.png" alt = "P4-新建工程-55.png" width = "70%" height = "auto">
</div>
<br>
<p>接着打开固件库的文件夹，打开Libraries，STM32标准外设驱动，src，这些就是库函数的源文件。</p>
<p>图：库函数的源文件 <code>D:\江科大 STM32\固件库\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver\src</code></p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-56.png" alt = "P4-新建工程-56.png" width = "70%" height = "auto">
</div>
<br>
<p>这个misc是内核的库函数，其他的就是内核外的外设库函数了。这个misc就是混杂的意思，看来这个ST公司还是不厚道，把内核的库函数都发配到杂项里面去。开个玩笑。</p>
<p>那我们按Ctrl+A全选，然后复制，在Library文件夹下粘贴。</p>
<p>然后再打开固件库的inc文件夹，这些是库函数的头文件。我们继续Ctrl+A全选，然后复制，在Library文件夹下粘贴。</p>
<p>图：加入库函数文件的Library文件夹 <code>D:\Keil5Project\STM32Project\2-1 STM32工程模板\Library</code></p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-57.png" alt = "P4-新建工程-57.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="2-keil工程中新建组library并导入库函数文件">2. Keil工程中新建组Library并导入库函数文件<a hidden class="anchor" aria-hidden="true" href="#2-keil工程中新建组library并导入库函数文件">#</a></h3>
<p>接着回到Keil软件，同样在Target处右键，然后添加组，改个名字叫Library。再右键添加已经存在的文件，把Library文件夹下所有文件加进来。</p>
<p>图：Keil工程中新建组Library</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-58.png" alt = "P4-新建工程-58.png" width = "70%" height = "auto">
</div>
<br>
<p>图：Keil工程中Library导入库函数文件</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-59.png" alt = "P4-新建工程-59.png" width = "70%" height = "auto">
</div>
<br>
<p>这样就把所有的库函数文件都添加进来了。但是对于这个库函数来说，现在还不能直接使用，我们需要再添加一个文件。</p>
<p>我们打开固件库文件夹，打开Project，STM32Template，可以看到stm32f10x_conf.h和两个it结尾的文件。</p>
<p>图：stm32f10x_conf.h和两个it结尾的文件 <code>D:\江科大 STM32\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template</code></p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-60.png" alt = "P4-新建工程-60.png" width = "70%" height = "auto">
</div>
<br>
<p>这个conf(configuration)文件是用来配置库函数头文件的包含关系的。另外这里面还有一个用来参数检查的函数定义，这是所有库函数都需要的.</p>
<p>两个it(interrupt)文件是用来存放中断函数的。我们把这三个文件复制下来，然后粘贴到工程的User目录下。</p>
<p>图：将三个文件粘贴到工程的User目录下  <code>D:\Keil5Project\STM32Project\2-1 STM32工程模板\User</code></p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-61.png" alt = "P4-新建工程-61.png" width = "70%" height = "auto">
</div>
<br>
<p>接着回到Keil软件，在User组里把刚才那三个文件添加进来。</p>
<p>图：Keil工程中在User组里把刚才那三个文件添加进来</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-62.png" alt = "P4-新建工程-62.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="3-keil工程中设置宏定义以及头文件路径">3. Keil工程中设置宏定义以及头文件路径<a hidden class="anchor" aria-hidden="true" href="#3-keil工程中设置宏定义以及头文件路径">#</a></h3>
<p>最后还需要一个宏定义，我们可以在这个头文件右键，打开文件。</p>
<p>图：进入头文件</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-63.png" alt = "P4-新建工程-63.png" width = "70%" height = "auto">
</div>
<br>
<p>然后滑到最下面。</p>
<p>图：stm32f10x.h中的 一个条件编译</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-64.png" alt = "P4-新建工程-64.png" width = "70%" height = "auto">
</div>
<br>
<p>看到这个语句，这是一个条件编译，意思是如果你定义了使用标准外设驱动USE_STDPERIPH_DRIVER这个字符串，下面这个include conf.h语句才有效。</p>
<p>所以我们还需要复制一下这个字符串，然后打开工程选项，在C/C++的Define栏目粘贴这个字符串，这样才能包含标准外设库，也就是库函数。</p>
<p>当然还有下面的头文件路径，也不要忘了把这个User和Library目录的路径也都添加上。</p>
<p>图：设置工程宏定义，设置头文件路径</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-65.png" alt = "P4-新建工程-65.png" width = "70%" height = "auto">
</div>
<br>
<p>然后OK，这样我们基于库函数的工程就建好了。</p>
<p>我们可以看一下这个Library里面的库函数也都带了钥匙，不需要我们更改。我们唯一需要更改的就是User组里面的这些文件。</p>
<h3 id="4-整理工程目录">4. 整理工程目录<a hidden class="anchor" aria-hidden="true" href="#4-整理工程目录">#</a></h3>
<p>我们点一下这个三个箱子的按钮，把这个Library往上挪下，把这些不用改的都放到最上面，这样看着舒服一下。</p>
<p>图：三个箱子 按钮</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-66.png" alt = "P4-新建工程-66.png" width = "70%" height = "auto">
</div>
<br>
<p>图：把Library移上去</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-67.png" alt = "P4-新建工程-67.png" width = "70%" height = "auto">
</div>
<br>
<p>图：把Library移上去的效果</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-68.png" alt = "P4-新建工程-68.png" width = "70%" height = "auto">
</div>
<br>
<p>那我们编译看一下。这个第一次编译会比较慢，以后就快一些。</p>
<p>可以看到是0错误，0警告，这说明我们的工程建立是成功的。</p>
<p>然后我们再用库函数来实现点灯的操作。我们先把这三句删了，库函数其实也是间接的配置寄存器，所以它们的步骤也是一样的。</p>
<h3 id="5-使用rcc_apb2外设时钟控制函数-rcc_apb2periphclockcmd来开启时钟">5. 使用RCC_APB2外设时钟控制函数 RCC_APB2PeriphClockCmd()来开启时钟<a hidden class="anchor" aria-hidden="true" href="#5-使用rcc_apb2外设时钟控制函数-rcc_apb2periphclockcmd来开启时钟">#</a></h3>
<p>首先是使能时钟，那库函数就有这样一个函数来开启时钟，叫RCC_APB2外设时钟控制 RCC_APB2PeriphClockCmd()。然后这里提示有两个参数，第一个是选择外设，第二个是选择新的状态。</p>
<p>图：RCC_APB2外设时钟控制函数 RCC_APB2PeriphClockCmd()</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-69.png" alt = "P4-新建工程-69.png" width = "70%" height = "auto">
</div>
<br>
<p>我们可以右键跳到函数定义 Go To Definition of ，这上面有函数的简介和参数说明。简介说这个函数是用来使能或者失能APB2的外设时钟。</p>
<p>第一个参数可以是下面这些值。那我们可以找到APB2外设GPIOC这一项，然后复制，直接作为第一个参数即可。</p>
<p>然后我们再回过去看第二个参数，NewState的值可以是ENABLE或者DISABLE。那我们复制ENABLE，放在第二个参数的位置。</p>
<p>最后别忘了括号和分号，这样GPIOC的外设时钟就配置好了。</p>
<p>图：在main.c中，使用库函数配置GPIOC的外设时钟</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-70.png" alt = "P4-新建工程-70.png" width = "70%" height = "auto">
</div>
<br>
<p>我们可以看一下这个函数，它的内部其实还是配置RCC_APB2ENR这个寄存器。但是经过函数的包装，我们不需要再去查手册，来确认哪一位是干啥的了。</p>
<p>函数定义：RCC_APB2PeriphClockCmd()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *   This parameter can be any combination of the following values:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11     
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @param  NewState: new state of the specified peripheral clock.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *   This parameter can be: ENABLE or DISABLE.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @retval None
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">RCC_APB2PeriphClockCmd</span>(<span style="color:#66d9ef">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Check the parameters */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert_param</span>(<span style="color:#a6e22e">IS_RCC_APB2_PERIPH</span>(RCC_APB2Periph));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert_param</span>(<span style="color:#a6e22e">IS_FUNCTIONAL_STATE</span>(NewState));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (NewState <span style="color:#f92672">!=</span> DISABLE)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    RCC<span style="color:#f92672">-&gt;</span>APB2ENR <span style="color:#f92672">|=</span> RCC_APB2Periph;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    RCC<span style="color:#f92672">-&gt;</span>APB2ENR <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>RCC_APB2Periph;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而且这里他已经帮我们用|=和&amp;=来操作了。或者这个库函数的配置是不会影响到寄存器的其他位的，这就是库函数和寄存器的区别。</p>
<p>我们看到这个代码虽然比寄存器长，但是语义更加明确，也不需要我们再查表计算这个寄存器的值了。我们只需要调用库函数，按照它的提示把参数填好就行了。所以说从这点对比上来看，库函数是比寄存器有更大优势的。</p>
<p>好，那我们继续来配置。</p>
<h3 id="6-使用gpio_init函数配置端口模式">6. 使用GPIO_Init()函数配置端口模式<a hidden class="anchor" aria-hidden="true" href="#6-使用gpio_init函数配置端口模式">#</a></h3>
<p>第二步是配置端口模式，我们需要用到GPIO_Init这个函数。然后有两个参数，第一个是选择哪个GPIO，第二个是参数的结构体。</p>
<p>这个比上一个函数要麻烦一些，但也是一个套路，我们根据提示来配置参数即可。那我这里来操作一下，这里使用了结构体来配置参数，代码逻辑还是有些复杂的，这个我们下节还会继续讲，大家先跟着我操作就行了。</p>
<p>我们首先还是去到这个函数的定义，可以看到这个函数的介绍是根据GPIO_Init结构体的参数来配置GPIO。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @brief  Initializes the GPIOx peripheral according to the specified
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *         parameters in the GPIO_InitStruct.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *         contains the configuration information for the specified GPIO peripheral.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @retval None
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GPIO_Init</span>(GPIO_TypeDef<span style="color:#f92672">*</span> GPIOx, GPIO_InitTypeDef<span style="color:#f92672">*</span> GPIO_InitStruct)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> currentmode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>, currentpin <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>, pinpos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>, pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> tmpreg <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>, pinmask <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Check the parameters */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert_param</span>(<span style="color:#a6e22e">IS_GPIO_ALL_PERIPH</span>(GPIOx));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert_param</span>(<span style="color:#a6e22e">IS_GPIO_MODE</span>(GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Mode));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert_param</span>(<span style="color:#a6e22e">IS_GPIO_PIN</span>(GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Pin));  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*---------------------------- GPIO Mode Configuration -----------------------*/</span>
</span></span><span style="display:flex;"><span>  currentmode <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uint32_t</span>)GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Mode) <span style="color:#f92672">&amp;</span> ((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x0F</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((((<span style="color:#66d9ef">uint32_t</span>)GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Mode) <span style="color:#f92672">&amp;</span> ((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x10</span>)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x00</span>)
</span></span><span style="display:flex;"><span>  { 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Check the parameters */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert_param</span>(<span style="color:#a6e22e">IS_GPIO_SPEED</span>(GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Speed));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Output mode */</span>
</span></span><span style="display:flex;"><span>    currentmode <span style="color:#f92672">|=</span> (<span style="color:#66d9ef">uint32_t</span>)GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Speed;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*---------------------------- GPIO CRL Configuration ------------------------*/</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Configure the eight low port pins */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (((<span style="color:#66d9ef">uint32_t</span>)GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Pin <span style="color:#f92672">&amp;</span> ((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x00FF</span>)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x00</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    tmpreg <span style="color:#f92672">=</span> GPIOx<span style="color:#f92672">-&gt;</span>CRL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (pinpos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; pinpos <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x08</span>; pinpos<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      pos <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x01</span>) <span style="color:#f92672">&lt;&lt;</span> pinpos;
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* Get the port pins position */</span>
</span></span><span style="display:flex;"><span>      currentpin <span style="color:#f92672">=</span> (GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Pin) <span style="color:#f92672">&amp;</span> pos;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (currentpin <span style="color:#f92672">==</span> pos)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        pos <span style="color:#f92672">=</span> pinpos <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Clear the corresponding low control register bits */</span>
</span></span><span style="display:flex;"><span>        pinmask <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x0F</span>) <span style="color:#f92672">&lt;&lt;</span> pos;
</span></span><span style="display:flex;"><span>        tmpreg <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>pinmask;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Write the mode configuration in the corresponding bits */</span>
</span></span><span style="display:flex;"><span>        tmpreg <span style="color:#f92672">|=</span> (currentmode <span style="color:#f92672">&lt;&lt;</span> pos);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Reset the corresponding ODR bit */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Mode <span style="color:#f92672">==</span> GPIO_Mode_IPD)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          GPIOx<span style="color:#f92672">-&gt;</span>BRR <span style="color:#f92672">=</span> (((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x01</span>) <span style="color:#f92672">&lt;&lt;</span> pinpos);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">/* Set the corresponding ODR bit */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Mode <span style="color:#f92672">==</span> GPIO_Mode_IPU)
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            GPIOx<span style="color:#f92672">-&gt;</span>BSRR <span style="color:#f92672">=</span> (((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x01</span>) <span style="color:#f92672">&lt;&lt;</span> pinpos);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    GPIOx<span style="color:#f92672">-&gt;</span>CRL <span style="color:#f92672">=</span> tmpreg;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*---------------------------- GPIO CRH Configuration ------------------------*/</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Configure the eight high port pins */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Pin <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0x00FF</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    tmpreg <span style="color:#f92672">=</span> GPIOx<span style="color:#f92672">-&gt;</span>CRH;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (pinpos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; pinpos <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x08</span>; pinpos<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      pos <span style="color:#f92672">=</span> (((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x01</span>) <span style="color:#f92672">&lt;&lt;</span> (pinpos <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x08</span>));
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* Get the port pins position */</span>
</span></span><span style="display:flex;"><span>      currentpin <span style="color:#f92672">=</span> ((GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Pin) <span style="color:#f92672">&amp;</span> pos);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (currentpin <span style="color:#f92672">==</span> pos)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        pos <span style="color:#f92672">=</span> pinpos <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Clear the corresponding high control register bits */</span>
</span></span><span style="display:flex;"><span>        pinmask <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x0F</span>) <span style="color:#f92672">&lt;&lt;</span> pos;
</span></span><span style="display:flex;"><span>        tmpreg <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>pinmask;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Write the mode configuration in the corresponding bits */</span>
</span></span><span style="display:flex;"><span>        tmpreg <span style="color:#f92672">|=</span> (currentmode <span style="color:#f92672">&lt;&lt;</span> pos);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Reset the corresponding ODR bit */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Mode <span style="color:#f92672">==</span> GPIO_Mode_IPD)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          GPIOx<span style="color:#f92672">-&gt;</span>BRR <span style="color:#f92672">=</span> (((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x01</span>) <span style="color:#f92672">&lt;&lt;</span> (pinpos <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x08</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Set the corresponding ODR bit */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (GPIO_InitStruct<span style="color:#f92672">-&gt;</span>GPIO_Mode <span style="color:#f92672">==</span> GPIO_Mode_IPU)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          GPIOx<span style="color:#f92672">-&gt;</span>BSRR <span style="color:#f92672">=</span> (((<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x01</span>) <span style="color:#f92672">&lt;&lt;</span> (pinpos <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x08</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    GPIOx<span style="color:#f92672">-&gt;</span>CRH <span style="color:#f92672">=</span> tmpreg;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="gpio_init函数分析">GPIO_Init()函数分析<a hidden class="anchor" aria-hidden="true" href="#gpio_init函数分析">#</a></h4>
<p>这个函数是STM32微控制器的库函数，用于初始化GPIO（通用输入输出）端口。GPIO端口可以被配置为不同的模式，用于输入、输出或者作为其他功能的接口。</p>
<h5 id="函数的原型是">函数的原型是：<a hidden class="anchor" aria-hidden="true" href="#函数的原型是">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GPIO_Init</span>(GPIO_TypeDef<span style="color:#f92672">*</span> GPIOx, GPIO_InitTypeDef<span style="color:#f92672">*</span> GPIO_InitStruct);
</span></span></code></pre></div><h5 id="参数说明">参数说明：<a hidden class="anchor" aria-hidden="true" href="#参数说明">#</a></h5>
<ol>
<li><code>GPIOx</code>: 一个指向GPIO端口的指针，其中<code>x</code>可以是A到G之间的字母，代表不同的GPIO端口。</li>
<li><code>GPIO_InitStruct</code>: 一个指向<code>GPIO_InitTypeDef</code>结构体的指针，该结构体包含了要初始化的GPIO端口的配置信息。</li>
</ol>
<ul>
<li><code>GPIOA</code> 是一个指向GPIOA端口的指针，所以它本身就是一个地址，不需要加上<code>&amp;</code>。</li>
<li><code>GPIO_InitStructure</code> 是一个<code>GPIO_InitTypeDef</code>类型的结构体变量，当你想传递这个结构体到函数中时，你需要传递它的地址，因此前面需要加上<code>&amp;</code>。</li>
</ul>
<h5 id="函数功能">函数功能：<a hidden class="anchor" aria-hidden="true" href="#函数功能">#</a></h5>
<ul>
<li>初始化指定的GPIO端口，根据<code>GPIO_InitStruct</code>中提供的配置信息。</li>
<li>配置GPIO端口的工作模式（如输入、输出、上拉/下拉等）。</li>
<li>配置输出速度（如果端口被配置为输出）。</li>
</ul>
<h5 id="使用方法">使用方法：<a hidden class="anchor" aria-hidden="true" href="#使用方法">#</a></h5>
<ol>
<li>定义一个<code>GPIO_InitTypeDef</code>类型的变量(结构体实例)，并设置其成员，以指定要初始化的GPIO端口的配置。</li>
<li>调用<code>GPIO_Init</code>函数，传入GPIO端口的地址和配置结构体的地址。</li>
</ol>
<p><code>GPIO_InitTypeDef</code>：</p>
<p><code>GPIO_InitTypeDef</code> 是一个结构体类型，用于定义GPIO端口的初始化参数。当您需要初始化一个GPIO端口时，您需要创建一个这种类型的变量（通常称为结构体实例），我们一般命名这个结构体实例为<code>GPIO_InitStructure</code>，并设置其成员变量，以指定您希望如何配置GPIO端口。</p>
<h5 id="示例">示例：<a hidden class="anchor" aria-hidden="true" href="#示例">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>GPIO_InitTypeDef GPIO_InitStructure;
</span></span><span style="display:flex;"><span>GPIO_InitStructure.GPIO_Pin <span style="color:#f92672">=</span> GPIO_Pin_0;  <span style="color:#75715e">// 设置要初始化的引脚，这里以GPIO的第0个引脚为例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>GPIO_InitStructure.GPIO_Mode <span style="color:#f92672">=</span> GPIO_Mode_Out_PP;  <span style="color:#75715e">// 设置为推挽输出模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>GPIO_InitStructure.GPIO_Speed <span style="color:#f92672">=</span> GPIO_Speed_50MHz;  <span style="color:#75715e">// 设置输出速度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">GPIO_Init</span>(GPIOA, <span style="color:#f92672">&amp;</span>GPIO_InitStructure);  <span style="color:#75715e">// 对GPIOA的第0个引脚进行初始化
</span></span></span></code></pre></div><h5 id="函数内部分析">函数内部分析：<a hidden class="anchor" aria-hidden="true" href="#函数内部分析">#</a></h5>
<ul>
<li>函数首先通过断言（<code>assert_param</code>）检查传入的参数是否有效。</li>
<li>然后，它根据<code>GPIO_InitStruct</code>中的模式和速度设置，计算出当前模式的值，并根据引脚是低8位还是高8位来配置相应的控制寄存器（CRL或CRH）。</li>
<li>如果模式是输入且带有上拉或下拉，则会设置或重置ODR（输出数据寄存器）相应的位。</li>
</ul>
<h5 id="对小白的讲解">对小白的讲解：<a hidden class="anchor" aria-hidden="true" href="#对小白的讲解">#</a></h5>
<p>想象一下，GPIO端口就像你家的电灯开关，你可以通过不同的方式控制它。这个函数就是用来告诉你的STM32微控制器，如何正确地设置这个开关。你需要告诉微控制器，你想要控制的是哪一个开关（通过<code>GPIOx</code>指定），以及你想要如何控制它（通过<code>GPIO_InitStruct</code>中的配置）。</p>
<p>例如，如果你想要一个开关可以控制LED灯的亮和灭，你就需要设置这个开关为输出模式，并且告诉微控制器，当输出高电平时LED亮，输出低电平时LED灭。</p>
<h4 id="gpio_init函数代码使用">GPIO_Init()函数代码使用<a hidden class="anchor" aria-hidden="true" href="#gpio_init函数代码使用">#</a></h4>
<h5 id="第一个参数gpiox">第一个参数GPIOx<a hidden class="anchor" aria-hidden="true" href="#第一个参数gpiox">#</a></h5>
<p>第一个参数GPIOx，其中x可以是A到G，来选择你要配置哪个GPLIO，那我们是PC13口的LED，所以第一个参数就写GPIOC。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>@param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
</span></span></code></pre></div><h5 id="第二个参数是一个gpio_inittypedef类型的结构体变量">第二个参数是一个GPIO_InitTypeDef类型的结构体变量<a hidden class="anchor" aria-hidden="true" href="#第二个参数是一个gpio_inittypedef类型的结构体变量">#</a></h5>
<p>第二个参数是一个GPIO_InitTypeDef类型的结构体变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>@param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
</span></span><span style="display:flex;"><span>  *         contains the configuration information for the specified GPIO peripheral.
</span></span></code></pre></div><p>我们需要先定义一个结构体，在上面我们先把这个结构体的类型写上，然后给结构体起个名字。这个名字可以随便起，但是根据官方的推荐，我们最好起这样的名字，叫GPIO_InitStructure。</p>
<p>然后我们把结构体的每一个参数填上，复制粘贴结构体的名字，然后用点来引出结构体的参数。可以看到这个结构体有三个参数，分别是GPIO模式、GPIO端口、GPIO速度。我们先把这三个参数都罗列出来。</p>
<h6 id="gpio_inittypedef-结构体类型的定义">GPIO_InitTypeDef (结构体类型)的定义：<a hidden class="anchor" aria-hidden="true" href="#gpio_inittypedef-结构体类型的定义">#</a></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint16_t</span> GPIO_Pin;             <span style="color:#75715e">/*!&lt; Specifies the GPIO pins to be configured.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                      This parameter can be any value of @ref GPIO_pins_define */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  GPIOSpeed_TypeDef GPIO_Speed;  <span style="color:#75715e">/*!&lt; Specifies the speed for the selected pins.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  GPIOMode_TypeDef GPIO_Mode;    <span style="color:#75715e">/*!&lt; Specifies the operating mode for the selected pins.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span>
</span></span><span style="display:flex;"><span>}GPIO_InitTypeDef;
</span></span></code></pre></div><p>💡知识回顾：C语言中typedef结构体的用法</p>
<p>在C语言中，<code>typedef</code> 结合结构体定义是一种非常实用的特性，用于为结构体创建一个更简洁、更易读的别名。这不仅让代码更加清晰，也使得程序员在声明和使用结构体变量时更为便捷。下面详细介绍其用法：</p>
<p><strong>一、基本语法</strong></p>
<p>基本的 <code>typedef</code> 结构体定义语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> tag {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 结构体成员定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#960050;background-color:#1e0010">数据类型</span> <span style="color:#960050;background-color:#1e0010">成员名</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">数据类型</span> <span style="color:#960050;background-color:#1e0010">成员名</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>} <span style="color:#960050;background-color:#1e0010">自定义类型名</span>;
</span></span></code></pre></div><ul>
<li><strong>tag</strong>：这是结构体的标签，可选的，用于指明结构体的类型。在 <code>typedef</code> 语句中，这个标签有时会被省略，特别是在你不需要直接通过结构体标签来声明变量时。</li>
<li><strong>自定义类型名</strong>：这是通过 <code>typedef</code> 关键字创建的新类型名称，之后可以用这个名称直接声明结构体变量，无需再写 <code>struct</code> 关键字。</li>
</ul>
<p><strong>二、简化定义与使用</strong></p>
<p>1、完整示例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Point {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span>} PointType;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PointType p1, p2; <span style="color:#75715e">// 直接使用PointType声明变量p1和p2
</span></span></span></code></pre></div><p>在这个例子中，<code>struct Point</code> 定义了一个包含两个整型成员 <code>x</code> 和 <code>y</code> 的结构体，<code>typedef</code> 则为这个结构体定义了一个别名 <code>PointType</code>。之后就可以直接使用 <code>PointType</code> 来声明结构体变量，而不需要写成 <code>struct Point</code> 形式。</p>
<p>2、匿名结构体与typedef</p>
<p>有时，结构体定义中不提供标签，这时 <code>typedef</code> 更显得尤为重要，因为它允许你为匿名结构体提供一个类型名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> b;
</span></span><span style="display:flex;"><span>} MyStruct;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyStruct example; <span style="color:#75715e">// 使用MyStruct声明变量
</span></span></span></code></pre></div><p><strong>三、优点</strong></p>
<ul>
<li><strong>提高代码可读性</strong>：通过给复杂的结构体类型起一个有意义的名字，可以让其他阅读代码的人更容易理解其用途。</li>
<li><strong>简化声明</strong>：直接使用类型别名声明变量，代码更简洁，减少出错机会。</li>
<li><strong>便于维护和扩展</strong>：修改结构体定义时，只需更改一处即可全局生效，尤其是当该类型被广泛使用时。</li>
</ul>
<p><strong>四、注意事项</strong></p>
<ul>
<li>当定义结构体成员时，注意对齐和大小端问题，可能影响内存使用效率。</li>
<li>如果结构体较大，考虑使用指针而非直接实例化，以节省栈空间。</li>
<li>虽然 <code>typedef</code> 可以让代码更易读，过度使用也可能导致代码难以理解，特别是当类型名没有清晰表达其含义时。</li>
</ul>
<p>通过合理利用 <code>typedef</code> 结构体定义，可以使C语言的编程更加高效、清晰。</p>
<p>所以在这里，<code>GPIO_InitTypeDef</code>等价为<code>struct</code>，代表结构体类型。</p>
<p><code>GPIO_InitTypeDef GPIO_InitStructure;</code> 也就意味着创建了一个结构体实例<code>GPIO_InitStructure</code>。</p>
<h6 id="gpio_initstructuregpio_mode">GPIO_InitStructure.GPIO_Mode<a hidden class="anchor" aria-hidden="true" href="#gpio_initstructuregpio_mode">#</a></h6>
<p>代码：GPIO_Mode的定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint16_t</span> GPIO_Pin;             <span style="color:#75715e">/*!&lt; Specifies the GPIO pins to be configured.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                      This parameter can be any value of @ref GPIO_pins_define */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  GPIOSpeed_TypeDef GPIO_Speed;  <span style="color:#75715e">/*!&lt; Specifies the speed for the selected pins.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  GPIOMode_TypeDef GPIO_Mode;    <span style="color:#75715e">/*!&lt; Specifies the operating mode for the selected pins.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span>
</span></span><span style="display:flex;"><span>}GPIO_InitTypeDef;
</span></span></code></pre></div><p>这右边的介绍说，这个参数可以是GPIOMode_TypeDef里面的一个值。因为这是注释里面的东西，所以没办法用右键跳转了。</p>
<p>那这里我们需要选中GPIOMode_TypeDef这个字符，按一下Ctrl+F，搜索一下这个定义的位置。点击find next，可以看到这是个枚举。GPIOMode就是这里的其中一个值。</p>
<p>图：搜索GPIOMode_TypeDef</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-75.png" alt = "P4-新建工程-75.png" width = "70%" height = "auto">
</div>
<br>
<p>代码：GPIOMode_TypeDef 的定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span>
</span></span><span style="display:flex;"><span>{ GPIO_Mode_AIN <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>,
</span></span><span style="display:flex;"><span>  GPIO_Mode_IN_FLOATING <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x04</span>,
</span></span><span style="display:flex;"><span>  GPIO_Mode_IPD <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x28</span>,
</span></span><span style="display:flex;"><span>  GPIO_Mode_IPU <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x48</span>,
</span></span><span style="display:flex;"><span>  GPIO_Mode_Out_OD <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x14</span>,
</span></span><span style="display:flex;"><span>  GPIO_Mode_Out_PP <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x10</span>,
</span></span><span style="display:flex;"><span>  GPIO_Mode_AF_OD <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1C</span>,
</span></span><span style="display:flex;"><span>  GPIO_Mode_AF_PP <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x18</span>
</span></span><span style="display:flex;"><span>}GPIOMode_TypeDef;
</span></span></code></pre></div><p>然后我们选择Out_PP这一项，复制，这个就是通用推挽输出。</p>
<p>然后在这里写上GPIO_Mode_Out_PP，这样这个参数就配置好了。</p>
<p>编写代码：main.c中配置好了GPIO_InitStructure.GPIO_Mode</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;stm32f10x.h&#34;                  // Device header</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOC,ENABLE);
</span></span><span style="display:flex;"><span>	GPIO_InitTypeDef GPIO_InitStructure;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Mode <span style="color:#f92672">=</span> GPIO_Mode_Out_PP;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Pin <span style="color:#f92672">=</span> ;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Speed <span style="color:#f92672">=</span> ;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">GPIO_Init</span>(GPIOC,);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="gpio_initstructuregpio_pin">GPIO_InitStructure.GPIO_Pin<a hidden class="anchor" aria-hidden="true" href="#gpio_initstructuregpio_pin">#</a></h6>
<p>然后我们继续看一下下一个参数，转到它的定义这里下面出现了一个框，这个是说它的定义有很多个。</p>
<p>图：GPIO_Pin的定义有很多个</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-76.png" alt = "P4-新建工程-76.png" width = "70%" height = "auto">
</div>
<br>
<p>我们来看一下，我们选择这个member这一项，双击，然后跳转的其实还是刚才那个位置。</p>
<p>图：双击 GPIO_Pin的member这一项</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-77.png" alt = "P4-新建工程-77.png" width = "70%" height = "auto">
</div>
<br>
<p>代码：GPIO_Pin的定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint16_t</span> GPIO_Pin;             <span style="color:#75715e">/*!&lt; Specifies the GPIO pins to be configured.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                      This parameter can be any value of @ref GPIO_pins_define */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  GPIOSpeed_TypeDef GPIO_Speed;  <span style="color:#75715e">/*!&lt; Specifies the speed for the selected pins.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  GPIOMode_TypeDef GPIO_Mode;    <span style="color:#75715e">/*!&lt; Specifies the operating mode for the selected pins.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span>
</span></span><span style="display:flex;"><span>}GPIO_InitTypeDef;
</span></span></code></pre></div><p>然后看一下这个GPIO_Pin的说明，他说这个参数在GPIO_pins_define里面定义了，我们还是一样选中，Ctrl+F，find next。</p>
<p>可以看到这里有个宏定义的列表，我们选择GPIO_Pin_13，复制，然后填在第二个位置。</p>
<p>代码：stm32f10x_gpio.h中GPIO_pins_define</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/** @defgroup GPIO_pins_define 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_0                 ((uint16_t)0x0001)  </span><span style="color:#75715e">/*!&lt; Pin 0 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_1                 ((uint16_t)0x0002)  </span><span style="color:#75715e">/*!&lt; Pin 1 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_2                 ((uint16_t)0x0004)  </span><span style="color:#75715e">/*!&lt; Pin 2 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_3                 ((uint16_t)0x0008)  </span><span style="color:#75715e">/*!&lt; Pin 3 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_4                 ((uint16_t)0x0010)  </span><span style="color:#75715e">/*!&lt; Pin 4 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_5                 ((uint16_t)0x0020)  </span><span style="color:#75715e">/*!&lt; Pin 5 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_6                 ((uint16_t)0x0040)  </span><span style="color:#75715e">/*!&lt; Pin 6 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_7                 ((uint16_t)0x0080)  </span><span style="color:#75715e">/*!&lt; Pin 7 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_8                 ((uint16_t)0x0100)  </span><span style="color:#75715e">/*!&lt; Pin 8 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_9                 ((uint16_t)0x0200)  </span><span style="color:#75715e">/*!&lt; Pin 9 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_10                ((uint16_t)0x0400)  </span><span style="color:#75715e">/*!&lt; Pin 10 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_11                ((uint16_t)0x0800)  </span><span style="color:#75715e">/*!&lt; Pin 11 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_12                ((uint16_t)0x1000)  </span><span style="color:#75715e">/*!&lt; Pin 12 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_13                ((uint16_t)0x2000)  </span><span style="color:#75715e">/*!&lt; Pin 13 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_14                ((uint16_t)0x4000)  </span><span style="color:#75715e">/*!&lt; Pin 14 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_15                ((uint16_t)0x8000)  </span><span style="color:#75715e">/*!&lt; Pin 15 selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_Pin_All               ((uint16_t)0xFFFF)  </span><span style="color:#75715e">/*!&lt; All pins selected */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IS_GPIO_PIN(PIN) ((((PIN) &amp; (uint16_t)0x00) == 0x00) &amp;&amp; ((PIN) != (uint16_t)0x00))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_1) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_2) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_3) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_4) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_5) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_6) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_7) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_8) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_9) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_10) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_11) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_12) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_13) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_14) || \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                              ((PIN) == GPIO_Pin_15))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span></code></pre></div><p>编写代码：main.c中配置好了GPIO_InitStructure.GPIO_Pin</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;stm32f10x.h&#34;                  // Device header</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOC,ENABLE);
</span></span><span style="display:flex;"><span>	GPIO_InitTypeDef GPIO_InitStructure;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Mode <span style="color:#f92672">=</span> GPIO_Mode_Out_PP;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Pin <span style="color:#f92672">=</span> GPIO_Pin_13;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Speed <span style="color:#f92672">=</span> ;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">GPIO_Init</span>(GPIOC,);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="gpio_initstructuregpio_speed">GPIO_InitStructure.GPIO_Speed<a hidden class="anchor" aria-hidden="true" href="#gpio_initstructuregpio_speed">#</a></h6>
<p>第三个参数也是一样，右键，跳到定义，选中，Ctrl+F， find next。</p>
<p>代码：stm32f10x_gpio.h中GPIOSpeed_TypeDef</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span>
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>  GPIO_Speed_10MHz <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>  GPIO_Speed_2MHz, 
</span></span><span style="display:flex;"><span>  GPIO_Speed_50MHz
</span></span><span style="display:flex;"><span>}GPIOSpeed_TypeDef;
</span></span></code></pre></div><p>在这里选中50MHz的速度复制，在这里粘贴，最后别忘了分号。</p>
<p>编写代码：main.c中配置好了GPIO_InitStructure.GPIO_Speed</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;stm32f10x.h&#34;                  // Device header</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOC,ENABLE);
</span></span><span style="display:flex;"><span>	GPIO_InitTypeDef GPIO_InitStructure;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Mode <span style="color:#f92672">=</span> GPIO_Mode_Out_PP;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Pin <span style="color:#f92672">=</span> GPIO_Pin_13;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Speed <span style="color:#f92672">=</span> GPIO_Speed_50MHz;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">GPIO_Init</span>(GPIOC,);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>那结构体变量就有了，我们就可以填这个GPIO_Init的第二个参数了。在这里有说明，这个第二个参数是一个指向结构体的指针，所以这里我们需要传递结构体的地址。</p>
<p>那我们复制结构体的名字粘贴到这个位置，然后前面加上一个取地址(&amp;)的符号，最后打成一个右括号，分号，这个GPIO模式配置就完成了。</p>
<p>编写代码：GPIO模式配置完成</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;stm32f10x.h&#34;                  // Device header</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOC,ENABLE);
</span></span><span style="display:flex;"><span>	GPIO_InitTypeDef GPIO_InitStructure;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Mode <span style="color:#f92672">=</span> GPIO_Mode_Out_PP;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Pin <span style="color:#f92672">=</span> GPIO_Pin_13;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Speed <span style="color:#f92672">=</span> GPIO_Speed_50MHz;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">GPIO_Init</span>(GPIOC,<span style="color:#f92672">&amp;</span>GPIO_InitStructure);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个配置的操作方式看上去比较难理解，但是STM32的这种方式都是固定的，大家多打几次就知道怎么用了。</p>
<p>最后我们设置端口的高低电平来进行点灯。这里有个函数GPIO_SetBits，这个就可以把指定端口设置为高电平。大家也可以右键去看一下参数的说明，那这里我就直接填了。</p>
<p>第一个是GPIOC，第二个是GPIO_Pin_13。这一句就可以将PC13号口置为高电平，接下来自低电瓶也有函数叫GPIO_ResetBits。参数同样是GPIO_Pin_13，这一句就可以将PC13号口置为低电平。</p>
<p>那我们依次试一下，我们先把高电平的注释掉。编译。下载。</p>
<p>编写代码：设置PC13号口为低电平，点亮LED灯</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;stm32f10x.h&#34;                  // Device header</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOC,ENABLE);
</span></span><span style="display:flex;"><span>	GPIO_InitTypeDef GPIO_InitStructure;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Mode <span style="color:#f92672">=</span> GPIO_Mode_Out_PP;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Pin <span style="color:#f92672">=</span> GPIO_Pin_13;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Speed <span style="color:#f92672">=</span> GPIO_Speed_50MHz;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">GPIO_Init</span>(GPIOC,<span style="color:#f92672">&amp;</span>GPIO_InitStructure);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//GPIO_SetBits(GPIOC,GPIO_Pin_13);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">GPIO_ResetBits</span>(GPIOC,GPIO_Pin_13);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到灯已经亮了。</p>
<p>图：PC13号口的LED灯亮</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-78.png" alt = "P4-新建工程-78.png" width = "70%" height = "auto">
</div>
<br>
<p>再把低电平的注释掉，编译。</p>
<p>编写代码：设置PC13号口为高电平，熄灭LED灯</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;stm32f10x.h&#34;                  // Device header</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOC,ENABLE);
</span></span><span style="display:flex;"><span>	GPIO_InitTypeDef GPIO_InitStructure;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Mode <span style="color:#f92672">=</span> GPIO_Mode_Out_PP;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Pin <span style="color:#f92672">=</span> GPIO_Pin_13;
</span></span><span style="display:flex;"><span>	GPIO_InitStructure.GPIO_Speed <span style="color:#f92672">=</span> GPIO_Speed_50MHz;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">GPIO_Init</span>(GPIOC,<span style="color:#f92672">&amp;</span>GPIO_InitStructure);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">GPIO_SetBits</span>(GPIOC,GPIO_Pin_13);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//GPIO_ResetBits(GPIOC,GPIO_Pin_13);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到灯就灭了。</p>
<p>图：PC13号口的LED灯灭</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-79.png" alt = "P4-新建工程-79.png" width = "70%" height = "auto">
</div>
<br>
<p>这就是使用库函数的基本操作了。这节把下节的课也带着讲了。这至于STM32 GPIO口的结构，结构体和库函数的操作，这些我们下节再详细解释。</p>
<p>本节我们先来用一下，来测试一下我们的工程。</p>
<p>有关新建工程的部分，我们这节大概就介绍完了。最后还要补充几点，来看一下PPT。</p>
<h2 id="新建工程里启动文件的选择">新建工程里启动文件的选择<a hidden class="anchor" aria-hidden="true" href="#新建工程里启动文件的选择">#</a></h2>
<p>首先是新建工程里的启动文件选择，我们新建工程第一个加的就是启动文件。这个启动文件有很多类型，至于选择哪一个，我们要根据芯片型号来选择。</p>
<p>图：STM32F1系列的启动文件一览</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-81.png" alt = "P4-新建工程-81.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="stm32f1系列型号分类表">STM32F1系列型号分类表<a hidden class="anchor" aria-hidden="true" href="#stm32f1系列型号分类表">#</a></h3>
<p>我们看到这个表，这里是STM32F1系列中的型号分类。</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-80.png" alt = "P4-新建工程-80.png" width = "70%" height = "auto">
</div>
<br>
<p>其中根据Flash的大小，分为了小容量产品，Flash为16~32K，简写为LD(Low Density)。</p>
<p>中容量产品，Flash为16~128K，简写为MD(Medium Density)。</p>
<p>大容量产品，Flash为256~512克，简写为HD(High Density)。</p>
<p>加大容量产品，Flash大于512K，简写为XL(EXtra Large)。</p>
<p>那STM32F100的系列，ST把它叫做超值系列，简写为VL(Value Line)。</p>
<p>SDM32F105和107。ST把它叫做互联型产品(CL, Connectivity Line)。这个就没有根据Flash大小再分类了。</p>
<p>所以就有了这个表。</p>
<h3 id="stm32f1系列型号分类表的使用">STM32F1系列型号分类表的使用<a hidden class="anchor" aria-hidden="true" href="#stm32f1系列型号分类表的使用">#</a></h3>
<p><strong>1、STM32F100型号</strong><br>
如果你使用STM32F100的型号，就选择带VL的启动文件，然后再根据Flash的大小选择LD、MD还是HD。</p>
<p><strong>2、STM32F101/102/103的型号</strong><br>
如果你使用STM32F101/102/103的型号，就选择不带VL的，然后根据Flash的大小选择LD、MD、HD还是XL。</p>
<p><strong>3、STM3F105/107的型号</strong><br>
如果你使用STM3F105/107的型号，直接选择CL的启动文件即可。</p>
<p>那在这里我们可以看一下，这个启动文件后面带的字母和我这个表的字母都是对应的。</p>
<p>这样我们就知道了我们这个STM32F103的芯片就需要选择这四列(LD、MD、HD还是XL)。又因为C8T6的Flash是64K所以选择MD的启动文件(也就是startup_stm32f10x_md.s)。</p>
<p>这就是STM32F1系列的型号分类和启动文件的选取。</p>
<h2 id="新建工程步骤">新建工程步骤<a hidden class="anchor" aria-hidden="true" href="#新建工程步骤">#</a></h2>
<p>接下来我们再总结一下新建工程的步骤。</p>
<h3 id="第一步">第一步<a hidden class="anchor" aria-hidden="true" href="#第一步">#</a></h3>
<p>第一步、建立工程文件夹，Keil中新建工程，选择型号。</p>
<h3 id="第二步">第二步<a hidden class="anchor" aria-hidden="true" href="#第二步">#</a></h3>
<p>第二步、工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹。</p>
<p>这一步是为了添加工程文件准备的。建文件夹是因为文件比较多，需要分类管理一下。</p>
<p>这个文件夹的名称和数量没有限制，大家也可以根据自己的理解来建，这都是可以的。</p>
<p>另外需要用的文件一定要复制到工程文件夹里面来，不要添加工程文件夹外面的文件，要不然你外面的文件一旦挪位置，工程里就找不到文件了。所以我们要复制文件到工程里来，保持工程的独立性。</p>
<h3 id="第三步">第三步<a hidden class="anchor" aria-hidden="true" href="#第三步">#</a></h3>
<p>第三步、工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里。</p>
<p>这一步的原因是在Keil里方便管理文件，因为Keil没法直接添加文件夹，所以还得重复一下。</p>
<p>这个添加文件我是把所有的.h文件和.c文件都添加进来了。因为.h文件是不参与编译的，所以其他很多工程都是不添加.h文件的。</p>
<p>但是我认为把.h文件加进来比较方便，而且.h文件也是需要经常打开看的，所以我比较习惯把所有的文件都添加进来。</p>
<h3 id="第四步">第四步<a hidden class="anchor" aria-hidden="true" href="#第四步">#</a></h3>
<p>第四步、工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹</p>
<p>这一步是因为你这个Start、Library等文件夹是你自己建的，Keil软件它并不知道。所以你要用自己文件夹里面的.h文件，就必须声明一下这个路径，那最好就是你自己建的所有文件夹都声明一下，这样就不会出现.h文件找不到的问题了。</p>
<h3 id="第五步">第五步<a hidden class="anchor" aria-hidden="true" href="#第五步">#</a></h3>
<p>第五步、工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER(标准外设驱动)，使用标准外设驱动这个字符串。</p>
<p>这是使用库函数的条件编译，使用库函数就必须定义这个。另外其他的工程在这个位置还声明了一个STM32F10X_MD的字符串。</p>
<p>那根据我的调查，Keil5在新建工程后自动就帮我们声明好了，这个不需要再额外申请声明了。所以在这个位置只需要声明使用USE_STDPERIPH_DRIVER(标准外设驱动)的字符串即可。</p>
<h3 id="第六步">第六步<a hidden class="anchor" aria-hidden="true" href="#第六步">#</a></h3>
<p>第六步、工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download里勾选Reset and Run。</p>
<p>这个就是选择调试器来进行下载的选项了。我们用STLINK就选择STLINK的那一项即可。</p>
<h3 id="结束">结束<a hidden class="anchor" aria-hidden="true" href="#结束">#</a></h3>
<p>这就是新建工程的基本步骤。新建工程也是很灵活的，大家只要符合要求，都可以编译通过。每个人建工程的风格也不同，大家学会了之后也可以建立一个属于自己风格的工程。</p>
<h2 id="工程架构">工程架构<a hidden class="anchor" aria-hidden="true" href="#工程架构">#</a></h2>
<p>最后我再额外的讲一下这个工程的架构，来看一下这个工程的每个文件都是干啥的，为啥需要这些文件？</p>
<p>图：工程架构</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-82.png" alt = "P4-新建工程-82.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="startup启动文件">startup启动文件<a hidden class="anchor" aria-hidden="true" href="#startup启动文件">#</a></h3>
<p>我们看到这个图，首先是startup启动文件，这个是程序执行的最基本的文件。</p>
<p>图：Keil中启动文件</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-83.png" alt = "P4-新建工程-83.png" width = "70%" height = "auto">
</div>
<br>
<p>我们可以看到Keil中启动文件是用汇编写的，启动文件内定义了中断向量表、中断服务函数等。</p>
<p>这个中断服务函数中有个复位中断，这就是整个程序的入口，当STM32上电复位或者按下复位按键之后，程序就会进入复位中断函数执行。</p>
<p>复位中断函数主要就做了两件事情。第一个是调用SystemInit函数，第二个是调用main函数。</p>
<p>图：复位中断函数</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-90.png" alt = "P4-新建工程-90.png" width = "70%" height = "auto">
</div>
<br>
<p>对应启动文件的这里。</p>
<p>图：startup_stm32f10x_md.s中 复位中断函数</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-84.png" alt = "P4-新建工程-84.png" width = "70%" height = "auto">
</div>
<br>
<p>这里可以看到这是复位的中断函数，然后调用SystemInit，再调用main，然后程序就结束了。</p>
<p>当然实际上单片机的程序永远也不会结束，所以在main函数的最后一定是一个死循环。</p>
<p>图：main.c中 while(1)死循环</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-85.png" alt = "P4-新建工程-85.png" width = "70%" height = "auto">
</div>
<br>
<p>SystemInit函数就是定义在这个system开头的.c文件里的。</p>
<p>那在Keil里我们也可以看到这个函数的定义。</p>
<p>这里的简介写了这个函数的作用，是设置微控制器的启动，初始化嵌入式闪存接口、锁相环、更新系统内核的时钟变量。</p>
<p>下面的note写的是这个函数仅在复位后需要调用。</p>
<p>那下面这些就是用来配置这些东西的，这个也不需要我们更改，我们只需要知道在main函数之前，单片机就已经执行了一堆东西了。</p>
<p>帮我们把这个闪存接口、时钟等一系列杂碎的东西都配置好了。</p>
<p>代码：system_stm32f10x.c中SystemInit函数定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @brief  Setup the microcontroller system
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *         Initialize the Embedded Flash Interface, the PLL and update the 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  *         SystemCoreClock variable.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @note   This function should be used only after reset.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @param  None
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * @retval None
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SystemInit</span> (<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Reset the RCC clock configuration to the default reset state(for debug purpose) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Set HSION bit */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CR <span style="color:#f92672">|=</span> (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x00000001</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef STM32F10X_CL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  RCC<span style="color:#f92672">-&gt;</span>CFGR <span style="color:#f92672">&amp;=</span> (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0xF8FF0000</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  RCC<span style="color:#f92672">-&gt;</span>CFGR <span style="color:#f92672">&amp;=</span> (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0xF0FF0000</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* STM32F10X_CL */</span><span style="color:#75715e">   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Reset HSEON, CSSON and PLLON bits */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CR <span style="color:#f92672">&amp;=</span> (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0xFEF6FFFF</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Reset HSEBYP bit */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CR <span style="color:#f92672">&amp;=</span> (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0xFFFBFFFF</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CFGR <span style="color:#f92672">&amp;=</span> (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0xFF80FFFF</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef STM32F10X_CL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">/* Reset PLL2ON and PLL3ON bits */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CR <span style="color:#f92672">&amp;=</span> (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0xEBFFFFFF</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Disable all interrupts and clear pending bits  */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CIR <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00FF0000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Reset CFGR2 register */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CFGR2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000000</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">/* Disable all interrupts and clear pending bits  */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CIR <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x009F0000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Reset CFGR2 register */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CFGR2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000000</span>;      
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">/* Disable all interrupts and clear pending bits  */</span>
</span></span><span style="display:flex;"><span>  RCC<span style="color:#f92672">-&gt;</span>CIR <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x009F0000</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* STM32F10X_CL */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">#ifdef DATA_IN_ExtSRAM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">SystemInit_ExtMemCtl</span>(); 
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">#</span>endif <span style="color:#75715e">/* DATA_IN_ExtSRAM */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Configure the Flash Latency cycles and enable prefetch buffer */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SetSysClock</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef VECT_TAB_SRAM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  SCB<span style="color:#f92672">-&gt;</span>VTOR <span style="color:#f92672">=</span> SRAM_BASE <span style="color:#f92672">|</span> VECT_TAB_OFFSET; <span style="color:#75715e">/* Vector Table Relocation in Internal SRAM. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  SCB<span style="color:#f92672">-&gt;</span>VTOR <span style="color:#f92672">=</span> FLASH_BASE <span style="color:#f92672">|</span> VECT_TAB_OFFSET; <span style="color:#75715e">/* Vector Table Relocation in Internal FLASH. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>另外在启动文件还定义了STM32所有的其他中断，这些中断达到触发条件后就会自动执行。那在启动文件(system_stm32f10x.c)这下面，这都是其他的中断调用了。</p>
<p>图：STM32所有的其他中断</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-89.png" alt = "P4-新建工程-89.png" width = "70%" height = "auto">
</div>
<br>
<p>这个中转函数的定义，就是在stm32f10x_it.c里面。</p>
<p>图：中断函数的定义在stm32f10x_it.c里面</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-88.png" alt = "P4-新建工程-88.png" width = "70%" height = "auto">
</div>
<br>
<p>我们打开Keil可以看到。这些就是中转函数的定义。</p>
<p>最后ST还建议我们把自己的中断写在这个位置上。当然我们还是习惯在哪用中断就写在哪里，写在别的地方也是可以的。</p>
<p>图：stm32f10x_it.c里 ST还建议我们把自己的中断写在这个位置上</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-91.png" alt = "P4-新建工程-91.png" width = "70%" height = "auto">
</div>
<br>
<p>那这些就是中断部分的执行逻辑了。</p>
<p>另外你也可以自己定义一些用户文件，来封装一些模块供主函数和中断调用，这些也都是没问题的，同时也有利于我们程序结构的模块化，要不然所有的程序都堆在主函数里，那主函数也太长了，是吧？</p>
<h3 id="stm32的资源外设和内核外设的寄存器描述库函数文件">STM32的资源：外设和内核外设的寄存器描述+库函数文件<a hidden class="anchor" aria-hidden="true" href="#stm32的资源外设和内核外设的寄存器描述库函数文件">#</a></h3>
<p>到此为止，这个工程结构主动执行的部分就介绍完了。剩下右边的就是被动执行的东西了，相当于STM32的资源。我们在主函数或者中断函数里就可以调用这些资源。</p>
<p>右上角这2个stm32f10x.h和core_cm3这些文件就是外设和内核外设的寄存器描述。</p>
<p>图：工程架构中stm32f10x.h和core_cm3这些文件</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-92.png" alt = "P4-新建工程-92.png" width = "70%" height = "auto">
</div>
<br>
<p>在Keil中我们可以看到。这里面都是寄存器和寄存器每一位的名字，还有地址信息等，如果直接调用这些寄存器来使用STM32，那就是寄存器的开发方式。</p>
<p>我们已经试过了，这种方式会有一些弊端，也比较麻烦。</p>
<p>所以ST公司就提供了下面这两个文件，这个就是库函数的文件。</p>
<p>图：ST公司提供的库函数文件</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-93.png" alt = "P4-新建工程-93.png" width = "70%" height = "auto">
</div>
<br>
<p>在Keil中可以看到这每个外设都提供了一大堆的函数，这些函数封装了寄存器的操作，给我们提供更加人性化的函数调用方式。只要学会了操作套路，那配置一个外设就是很简单的，连手册都不需要看一下。</p>
<p>这个conf文件就是用来配置头文件的包含关系的。</p>
<p>在Keil中我们可以看到在这里conf文件include了所有的库函数头文件。同时我们在stm32f10x.h的最后又包含了conf。</p>
<p>图：stm32f10x.h的最后又包含了conf</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-94.png" alt = "P4-新建工程-94.png" width = "70%" height = "auto">
</div>
<br>
<p>所以在使用这些库函数时，我们只需要包含stm32f10x.h这一个头文件，就相当于包含了所有的库函数头文件。这样我们就可以任意的调用库函数了。</p>
<p>这些就是整个工程的结构和每个文件的作用。好，以上就是我们我们本节课的所有内容。本节课我们建好了基于库函数的STM32工程，我们下一节就开始从这个工程上学习STM32的第一个外设GPIO了。</p>
<h2 id="临时解决一个小问题头文件报错">临时解决一个小问题：头文件报错<a hidden class="anchor" aria-hidden="true" href="#临时解决一个小问题头文件报错">#</a></h2>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-72.png" alt = "P4-新建工程-72.png" width = "70%" height = "auto">
</div>
<br>
<h3 id="1点击魔术棒">1.点击魔术棒<a hidden class="anchor" aria-hidden="true" href="#1点击魔术棒">#</a></h3>
<p>在Target栏目下，将ARM Compiler的级别选为如下图所示。</p>
<br>
<div align="center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/STM32-standard-library-learning-JKD/P4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B-74.png" alt = "P4-新建工程-74.png" width = "70%" height = "auto">
</div>
<br>
<h2 id="end">END<a hidden class="anchor" aria-hidden="true" href="#end">#</a></h2>
<blockquote>
<p><strong>END：本节内容到此结束。</strong></p>
</blockquote>
<p>个人提升之余，别忘了和小伙伴积极交流，很多人觉得他们在思考，而实际上他们只是在重新整理自己的偏见。请珍惜和他人交流讨论的机会。</p>
<br>
<div align = "center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/Blog-Common-Images/END1.jpg" alt = "END1.jpg" width = "70%" height = "auto">
</div>
<br>
<p>希望你每一天都有所收获，进步up up up。今天的我们并不比昨天更聪明，但一定要比昨天更睿智。</p>
<br>
<div align = "center">
<img src = "https://testingcf.jsdelivr.net/gh/EddyCliff/ChartBed/Blog-Common-Images/END2.jpg" alt = "END2.jpg" width = "70%" height = "auto">
</div>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://eddyblog.cn/posts/tech/stm32-standard_library_learning-jkd-p6/">
    <span class="title">« 上一页</span>
    <br>
    <span>嵌入式开发-STM32标准库学习：实现LED闪烁与流水灯，蜂鸣器</span>
  </a>
  <a class="next" href="https://eddyblog.cn/posts/tech/stm32-standard-library-learning-jkd-p2/">
    <span class="title">下一页 »</span>
    <br>
    <span>嵌入式开发-STM32标准库学习：STM32简介</span>
  </a>
</nav>

        </footer>
    </div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        -2024
        <a href="https://eddyblog.cn/" style="color:#939393;">Eddy&#39;s blog</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;"></a>&nbsp;
    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="" style="float:left;margin: 0px 5px 0px 0px;"/>
            
        </a>
    </span>
    <span id="busuanzi_container">
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
        <span class="fa fa-eye"></span> <span id="busuanzi_value_site_pv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Eddy's blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Eddy's blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"Eddy's blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>

<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style></body>

</html>
