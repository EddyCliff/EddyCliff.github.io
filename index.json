[{"content":" 启程-第1站\n尊敬的乘客，您好。\n我是Eddy，将在这趟知识的列车旅程中担任您的列车长。欢迎您登上“探险号”，在这里，每次启程都承载着新的发现与学习的机会。\n本次列车的目的地——LLC谐振变换器，一个在现代电子设备中不可或缺的神秘组件。它利用巧妙的物理原理有效减少能量损失，保证了我们设备的高效运行。\n在接下来的行程中，无论您是刚接触电子的新手，还是希望巩固基础知识的老手，我都希望这次旅程能为您带来新的灵感和知识。请您准备好您的工具包，我们即将启程，深入探索LLC谐振变换器的奇妙世界。期待在旅途中与您共同探讨、学习，并享受这一探索之旅。\n那么，请扣好安全带，我们这就出发吧！\n本次行车路线：LLC的定义及优势 - LLC入门 - LLC工作原理 - LLC特性分析\n🚄前方到站是：LLC的定义以及优势\nLLC的定义 LLC概念 LLC谐振转换器是使用带有电容器和两个电感器的三元件谐振电路，它拥有高工作频率，并在宽输出负载调节范围内为高功率系统实现良好的效率。\n这减少了所需元件的尺寸和组件的数量，使得最终成本额降低。\nLLC转换器像其他谐振转换器一样，由3个模块组成：电源开关，谐振回路，二极管整流器。\n首先打开MOS开关管，将直流电压转换为高频方波，方波进入谐振回路后，消除了方波的谐波，输出基频的正弦波，正弦波通过高频变压器传输到转换器的次级侧，根据输出要求升高或降低电压，最后，正弦波通过二极管整流器转换为稳定的直流输出。\nLLC的电源开关 LLC的电源开关可以在全桥或者半桥拓扑中实现，\n它们的主要区别是：\n全桥拓扑结构生成无直流偏移的方波输出，幅度等于输入电压，范围从正波到负波。\n半桥拓扑生成了一个方波，该方波使得输出电压的一半发生偏移。\n因此，全桥拓扑和半桥拓扑这两种拓扑结构存在振幅差异。\n全桥拓扑：\n缺点：需要耗费更多晶体管，这使得它价格高昂一些，此外，由于晶体管数量更多，电路中将有更多RDS处于开启状态，这会增加传导的损耗。\n优点：全桥拓扑将变压器传输比降低一半，从而最大限度地减少变压器中的铜损耗。\n半桥拓扑：\n优点：实施起来更具成本优势，并且增加了电容器两端RMS电流的优势，将此电路减少了原来的15%。\n缺点：增加了开关损耗。\n综上：\n我们简易功率低于1kw的应用应该使用半桥电源开关拓扑。高于1kw的使用全桥电源开关拓扑。\n为什么我们在隔离谐振转换器中只使用LLC而不用其他谐振回路？ 主要有两个原因：\n原因1：\n每当我们设计一个系统时，我们都需要考虑该系统的成本竞争力。\n通常情况下，半桥拓扑可以提供成本最低的开关网络。\n我们需要找到一个可以使用变压器参数的谐振回路，一旦能够实现这一点，我们就可以减少谐振电路的额外元件数量。\n理想变压器的磁化电感与其输入绕组并联，我们可以将其用作与谐振回路输出端口并联的励磁电感Lm。\n在现实世界中，变压器总是带有与变压器绕组串联的漏电感，如果我们以某种方式使用这个串联漏电感作为谐振电感Lr，我们就能降低电路的成本。\n原因2：\nLLC的谐振回路由一个谐振电容器和两个电感器组成。\n与电容器和变压器串联的谐振电感器以及并联的磁化电感器。\n这里容器的作用是滤除方波中的谐波，并提供变压器输入端基本开关频率的正弦波。\n谐振回路的增益会根据频率和施加到输出侧的负载而变化。\n我们可以这么认为，当电源能够很好的提供电量的时候，这个电源就是一个稳健的设计。\n那么负载调节量以及谐振回路的响应是否会随负载变化而给设计带来挑战呢？\n我们必须考虑开关频率和输出负载来调整谐振回路的响应，以确保转换器通过设计谐振回路的增益在广泛的负载范围内高效的运行。\n由于谐振回路的双电感器，LLC转换器的工作范围较宽。\n为了解其工作原理，我们将根据要求考虑容器对重载和轻载的响应。\n让我们将变压器的整个次级侧视为谐振回路的负载端。\n仅含Lm和Cr的回路 如果谐振回路仅由谐振电容器和磁化电感器组成，让我们看一看在一定负载范围内的谐振增益是怎么样的。\n当负载较轻时，谐振回路的增益有一个明显的峰值，然而，重负载的增益没有上限，它能够响应衰减变化并且仅在非常高的频率下能实现单位增益。\n仅含Lr和Cr的回路 现在，如果谐振回路仅由谐振电容器和与之串联的谐振电感器Lr组成，则结果会有所不同。\n当负载较轻时，这中间的增益不会超过单位增益。\n但当负载较重时，谐振回路达到单位增益的速度则比并联电感器Lm快得多。\n因此，通过谐振回路中实施两个电感器，我们得到了频率增益响应，确保转换器能够响应更大范围的负载。\n此外，它可以在整个负载范围内实现稳定的控制。\nLLC的两个谐振频率 对LLC来说，有两个谐振频率，\n一个谐振频率fr是利用谐振电感Lr谐振电容Cr组成；\n另一个谐振频率fm是利用谐振电感Lr，励磁电感Lm，谐振电容Cr一起组成；\n$f_{r1}=\\frac{1}{2\\cdot\\pi\\cdot\\sqrt{L_r\\cdot C_r}}$\n$f_{r2}=\\frac1{2\\cdot\\pi\\cdot\\sqrt{\\left(L_r+L_m\\right)\\cdot C_r}}$\n这既可以利用PR（并联谐振）的升压功能，也可以利用SR（串联谐振）特性的降压功能。\n让我们看看谐振参数变化时产生的影响\n随着Lm/Lr比例增加，增益曲线的峰值降低，这意味着电压调节范围减小了。\n如果Lr/Cr比例增加，两个谐振频率之间的差异会增加，这意味着工作频率变化增加。\n因此两个比例（Lm/Lr）（Lr/Cr）都需要足够低，使得电路具有较宽的电压调节范围和较窄的工作频率变化。\n然而，电流ILm在输入端的开关网络和谐振回路之间循环 ,并且由于隔离的原因不会传输到输出端。\n如果降低Lm以在宽电压调节范围内保持低Lm/Lr比例，ILm数值会增加，因此会降低转换器的效率。\n因此，在设计过程中必须考虑效率和稳压的范围。\n正如我们所见，转换器的效率来自谐振回路，LLC转换器的谐振回路可在初级侧和次级侧实现软开关。\n它在输入开关上启用ZVS，此外，如果开关频率介于两个谐振频率之间，我们可以在输出整流器上实现零电流开关。\nLLC拓扑可节省电路板空间，LLC拓扑没有输出电感器，这意味着所有电感器可以更轻松地集成到单个磁性结构，以节省面积和成本。\n简而言之，可以通过LLC串并联谐振变换器来提高开关频率以减小转换器尺寸，同时保持较高的转换器效率。\n比如，我们可以使用氮化镓（GaN）FET设计一个1kw输出的LLC串联谐振转换器，其开关频率为1MHz，并实现高达95%的效率，与此同时它的尺寸和重量会缩小到可以装进我们的午餐盒里。\n这就是LLC谐振变换器被用于高端消费电子产品，服务器和电信站等精密系统的电源应用的原因。\n参考/感谢 [1]https://www.bilibili.com/video/BV1Sh411T7XV/?spm_id_from=333.999.0.0\n🚉尊敬的旅客朋友们，已到站，本站是：LLC的定义及优势，请需要下车的乘客带好随身物品有序下车。\n⏩下一站是：LLC入门\n","permalink":"https://eddyblog.cn/posts/tech/llc_resonant_converters-chapter_0_definition_and-advantages_of_llc/","summary":"启程-第1站 尊敬的乘客，您好。 我是Eddy，将在这趟知识的列车旅程中担任您的列车长。欢迎您登上“探险号”，在这里，每次启程都承载着新的发现与学习的机会。 本次列车的目的地——LLC谐振变换器，一个在现代电子设备中不可或缺的神秘组件。它利用巧妙的物理原理有效减少能量损失，保证了我们设","title":"【浅谈LLC谐振变换器】-章节0:LLC的定义以及优势"},{"content":" 启程-第2站\n尊敬的乘客，您好。\n我是Eddy，将在这趟知识的列车旅程中担任您的列车长。欢迎您登上“探险号”，在这里，每次启程都承载着新的发现与学习的机会。\n本次列车的目的地——LLC谐振变换器，一个在现代电子设备中不可或缺的神秘组件。它利用巧妙的物理原理有效减少能量损失，保证了我们设备的高效运行。\n在接下来的行程中，无论您是刚接触电子的新手，还是希望巩固基础知识的老手，我都希望这次旅程能为您带来新的灵感和知识。请您准备好您的工具包，我们即将启程，深入探索LLC谐振变换器的奇妙世界。期待在旅途中与您共同探讨、学习，并享受这一探索之旅。\n那么，请扣好安全带，我们这就出发吧！\n本次行车路线：LLC的定义及优势 - LLC入门 - LLC工作原理 - LLC特性分析\n🚄前方到站是：LLC入门\n谐振变换器 功率变换器设计目标：\n高功率密度，小设计尺寸，高转换效率\n措施：\n提高开关频率，采用高频工作降低无源器件的尺寸，如变压器和滤波电感、 电容等器件。但存在的开关损耗却对高频工作带来不利影响\n谐振变换器优点：\n谐振变换器的基本变换单元是谐振电路，由于电路的谐振作用，使得电压或者电流都能周期性地通过零点，这样开关器件就能够在零电压或者零电流的条件下导通或者关断，开关器件实现了软开关，使得开关损耗降低。因此，开关损耗和噪声可大幅度减少。常规谐振器使用串联的电感电容作为谐振网络。负载连接有两种基本结构，串联和并联。\n四种谐振回路：\nLLC LLC谐振变换器（也称为LLC串并联谐振变换器）通常被选择用于电源设计中，因为它集成了串联谐振变换器（SRC）和并联谐振变换器（PRC）的优点，并且解决了它们的一些局限性。以下是选择LLC谐振变换器的几个关键原因：\n零电压开关（ZVS）：LLC谐振变换器可以在较宽的负载范围内提供ZVS，这减少了开关损耗，从而提高了整体效率。在低负载条件下，SRC可能无法保持ZVS，而LLC可以。\n最小化电磁干扰（EMI）：由于其软开关特性，LLC变换器能够减少EMI，这对于符合严格EMI标准的应用非常重要。\n负载调节能力：LLC变换器能够更好地处理广泛的负载变化，并且仍然保持高效的能量转换，而SRC和PRC在这方面的表现可能不够理想。\n变频操作：LLC变换器允许在不同频率下操作，以优化效率和输出特性，而SRC和PRC可能只在单一频率下最优化。\n宽输入电压范围：LLC谐振变换器可以适应宽广的输入电压变化，这使得它们适用于变动输入电压的应用场景。\n效率和功率密度：LLC谐振变换器因为可以维持高效率，使得它们能够实现更高的功率密度，这对于需要小型化解决方案的应用非常关键。\n简化的控制策略：与SRC或PRC相比，LLC变换器可以使用更简单的控制策略，这降低了设计的复杂性和成本。\n热性能：由于较低的开关损耗，LLC变换器一般有更好的热性能，这减少了冷却需求和相关成本。\n更高的可靠性：减少了开关损耗和运行在较低的应力下，LLC变换器的可靠性更高，这对于要求长寿命应用的场景特别有价值。\n由于这些优势，LLC变换器在众多需要高效、高密度和高可靠性电源的应用中成为了首选。然而，它们的设计和控制可能比SRC或PRC更复杂，需要精确的电感和电容匹配以及优化的控制算法来实现最佳性能。因此，LLC变换器的选择应基于应用的具体需求和可接受的设计复杂性。\n参考/感谢： [1]Bo Yang. Topology Investigation for Front End DC/DC Power Conversion for Distributcd Power System.\n[2]ST. Simplified Analysis and Design of Series resonant LLC Half-bridge Converters.\n[3]https://www.bilibili.com/video/BV1Pr4y1g7ad/?spm_id_from=333.788\u0026amp;vd_source=c57cc7d724946a8cfa6381f148e147d5\n🚉尊敬的旅客朋友们，已到站，本站是：LLC入门，请需要下车的乘客带好随身物品有序下车。\n⏩下一站是：LLC工作原理\n","permalink":"https://eddyblog.cn/posts/tech/llc_resonant_converters-chapter_1_introduction_to_llc/","summary":"启程-第2站 尊敬的乘客，您好。 我是Eddy，将在这趟知识的列车旅程中担任您的列车长。欢迎您登上“探险号”，在这里，每次启程都承载着新的发现与学习的机会。 本次列车的目的地——LLC谐振变换器，一个在现代电子设备中不可或缺的神秘组件。它利用巧妙的物理原理有效减少能量损失，保证了我们设","title":"【浅谈LLC谐振变换器】-章节1:LLC入门"},{"content":" 启程-第3站\n尊敬的乘客，您好。\n我是Eddy，将在这趟知识的列车旅程中担任您的列车长。欢迎您登上“探险号”，在这里，每次启程都承载着新的发现与学习的机会。\n本次列车的目的地——LLC谐振变换器，一个在现代电子设备中不可或缺的神秘组件。它利用巧妙的物理原理有效减少能量损失，保证了我们设备的高效运行。\n在接下来的行程中，无论您是刚接触电子的新手，还是希望巩固基础知识的老手，我都希望这次旅程能为您带来新的灵感和知识。请您准备好您的工具包，我们即将启程，深入探索LLC谐振变换器的奇妙世界。期待在旅途中与您共同探讨、学习，并享受这一探索之旅。\n那么，请扣好安全带，我们这就出发吧！\n本次行车路线：LLC的定义及优势 - LLC入门 - LLC工作原理 - LLC特性分析\n🚄前方到站是：LLC工作原理\nZVS和ZCS软开关 硬开关\n开关管在开通和关断时，开关管源漏极电压与电流会出现重叠的现象，即有额外的开关损耗产生，这种开通与关断称为硬开关。\n软开关\n在开关管导通前，使用特定的措施使得开关管两端电压预先下降到零，随后开通开关管，即可实现软开通（ZVS，零电压开通）； 在开关管关断前，使用特定的措施便得开关管的电流预先下降到零，随后关闭开关管，即可实现软关断（ZCS，零电流关断）\n半桥LLC主电路结构分析 整流网络有两种情况：全波整流和全桥整流。\n全波整流适用于低压高电流场合，全桥整流适用于高压低电流场合。\n三种频率条件下的模态与关键波形分析 LLC谐振变换器存在以下三种工作模式\n开关频率fs 谐振频率fr\n工作模式1：fs\u0026lt;fr\n该模式下，励磁电感Lm部分时间参与谐振，LLC谐振变换器不仅能实现原边侧开关管零电压开通（ZVS），也能同时实现副边侧整流部分二极管零电流关断（ZCS）。\n工作模式2：fs=fr\n该模式下，励磁电感Lm始终被输出电压嵌位，一直未参与谐振，其两端电压一直被输出电压嵌位在nVo。 整流二极管电流临界连续，因此同样能够实现ZCS关断。\n工作模式3：fs\u0026gt;fr\n该模式下，励磁电感Lm始终被输出电压嵌位，一直未参与谐振。原边开关管可实现ZVS开通，但副边侧整流二极管上的电流不能ZCS关断，且换流时因反向恢复产生损耗。\n综上，fs≤fr时，可以实现原边ZVS开通和ZSC关断。fs\u0026gt;fr时，可以实现原边ZVS开通，不能实现副边ZSC关断。\n工作模式1：一共有8种模态。\n1）Q1 OFF，Q2 ON\n2）Q1 OFF，Q2 OFF\n3）Q1 OFF，Q2 OFF\n4）Q1 ON，Q2 OFF\n5）Q1 ON，Q2 OFF\n6）Q1 OFF，Q2 OFF\n7）Q1 OFF，Q2 OFF\n8）Q1 OFF，Q2 ON\n工作模式2：一共有6种模态。\n1）Q1 OFF，Q2 ON\n2）Q1 OFF，Q2 OFF\n3）Q1 ON，Q2 OFF\n4）Q1 ON，Q2 OFF\n5）Q1 OFF，Q2 OFF\n6）Q1 OFF，Q2 ON\n工作模式3：一共有6种模态。\n1）Q1 OFF，Q2 ON\n2）Q1 OFF，Q2 OFF\n3）Q1 ON，Q2 OFF\n4）Q1 ON，Q2 OFF\n5）Q1 OFF，Q2 OFF\n6）Q1 OFF，Q2 ON\nLLC谐振半桥电容模式（fs~fr2）：为什么必须避免\n当fs接近fr2时，会遇到电容模式，虽然在电容模式下可以实现ZCS，但是ZVS会丢失。\n这会导致：\nQ1和Q2的硬开关\nQ1和Q2体二极管反向恢复：导通时高电流尖峰，额外功耗，mosfet很容易爆炸。\n产生高水平的电磁干扰\n在HB中点的大的负电压尖峰可能会导致控制IC失效\n反馈回路符号可以由负变正：\n在电容模式下，能量与频率的关系是相反的\n转换器的工作频率将跑向最小值（假如mosfet没有爆炸）\n参考/感谢 [1]ST SimplifiedAnalysis and Design of Series resonantLLC HalfbridgeConverters\n[2]https://www.bilibili.com/video/BV143411u74r/?spm_id_from=333.788\u0026amp;vd_source=c57cc7d724946a8cfa6381f148e147d5\n🚉尊敬的旅客朋友们，已到站，本站是：LLC工作原理，请需要下车的乘客带好随身物品有序下车。\n⏩下一站是：LLC特性分析\n","permalink":"https://eddyblog.cn/posts/tech/llc_resonant_converter-chapter_2_llc_resonant_converter_principle_of_operation/","summary":"启程-第3站 尊敬的乘客，您好。 我是Eddy，将在这趟知识的列车旅程中担任您的列车长。欢迎您登上“探险号”，在这里，每次启程都承载着新的发现与学习的机会。 本次列车的目的地——LLC谐振变换器，一个在现代电子设备中不可或缺的神秘组件。它利用巧妙的物理原理有效减少能量损失，保证了我们设","title":"【浅谈LLC谐振变换器】-章节2:LLC工作原理"},{"content":" 启程-第4站\n尊敬的乘客，您好。\n我是Eddy，将在这趟知识的列车旅程中担任您的列车长。欢迎您登上“探险号”，在这里，每次启程都承载着新的发现与学习的机会。\n本次列车的目的地——LLC谐振变换器，一个在现代电子设备中不可或缺的神秘组件。它利用巧妙的物理原理有效减少能量损失，保证了我们设备的高效运行。\n在接下来的行程中，无论您是刚接触电子的新手，还是希望巩固基础知识的老手，我都希望这次旅程能为您带来新的灵感和知识。请您准备好您的工具包，我们即将启程，深入探索LLC谐振变换器的奇妙世界。期待在旅途中与您共同探讨、学习，并享受这一探索之旅。\n那么，请扣好安全带，我们这就出发吧！\n本次行车路线：LLC的定义及优势 - LLC入门 - LLC工作原理 - LLC特性分析\n🚄前方到站是：LLC特性分析\nLLC谐振变换器特性分析 LLC谐振变换器FHA等效模型推导 用基波等效法推出它的等效电阻Req，用等效模型从而推出电压增益。\n由等效图可知，\n$电压增益=\\frac{\\text{R}eq}{\\text{}整个电路的阻抗}$\nReq就是整流网络加上变压去等效到原边的阻抗Req。\n而由图可知，\n$Req =\\frac{\\text{V}p}{\\text{I}p}$\n这里我们用到基波等效分析法求Vp和Ip。\n先介绍一下傅里叶级数的基本概念。\n傅里叶级数基本概念\n周期为2π的函数f(x)傅里叶级数展开后的表达式为：\n$f(x) = {{{a_0}} \\over 2} + \\sum\\limits_{n = 1}^\\infty {({a_n}\\cos {nx} + {b_n}\\sin {nx})}$\n其中：\n$\\begin{aligned} \u0026amp;a_{n} =\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f\\bigl(x\\bigr)\\cos nxdx \\ \u0026amp;b_{n} =\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f\\bigl(x\\bigr)\\sin nxdx \\ \u0026amp;a_{0} =\\frac1\\pi\\int_{-\\pi}^{\\pi}f(x)dx \\end{aligned}$\n1）Vd方波的傅里叶级数展开\n半波Vd傅里叶级数展开后的表达式为：\n$\\nu_{d}\\left(t\\right)=\\frac{V_{bus}}{2}+\\frac{2V_{bus}}{\\pi}\\sum_{n=1,3,5,\u0026hellip;}^{\\infty}\\frac{1}{n}\\sin(n\\omega_{s}t)$\n基波分量表达式为：\n$\\nu_{d}\\left(t\\right)=\\frac{2V_{bus}}{\\pi}\\sin(\\omega_{s}t)$\n2）变压器原边电压Vp傅里叶级数展开\nVp傅里叶级数展开的表达式为：\n$\\nu_{p}\\left(t\\right)=\\frac{4NV_{o}}{\\pi}\\sum_{n=1,3,5,..}^{\\infty}\\frac{1}{n}\\sin(n\\omega_{s}t-\\varphi)$\n基波分量与方波电压是同相的，因此，取n=1可得其基波分量表达式为：\n$\\begin{aligned}V_{p1}\\left(t\\right)\u0026amp;=\\frac{4NV_{o}}{\\pi}\\sin(\\omega_{s}t-\\varphi)=\\sqrt{2}V_{p1rms}\\sin(\\omega_{s}t-\\varphi)\\\u0026amp;\\quad V_{p1rms}=\\frac{4NV_{o}}{\\pi}/\\sqrt{2}=\\frac{2\\sqrt{2}NV_{o}}{\\pi}\\end{aligned}$\n3）变压器原边电压ip傅里叶级数展开\nip可以近似认为是一正弦基波分量，其表达式为:\n$i_{p}\\left(t\\right)=\\sqrt{2}I{_{prms}}\\sin(\\omega_st-\\varphi)$\n上式最关键的是计算Iprms：\n$I_o=\\frac1{2\\pi}\\int_0^{2\\pi}i_o\\left(t\\right)dt=\\frac1{2\\pi}\\int_0^{2\\pi}N\\left|i_p\\left(t\\right)\\right|dt=\\frac{2\\sqrt{2}N}\\pi I_{prms}$\n$I_{prms}=\\frac{I_{o}\\pi}{2\\sqrt{2}N}$\n4）等效电阻Req\n$R_{eq}=\\frac{\\nu_{_{p1}}}{i_p}=\\frac{\\frac{4NV_o}\\pi\\sin(\\omega_st-\\varphi)}{\\frac{I_o\\pi}{2N}\\sin(\\omega_st-\\varphi)}=\\frac{8N^2}{\\pi^2}R_L$\nLLC谐振变换器电压增益 根据上图可以得到LLC谐振变换器的交流电压增益为：\n$H(j\\omega)=\\frac{V_{p1}(j\\omega)}{V_{d1}(j\\omega)}=\\frac{R_{eq}\\parallel j\\omega L_m}{j\\omega L_r+\\frac1{j\\omega C_r}+R_{eq}\\parallel j\\omega L_m}$\n定义励磁电感与谐振电感之比为：\n$\\gamma=\\frac{L_m}{L_r}$\n品质因数Q：\n$Q=\\frac{Z_r}{R_{eq}}=\\frac{\\sqrt{\\frac{L_r}{C_r}}}{R_{eq}}$\n归一化频率：\n$f_n=\\frac{f_s}{f_r}$\n可以得到LLC谐振变换器的电压增益函数为：\n$M(f_n)=\\frac1{\\sqrt{\\left[1+\\frac1\\gamma(1-\\frac1{f_n}^2)\\right]^2+\\left[Q(f_n-\\frac1{f_n})\\right]^2}}$\nLLC谐振变换器电压增益曲线分析 - Q值和γ值的选取 课程回顾\nQ值对增益的影响\nγ值对增益的影响\nQ与γ的选取思路\n由输入电压变换引起的最大输出电压变换范围\n由空载到满载引起的输出电压变换\n确保整个工作区ZVS，从而降低损耗\n$V_O=M\\times\\frac1N\\times\\frac{V\\mathrm{in}}2$\n参考/感谢 [1]ST. Simplified Analysis and Design of Series resonant LLC Half-bridge Converters.\n[2]https://www.bilibili.com/video/BV1tG411j7Vx/?p=5\u0026amp;spm_id_from=pageDriver\u0026amp;vd_source=c57cc7d724946a8cfa6381f148e147d5\n🚉尊敬的旅客朋友们，已到站，本站是：LLC特性分析，请需要下车的乘客带好随身物品有序下车。\n⏩下一站是：LLC参数设计\n","permalink":"https://eddyblog.cn/posts/tech/llc_resonantconverter-chapter_3_llc_characterization/","summary":"启程-第4站 尊敬的乘客，您好。 我是Eddy，将在这趟知识的列车旅程中担任您的列车长。欢迎您登上“探险号”，在这里，每次启程都承载着新的发现与学习的机会。 本次列车的目的地——LLC谐振变换器，一个在现代电子设备中不可或缺的神秘组件。它利用巧妙的物理原理有效减少能量损失，保证了我们设","title":"【浅谈LLC谐振变换器】-章节3:LLC特性分析"},{"content":"一、文件的概念 文件用来存放程序、文档、音频、视频数据、图片等数据的。\n文件就是存放在磁盘上的，一些数据的集合。在windows下可以通过写字板或记事本打开文本文件对文件进行编辑保存。写字板和记事\n本是微软程序员写的程序，对文件进行打开、显示、读写、关闭。\n作为一个程序员，必须掌握编程实现创建、写入、读取文件等操作\n对文件的操作是经常要用到的知识，比如：写飞秋软件传送文件等\n1.1 文件的定义 磁盘文件：（我们通常认识的文件）\n指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。\n设备文件：\n在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。\n键盘：标准输入文件 屏幕：标准输出文件\n其它设备：打印机、触摸屏、摄像头、音箱等\n在Linux操作系统中，每一个外部设备都在/dev目录下对应着一个设备文件，咱们在程\n序中要想操作设备，就必须对与其对应的/dev下的设备文件进行操作。\n标准io库函数对磁盘文件的读取特点\n通过标准IO库相当于在内存当中对我们的磁盘文件做输入输出操作，也就是读写操作。\n1、行缓冲\n标准io库函数，往标准输出（屏幕）输出东西的时候是行缓冲的\n所谓的行缓冲就是缓冲区碰到换行符的时候才刷新缓冲区\n如果不刷新缓冲区，无法对文件执行读写操作\n举个例子：当地铁到站之后，只有所有门都关闭的时候，地铁才会出发，只要有一个门没关闭，地铁就不会出发。这就相当于我们的行缓存，如果不刷新缓冲区，就无法对文件执行读写操作。\n行缓冲的刷新条件：\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { //由于printf函数是一个标准io，所以只有刷新缓冲区才可以将数据输出到终端 //printf(\u0026#34;hello world\u0026#34;); //刷新缓冲区方法1：使用\\n //printf(\u0026#34;hello world\\n\u0026#34;); //刷新缓冲区方法2：程序正常结束 /* printf(\u0026#34;hello world\u0026#34;); return 0; */ //刷新缓冲区方法3：使用fflush函数刷新缓冲区 /* printf(\u0026#34;hello world\u0026#34;); fflush：刷新函数。可以刷新指定的缓冲区 stdout：标准输出，就是对终端进行写操作 fflush(stdout); */ //刷新缓冲区方法4：当缓冲区满的时候自动刷新 //默认行缓冲的大小为1024个字节 /* int i; for(i = 1; i \u0026lt; 300; i++) { printf(\u0026#34;%03d \u0026#34;, i); } */ while(1); return 0; } 没有刷新缓冲区，则无法进行输出\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { //由于printf函数是一个标准io，所以只有刷新缓冲区才可以将数据输出到终端 printf(\u0026#34;hello world\u0026#34;); //此时我们是没有任何输出结果的,因为我们没有加\\n刷新缓冲区. while(1); return 0; } 2、全缓冲\n标准io库函数 ，往普通文件读写数据的，是全缓冲的，\n碰到换行符也不刷新缓冲区，即缓冲区满了，才刷新缓冲区。\n刷新缓冲区的情况\n1.缓冲区满了，刷新缓冲区\n2.人为刷新缓冲区 fflush(文件指针)\n3.程序正常结束 会刷新缓冲区\n3.无缓冲\n在读写文件的时候通过系统调用io （read write）,对文件进行读写数据\n这个时候是无缓冲的，即写数据会立马进入文件，读数据会立马进入内存\n写文件的流程\n应用程序空间 → 内核空间 → 驱动程序 → 硬盘上\n应用程序和内核程序运行在不同的空间里，目的是为了保护内核。\n设置缓冲区的目的\n通过缓冲可以减少进出内核的次数，以提高效率。\n1.2 磁盘文件的分类 一个文件通常是磁盘上一段命名的存储区\n计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储\n从用户或者操作系统使用的角度（逻辑上）把文件分为：\n文本文件：基于字符编码的文件\n二进制文件：基于值编码的文件\n文本文件\n基于字符编码，常见编码有ASCII、UNICODE等\n一般可以使用文本编辑器直接打开\n例如：数5678的以ASCII存储形式为：\nASCII码：00110101 00110110 00110111 00111000\n歌词文件(lrc):文本文件\n二进制码文件\n基于值编码,自己根据具体应用,指定某个值是什么意思\n把内存中的数据按其在内存中的存储形式原样输出到磁盘上\n一般需要自己判断或使用特定软件分析数据格式\n例如：数5678的存储形式为：\n二进制码：00010110 00101110\n音频文件(mp3):二进制文件\n图片文件（bmp）文件，一个像素点由两个字节来描述*****######\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\n*代表红色的值#代表绿色的值\n\u0026amp;代表蓝色的值\n二进制文件以位来表示一个意思。\n文本文件、二进制文件对比：\n译码：\n文本文件编码基于字符定长，译码容易些；\n二进制文件编码是变长的，译码难一些（不同的二进制文件格式，有不同的译码方\n式）。\n空间利用率：\n二进制文件用一个比特来代表一个意思(位操作)；\n而文本文件任何一个意思至少是一个字符。\n二进制文件，空间利用率高。\n可读性：\n文本文件用通用的记事本工具就几乎可以浏览所有文本文件\n二进制文件需要一个具体的文件解码器，比如读BMP文件，必须用读图软件。\n总结一下：\n文件在硬盘上存储的时候，物理上都是用二进制来存储的。\n咱们的标准io库函数，对文件操作的时候，不管文件的编码格式（字符编码、或二进制），而是按字节对文件进行读写，所以咱们管文件又叫流式文件，即把文件看成一个字节流。\n二、文件指针 文件指针就是用于标识一个文件的，所有对文件的操作都是用对文件指针进行操作的\n定义文件指针的一般形式为:\nFILE * 指针变量标识符；\n本质上文件指针是一个结构体指针，结构体中包含了当前文件的很多信息，但是在实际编程时，\n不需要关系结构体中的成员，只需要使用文件指针即可\n对文件操作的步骤：\n1、对文件进行读写等操作之前要打开文件得到文件指针\n2、可以通过文件指针对文件进行读写等操作\n3、读写等操作完毕后，要关闭文件，关闭文件后，就不能再通过此文件指针操作文件了\nc语言中有三个特殊的文件指针无需定义，在程序中可以直接使用\nstdin： 标准输入 默认为当前终端（键盘）\n我们使用的scanf、getchar函数默认从此终端获得数据\n**stdout：**标准输出 默认为当前终端（屏幕）\n我们使用的printf、puts函数默认输出信息到此终端\n**stderr：**标准错误输出设备文件 默认为当前终端（屏幕）\n当我们程序出错使用:perror函数时信息打印在此终端\n三、打开文件fopen #include \u0026lt;stdio.h\u0026gt; FILE *fopen(const char *path, const char *mode); 功能：创建或者打开一个文件 参数： path：文件名，如果只写文件名，默认就是当前路径，也可以添加路径 mode：文件权限 r 只读，如果文件不存在则报错 r+ 读写，如果文件不存在则报错 w 只写，如果文件不存在则创建，如果文件存在则清空 w+ 读写，如果文件不存在则创建，如果文件存在则清空 a 只写，如果文件不存在则创建，如果文件存在则追加 a+ 读写，如果文件不存在则创建，如果文件存在则追加 返回值： 成功：文件指针 失败：NULL 示例程序：对file.txt进行fopen操作\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { //使用fopen函数打开或者创建文件，返回文件指针 FILE *fp; //以只读的方式打开文件，如果文件不存在则报错 //fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;r\u0026#34;); //以只写的方式打开文件，如果文件不存在则创建，如果文件存在清空 //fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;w\u0026#34;); //以只写的方式打开文件，如果文件不存在则创建，如果文件存在则追加 fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;a\u0026#34;); if(fp == NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } return 0; } 四、关闭文件fclose #include \u0026lt;stdio.h\u0026gt; int fclose(FILE *stream); 功能：关闭一个文件指针，无法在对当前文件进行操作 参数： stream：指定的文件指针，fopen函数的返回值 返回值： 成功：0 失败：EOF 注意：注意一个文件只能关闭一次，不能多次关闭。 关闭文件之后就不能再文件指针对文件进行读写等操作了。 示例程序：对file.txt进行fclose操作\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { //使用fopen函数打开或者创建文件，返回文件指针 FILE *fp; //以只写的方式打开文件，如果文件不存在则创建，如果文件存在则追加 fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;a\u0026#34;); if(fp == NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } //使用fclose关闭文件 fclose(fp); return 0; } 五、一次读写一个字符 5.1 fgetc #include \u0026lt;stdio.h\u0026gt; int fgetc(FILE *stream); 功能：从文件指针标识的文件中读取一个字符 参数： stream：指定的文件指针 返回值： 成功：读取的字符 失败：EOF 如果文件读取完毕，也会返回EOF file.txt文件内容\nhello 666 示例程序：对file.txt进行fgetc操作\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { FILE *fp; fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;r\u0026#34;); if(fp == NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } //使用fgetc从文件中读取一个字符 // int c = fgetc(fp); // printf(\u0026#34;c = [%c] ‐ %d\\n\u0026#34;, c, c); // c = fgetc(fp); // printf(\u0026#34;c = [%c] ‐ %d\\n\u0026#34;, c, c); //文件的每一行结束的位置都有一个标识，是一个换行符，称之为行结束符 //fgetc可以读取到行结束符 int c; //遍历文件中内容,每次读取一个字符,每读取一次就移动到下一个字符 while((c = fgetc(fp)) != EOF) { printf(\u0026#34;c = [%c] ‐ %d\\n\u0026#34;, c, c); } //注意：打开文件的时候，默认读写位置在文件的开始，如果以 a 的方式打开读写位置在文件的末尾 //咱们向文件中读取字节或写入字节的时候，读写位置会往文件的末尾方向偏移，读写多少个字节，读写位置就往 //文件的末尾方向偏移多少个字节 return 0; } 执行结果：file.txt文件内容\nc = [h] - 104 c = [e] - 101 c = [l] - 108 c = [l] - 108 c = [o] - 111 c = [ ] - 10 c = [6] - 54 c = [6] - 54 c = [6] - 54 5.2 fputc #include \u0026lt;stdio.h\u0026gt; int fputc(int c, FILE *stream); 功能：向文件指针标识的文件中写入一个字符 参数： c：要写入的字符 stream：指定的文件指针 返回值： 成功：要写入的字符 失败：EOF 示例程序：对file.txt进行fputc操作\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { FILE *fp; fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;w\u0026#34;); if(fp == NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } //通过fputc函数向文件写入一个字符 fputc(\u0026#39;w\u0026#39;, fp); fputc(\u0026#39;h\u0026#39;, fp); fputc(\u0026#39;a\u0026#39;, fp); fputc(\u0026#39;t\u0026#39;, fp); fputc(\u0026#39;\\n\u0026#39;, fp); fputc(\u0026#39;o\u0026#39;, fp); return 0; } 执行结果：file.txt文件内容\nwhat o 六、一次读写一个字符串 6.1 fgets #include \u0026lt;stdio.h\u0026gt; char *fgets(char *s, int size, FILE *stream); 功能：从文件中读取内容 参数： s：保存读取到的内容 size：每次读取的最大个数 stream：文件指针 返回值： 成功：读取的数据的首地址 失败：NULL 如果文件内容读取完毕，也返回NULL 注意：从stream所指的文件中读取字符，在读取的时候碰到换行符或者是碰 到文件的末尾停止读取，或者是读取了size‐1个字节停止读取，在读取 的内容后面会加一个\\0,作为字符串的结尾 file.txt文件内容\nhello world nihao beijing 示例程序：对file.txt进行fgets操作\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { FILE *fp; fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;r\u0026#34;); if(fp == NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } //使用fgets读取文件内容 //fgets每次读取时最多读取文件一行内容，只要遇到行结束符就立即返回 //如果想要读取的字节数小于一行内容，则只会读取第二个参数‐1个字节， //最后位置补\\0 char buf[32] = \u0026#34;\u0026#34;; //fgets(buf, 8, fp); fgets(buf, 32, fp); printf(\u0026#34;buf = %s\\n\u0026#34;, buf); return 0; } 执行结果：file.txt文件内容\nbuf = hello world 6.2 fputs #include \u0026lt;stdio.h\u0026gt; int fputs(const char *s, FILE *stream); 功能：向文件写入数据 参数： s：要写入的内容 stream：文件指针 返回值： 成功：写入文件内容的字节数 失败：EOF 示例程序：对file.txt进行fputs操作\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { FILE *fp; fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;w\u0026#34;); if(fp == NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } //通过fputs函数向文件写入数据 fputs(\u0026#34;66666666666666\\n\u0026#34;, fp); fputs(\u0026#34;nihao\u0026#34;, fp); return 0; } 执行结果：file.txt文件内容\n66666666666666 nihao 七、读文件fread #include \u0026lt;stdio.h\u0026gt; size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：从文件中读取数据 参数： ptr：保存读取的数据 size：每次读取的字节数 nmemb：一共读取的次数 stream：文件指针 返回值： 成功：实际读取的次数（对象数、块数） 失败：0 如果文件内容读取完毕，返回0 对fread的说明\n例1： int num; num=fread(str,100,3,fp); 从fp所代表的文件中读取内容存放到str指向的内存中，读取的字节数为 ，每块100个字节，3块。 返回值num， 如果读到300个字节返回值num为3 如果读到了大于等于200个字节小于300个字节 返回值为2 读到的字节数，大于等于100个字节小于200个字节 返回1 不到100个字节返回0 file.txt文件内容\n66666666666666 nihao 示例程序：对file.txt进行fread操作\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { FILE *fp; fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;r\u0026#34;); if(fp == NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } //使用fread函数读取文件内容 int num; char buf[128] = \u0026#34;\u0026#34;; num = fread(buf, 5, 4, fp); printf(\u0026#34;buf = %s\\n\u0026#34;, buf); printf(\u0026#34;num = %d\\n\u0026#34;, num); return 0; } 执行结果\nbuf = 66666666666666 nihao num = 4 八、写文件fwrite #include \u0026lt;stdio.h\u0026gt; size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：向文件中写入数据 参数： ptr：要写入的数据 size：一次写入的字节数 nmemb：一共写入的次数 stream：文件指针 返回值： 成功：实际写入的次数 失败：0 示例代码：对file.txt进行fwrite操作\n#include \u0026lt;stdio.h\u0026gt; typedef struct{ int a; int b; char c; }MSG; int main(int argc, char *argv[]) { FILE *fp; fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;, \u0026#34;w+\u0026#34;); if(fp == NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } //使用fwrite向文件写入一个结构体 MSG msg[4] = {1, 2, \u0026#39;a\u0026#39;, 3, 4, \u0026#39;b\u0026#39;, 5, 6,\u0026#39;c\u0026#39;, \\ 7, 8, \u0026#39;d\u0026#39;}; fwrite(msg, sizeof(MSG), 4, fp); //fwrite,打开file.txt会发现里面有乱码 //因为我们的结构体在计算机中存储的方式和字符串是不一样的 //如果我们想要得到file.txt的正确内容,我们下面用fread操作 //fwite操作后,文件偏移量会移动到文件的末尾 //将文件的偏移量设置为文件的起始位置 //假如不进行rewind,那么fread会直接从文件的末尾开始读,会读出来为空 rewind(fp); MSG rcv[4]; fread(rcv, sizeof(MSG), 4, fp); int i; for(i = 0; i \u0026lt; 4; i++) { printf(\u0026#34;%d ‐ %d ‐ %c\\n\u0026#34;, rcv[i].a, rcv[i].b, rcv[i].c); } return 0; } 执行结果\n第一次fwrite执行结果 第二次fread执行结果 1 - 2 - a 3 - 4 - b 5 - 6 - c 7 - 8 - d 九、格式化读写文件函数 函数调用: fprintf(文件指针,格式字符串,输出表列); fscanf(文件指针,格式字符串,输入表列); 函数功能: 从磁盘文件中读入或输出字符 fprintf 和printf函数类似： printf是将数据输出到屏幕上（标准输出）， fprintf函数是将数据输出到文件指针所指定的文件中。 fscanf和scanf 函数类似： scanf是从键盘（标准输入）获取输入， fscanf是从文件指针所标示的文件中获取输入。 示例程序：对file.txt进行fprintf和fscanf操作\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { FILE *fp; char ch1=\u0026#39;a\u0026#39;, ch2; int num1=50, num2; char string1[20]=\u0026#34;hello\u0026#34;, string2[20]; float score1 = 85.5, score2; if((fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;,\u0026#34;w+\u0026#34;))==NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } //使用fprintf向文件写入字符串 fprintf(fp,\u0026#34;%c %d %s %f\\n\u0026#34;,ch1,num1,string1,score1); rewind(fp); //使用fscanf获取文件内容 fscanf(fp,\u0026#34;%c %d %s %f\\n\u0026#34;,\u0026amp;ch2,\u0026amp;num2,\u0026amp;string2,\u0026amp;score2); printf(\u0026#34;%c %d %s %f\\n\u0026#34;,ch2,num2,string2,score2); fclose(fp); return 0; } 执行结果\nfile.txt文件内容 a 50 hello 85.500000 运行终端 a 50 hello 85.500000 十、随机读写 前面介绍的对文件的读写方式都是顺序读写，即读写文件只能从头开始，顺序读写各个数据。\n但在实际问题中常要求只读写文件中某一指定的部分，例如：读取文件第200\u0026ndash;300个字节。\n为了解决这个问题可以移动文件内部的位置指针到需要读写的位置，再进行读写，这种读写称为随机读写。\n实现随机读写的关键是要按要求移动位置指针，这称为文件的定位。\n10.1 rewind #include \u0026lt;stdio.h\u0026gt; void rewind(FILE *stream); 功能：将文件位置定位到起始位置 参数： stream：文件指针 返回值：无 10.2 ftell #include \u0026lt;stdio.h\u0026gt; long ftell(FILE *stream); 功能：获取当前文件的偏移量 参数： stream：文件指针 返回值： 获取当前文件的偏移量 10.3 fseek #include \u0026lt;stdio.h\u0026gt; int fseek(FILE *stream, long offset, int whence); 功能：设置文件位置指针的偏移量 参数： stream：文件指针 offset：偏移量 可正可负也可为0 whence：相对位置 SEEK_SET 文件起始位置 SEEK_CUR 文件当前位置 SEEK_END 文件末尾位置（最后一个字符后面一个位置） 返回值： 成功：0 失败：‐1 rewind(fp) \u0026lt;==\u0026gt; fseek(fp, 0, SEEK_SET); 这样fseek就可以实现rewind的功能 示例程序：对file.txt进行rewind,ftell,fseek操作\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { FILE *fp; if((fp = fopen(\u0026#34;C:/Users/lzx/Desktop/file.txt\u0026#34;,\u0026#34;w+\u0026#34;))==NULL) { printf(\u0026#34;fail to fopen\\n\u0026#34;); return ‐1; } fputs(\u0026#34;123456789\\n\u0026#34;, fp); fputs(\u0026#34;abcdefghijklmn\u0026#34;, fp); //获取当前文件指针的读写位置 printf(\u0026#34;offset = %ld\\n\u0026#34;, ftell(fp)); //将当前文件的读写文件设置到文件的起始位置 //必须将当前文件的读写文件设置到文件的起始位置,因为fputs操作后读写位置已经到了文件的末尾,打印出来为空 rewind(fp); fseek(fp, 0, SEEK_SET); //将当前文件的读写位置设置为倒数第五个位置 //fseek(fp, ‐5, SEEK_END); char buf[32] = \u0026#34;\u0026#34;; while(fgets(buf, 32, fp) != NULL) { printf(\u0026#34;[%s]\\n\u0026#34;, buf); } return 0; } 执行结果\nfile.txt文件内容 123456789 abcdefghijklmn 运行终端 offset = 25 [jklmn] 彩蛋🎁\n整个春天，直至夏天，都是生命力独享风流的季节。长风沛雨，艳阳明月。那时田野被喜悦铺满，天地间充着生的豪情，风里梦里也全是不屈不挠的欲望。春天的美丽也正在于此，在于纯真和勇敢，在于未通世故。\n史铁生《比如摇滚与写作》 恭喜你🎉，完成了对第十章《文件》部分的学习，下一章我们将学习Linux基础命令。\n⏩第十一章《Linux基础命令》\n","permalink":"https://eddyblog.cn/posts/tech/embedded_high-level_c_programming_10file/","summary":"一、文件的概念 文件用来存放程序、文档、音频、视频数据、图片等数据的。 文件就是存放在磁盘上的，一些数据的集合。在windows下可以通过写字板或记事本打开文本文件对文件进行编辑保存。写字板和记事 本是微软程序员写的程序，对文件进行打开、显示、读写、关闭。 作为一个程序员，必须掌握编程实","title":"【嵌入式高级C编程】第十章 文件"},{"content":"第八章 结构体，共用体，枚举 一、结构体类型的概念及定义 1.1 基本概述 构造类型： 不是基本类型的数据结构也不是指针，它是若干个相同或不同类型的数据构成的集合 常用的构造类型有数组、结构体、共用体\n数组用于保存多个相同类型的数据 结构体用于保存多个不同类型的数据\n1.2 结构体的概念 结构体是一种构造类型的数据结构，\n是一种或多种基本类型或构造类型的数据的集合。\n1.3 结构体类型的定义 1.3.1 先定义结构体类型，再去定义结构体变量\nstruct 结构体类型名{ 成员列表 }; 例子：\nstruct stu{ int num; char name[20]; char sex; }; //有了结构体类型后，就可以用类型定义变量了\nstruct stu lucy, bob, lilei; //定义了三个struct stu类型的变量，注意不要把struct省略\n每个变量都有三个成员，分别是num name sex\n1.3.2 在定义结构体类型的时候顺便定义结构体变量，以后还可以定义结构体变量\nstruct 结构体类型名{ 成员列表; }结构体变量1,变量2; struct 结构体类型名 变量3，变量4； 例子：\nstruct stu{ int num; char name[20]; char sex; }lucy,bob,lilei; struct stu xiaohong,xiaoming; 注意：一般结构体类型都会定义在全局，也就是main函数的外面。\n所以在定义结构体类型的同时定义变量，这些变量一般都是全局变量。\n定义完类型之后定义的结构体变量内存分配要看定义的位置。\n1.3.3 无名结构体的定义\n在定义结构体类型的时候，没有结构体类型名，顺便定义结构体变量，因为没有类型名，所以以后不能再定义相关类型的数据了\nstruct { 成员列表; }变量1，变量2; 注意：无名结构体由于没有结构体名，所以定义完之后是无法在定义结构体变量的，只能在定义类型的同时定义结构体变量。\n例子：\nstruct { int num; char name[20]; char sex; }lucy,bob; 1.3.4 给结构体类型取别名\n通常咱们将一个结构体类型重新起个类型名，用新的类型名替代原先的类型\ntypedef struct 结构体名 { 成员列表; }重新定义的结构体类型名A; 注意：typedef主要用于给一个类型取别名，此时相当于给当前结构体重新起了一个类型名为A，相当于 struct 结构体名，所以如果结构体要取别名，一般不需要先给结构体定义名字，定义结构体变量时，直接使用A即可，不用加struct\n例子：\ntypedef struct stu{ int num; char name[20]; char sex; }STU; 以后STU 就相当于 struct stu\nSTU lucy; 和struct stu lucy; 是等价的，所以可以不指定stu这个名字\n二、结构体变量的定义初始化及使用 2.1 结构体变量的定义和初始化 结构体变量，是个变量，这个变量是若干个数据的集合\n注：\n(1)：在定义结构体变量之前首先得有结构体类型，然后在定义变量\n(2)：在定义结构体变量的时候，可以顺便给结构体变量赋初值，被称为结构体的初始化\n(3)：结构体变量初始化的时候，各个成员顺序初始化\n案例：\n#include \u0026lt;stdio.h\u0026gt; //定义结构体类型 struct stu{ int id; char name[32]; char sex; int age; //定义结构体变量之定义结构体类型的同时定义结构体变量 }zhangsan, lisi = {1002, \u0026#34;李四\u0026#34;, \u0026#39;B\u0026#39;, 25}; //使用typedef对结构体类型取别名 typedef struct{ int a; int b; char c; }MSG; int main(int argc, char *argv[]) { //定义结构体变量之类型定义完毕之后定义变量 struct stu wangwu; //结构体变量的初始化 struct stu zhaoliu = {1001, \u0026#34;赵六\u0026#34;, \u0026#39;B\u0026#39;, 20}; //如果使用typedef对结构体类型取别名 //就无法在定义类型的同时定义结构体变量 //在定义结构体变量的时候不用加struct MSG msg1, msg2 = {100, 200, \u0026#39;w\u0026#39;}; return 0; } 2.2 结构体变量的使用 结构体变量对成员调用的方式：\n结构体变量.结构体成员 注意：这地方说的结构体变量主要指的是普通结构体变量\n2.2.1 结构体变量的简单使用\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; struct stu{ int id; char name[32]; char sex; int age; }zhangsan, lisi = {1002, \u0026#34;李四\u0026#34;, \u0026#39;B\u0026#39;, 25}; typedef struct{ int a; int b; char c; }MSG; int main(int argc, char *argv[]) { struct stu wangwu; struct stu zhaoliu = {1001, \u0026#34;赵六\u0026#34;, \u0026#39;B\u0026#39;, 20}; MSG msg1, msg2 = {100, 200, \u0026#39;w\u0026#39;}; //结构体变量的使用 zhangsan.id = 1001; strcpy(zhangsan.name, \u0026#34;张三\u0026#34;); zhangsan.sex = \u0026#39;B\u0026#39;; zhangsan.age = 18; printf(\u0026#34;%d ‐ %s ‐ %c ‐ %d\\n\u0026#34;, zhangsan.id, zhangsan.name,zhangsan.sex, zhangsan.age); printf(\u0026#34;%d ‐ %s ‐ %c ‐ %d\\n\u0026#34;, lisi.id, lisi.name,lisi.sex, lisi.age); printf(\u0026#34;%d ‐ %s ‐ %c ‐ %d\\n\u0026#34;, zhaoliu.id, zhaoliu.name,zhaoliu.sex, zhaoliu.age); printf(\u0026#34;%d ‐ %d ‐ %c\\n\u0026#34;, msg2.a, msg2.b, msg2.c); return 0; } 执行结果\n1001 - 张三 - B - 18 1002 - 李四 - B - 25 1001 - 赵六 - B -20 100 - 200 - W Question：\n为什么这个时候不能直接给year赋值？\ntypedef struct{ int year; int month; int day; }BD; Answer：\n上述代码定义了一个结构体类型 BD，但它仅仅是一个类型的声明，没有创建任何具体的变量。因此，您不能直接给 year、month 或 day 赋值，因为这些成员是结构体内部的成员，需要通过结构体变量来访问和赋值。\n您可以理解为 BD 类型是一种用户自定义的数据类型，类似于 int 或其他基本数据类型。在使用它时，需要创建具体的变量，然后通过这些变量来操作其成员。\n例如，在使用 BD 类型时，您需要先创建一个 BD 类型的变量，然后通过该变量来访问和赋值其成员变量 year、month 和 day，就像前面的示例所示。\nBD birthday; // 创建一个BD类型的变量 birthday.year = 1990; // 给year成员变量赋值 birthday.month = 9; // 给month成员变量赋值 birthday.day = 15; // 给day成员变量赋值 这个变量 birthday 才是具体存储数据的实例，而 BD 只是定义了这种类型的数据结构。\n2.2.2 在结构体中嵌套结构体\n//在结构体中嵌套结构体 typedef struct{ int year; int month; int day; }BD; typedef struct{ int id; char name[32]; BD birthday; }STU; void test2() { STU xiaoming; xiaoming.id = 1001; strcpy(xiaoming.name, \u0026#34;小明\u0026#34;); //如果结构体中嵌套结构体，赋值时找到最内层的成员再进行赋值 xiaoming.birthday.year = 2002; xiaoming.birthday.month = 12; xiaoming.birthday.day = 20; printf(\u0026#34;%d ‐ %s ‐ %d‐%d‐%d\\n\u0026#34;, xiaoming.id, xiaoming.name,\\ xiaoming.birthday.year, xiaoming.birthday.month,\\ xiaoming.birthday.day); //嵌套的形式定义并初始化 STU xiaoli = {1002, \u0026#34;小丽\u0026#34;, 2000, 1, 1}; printf(\u0026#34;%d ‐ %s ‐ %d‐%d‐%d\\n\u0026#34;, xiaoli.id, xiaoli.name,\\ xiaoli.birthday.year, xiaoli.birthday.month,\\ xiaoli.birthday.day); } 执行结果\n1001 - 小明 - 2002-12-20 1002 - 小丽 - 2000-1-1 2.3 相同类型的结构体变量可以相互赋值 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; struct stu{ int id; char name[32]; char sex; int age; }; int main(int argc, char *argv[]) { struct stu zhangsan; zhangsan.id = 1001; strcpy(zhangsan.name, \u0026#34;张三\u0026#34;); zhangsan.sex = \u0026#39;B\u0026#39;; zhangsan.age = 18; printf(\u0026#34;%d ‐ %s ‐ %c ‐ %d\\n\u0026#34;, zhangsan.id, zhangsan.name,\\ zhangsan.sex, zhangsan.age); //相同类型的结构体变量之间可以直接赋值 struct stu lisi; lisi = zhangsan; printf(\u0026#34;%d ‐ %s ‐ %c ‐ %d\\n\u0026#34;, lisi.id, lisi.name,\\ lisi.sex, lisi.age); return 0; } 这是我优化后的代码：\n#include\u0026lt;stdio.h\u0026gt; typedef struct { int id; char name[32]; char sex; int age; }STU; int main(int argc, char *argv[]) { STU zhangsan = {1001, \u0026#34;张三\u0026#34;, \u0026#39;B\u0026#39;, 18}; printf(\u0026#34;%d - %s - %c - %d\\n\u0026#34;,zhangsan.id,zhangsan.name,\\ zhangsan.sex,zhangsan.age); //相同类型的结构体变量之间可以直接赋值 STU lisi; lisi = zhangsan; printf(\u0026#34;%d - %s - %c - %d\\n\u0026#34;,lisi.id,lisi.name,\\ lisi.sex,lisi.age); return 0; } 执行结果\n1001 - 张三 - B - 18 1001 - 张三 - B - 18 三、结构体数组 结构体数组是个数组，由若干个相同类型的结构体变量构成的集合\n1、结构体数组的定义方法\nstruct 结构体类型名 数组名[元素个数]; 例子：\nstruct stu{ int num; char name[20]; char sex; }; struct stu edu[3]; 定义了一个struct stu 类型的结构体数组edu， 这个数组有3个元素分别是edu[0] 、edu[1]、edu[2] 2、结构体数组元素的引用\n数组名[下标] 3、结构体数组元素对成员的使用\n数组名[下标].成员 案例：\n#include \u0026lt;stdio.h\u0026gt; typedef struct{ int num; char name[20]; float score; }STU; int main(int argc, char *argv[]) { //定义一个结构体数组 STU edu[3] = { {101,\u0026#34;Lucy\u0026#34;,78}, {102,\u0026#34;Bob\u0026#34;,59.5}, {103,\u0026#34;Tom\u0026#34;,85} }; //输出结构体数组中的元素 int j; for(j = 0; j \u0026lt; 3; j++) { printf(\u0026#34;%d ‐ %s ‐ %.2f\\n\u0026#34;, edu[j].num, edu[j].name,\\ edu[j].score); } int i; float sum=0; for(i = 0; i \u0026lt; 3; i++) { sum += edu[i].score; } printf(\u0026#34;平均成绩为%.2f\\n\u0026#34;,sum / 3); return 0; } 执行结果\n101 - Lucy - 78.00 102 - Bob - 59.50 103 - Tom - 85.00 平均成绩为74.17 四、结构体指针 即结构体的地址，结构体变量存放内存中，也有起始地址\n咱们定义一个变量来存放这个地址，那这个变量就是结构体指针变量。\n1、结构体指针变量的定义方法：\nstruct 结构体类型名 * 结构体指针变量名; 2、结构体指针变量对成员的引用\n(*结构体指针变量名).成员 结构体指针变量名‐\u0026gt;成员 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; struct stu{ int id; char name[32]; char sex; int age; }; int main(int argc, char *argv[]) { //定义一个结构体指针变量 struct stu *s; //在堆区开辟结构体空间并将其地址保存在结构体指针变量中 s = (struct stu *)malloc(sizeof(struct stu)); s-\u0026gt;id = 1001; strcpy(s-\u0026gt;name, \u0026#34;张三\u0026#34;); s-\u0026gt;sex = \u0026#39;B\u0026#39;; s-\u0026gt;age = 20; printf(\u0026#34;%d - %s - %c - %d\\n\u0026#34;, s-\u0026gt;id, s-\u0026gt;name, s-\u0026gt;sex, s-\u0026gt;age); return 0; } 执行结果\n1001 - 张三 - B - 20 五、结构体内存分配问题 #include\u0026lt;stdio.h\u0026gt; struct stu{ char sex; int age; }lucy; int main() { printf(\u0026#34;%d\\n\u0026#34;,sizeof(lucy)); //结果为 8？？？ return 0; } 引言：\n结构体变量大小是它的所有成员之和，那么为什么上述例子中sizeof(lucy)不是1+4=5而是8呢？❓\n结构体变量究竟是怎么分配内存的呢？❓\n请看下文🕵‍(侦探)\n实际给结构体变量分配内存的时候，是规则的\n规则1：以多少个字节为单位开辟内存\n给结构体变量分配内存的时候，会去结构体变量中找基本类型的成员\n哪个基本类型的成员占字节数多，就以它大大小为单位开辟内存,\n在gcc中出现了double类型的例外\n(1)：成员中只有char型数据 ，以1字节为单位开辟内存。\n(2)：成员中出现了short 类型数据，没有更大字节数的基本类型数据。以2字节为单位开辟内存\n(3)：出现了int 、float 没有更大字节的基本类型数据的时候以4字节为单位开辟内存。\n(4)：出现了double类型的数据\n情况1：\n在vc里，以8字节为单位开辟内存。\n情况2：\n在gcc里，以4字节为单位开辟内存。\n无论是那种环境，double型变量，占8字节。\n(5)：如果在结构体中出现了数组，数组可以看成多个变量的集合。\n如果出现指针的话，没有占字节数更大的类型的，以4字节为单位开辟内存。\n(6)：在内存中存储结构体成员的时候，按定义的结构体成员的顺序存储。\n规则2：字节对齐\n(1)：char 1字节对齐 ，即存放char型的变量，内存单元的编号是1的倍数即可。\n(2)：short 2字节对齐 ，即存放short int 型的变量，起始内存单元的编号是2的倍数即可。\n(3)：int 4字节对齐 ，即存放int 型的变量，起始内存单元的编号是4的倍数即可。\n(4)：long 在32位平台下，4字节对齐 ，即存放long int 型的变量，起始内存单元的编号是4的倍数即可。\n(5)：float 4字节对齐 ，即存放float 型的变量，起始内存单元的编号是4的倍数即可。\n(6)：double\na.vc环境下\n8字节对齐，即存放double型变量的起始地址，必须是8的倍数，double变量占8字节。\nb.gcc环境下\n4字节对齐，即存放double型变量的起始地址，必须是4的倍数，double变量占8字节。\n注意：\n当结构体成员中出现数组的时候，可以看成多个变量。\n开辟内存的时候，从上向下依次按成员在结构体中的位置顺序开辟空间\n例子：temp占 8 个字节\n#include\u0026lt;stdio.h\u0026gt; struct stu{ char a; short int b; int c; }temp; int main() { printf(\u0026#34;%d\\n\u0026#34;,sizeof(temp)); printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;(temp.a)); printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;(temp.b)); printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;(temp.c)); return 0; } 这是具体分配内存的图示\n结果分析：\na 的地址和 b 的地址差 2 个字节\nb 的地址和 c 的地址差 2 个字节\n例子：temp 的大小为 12 个字节\nstruct stu{ char a; int c; short int b; }temp; 结果分析：\na 和 c 的地址差 4 个字节\nc 和 b 的地址差 4 个字节\n例子：\nstruct stu{ char a; double b; }temp; 结果分析;\n在 vc 中占 16 个字节 a 和 b 的地址差 8 个字节\n在 gcc 中占 12 个字节 a 和 b 的地址差 4 个字节\n例子：\nstruct stu{ int num; int age; }lucy; 8字节 struct stu{ char sex; int age; }lucy; 8字节 struct stu{ char a; short int b; int c; }temp; 8字节 struct stu{ char a; int c; short int b; }temp; 12字节 struct stu{ char buf[10]; int a; }temp; 16字节 struct stu{ char a; double b; }; 12字节 为什么要有字节对齐？\n用空间来换时间，提高cpu读取数据的效率\n看到这里的话，恭喜你，已经掌握了结构体的基本知识。🏅\n本章已过完1/3，下一节，我们将对《位段》进行学习。⏩\n六、位段 引言：\n位段是偏底层的内容\n目前做应用层的话只需了解即可\n我目前也不知道这是做什么的😶‍🌫️(迷茫)\n一、位段\n在结构体中，以位为单位的成员，咱们称之为位段(位域)。\nstruct packed_data{\nunsigned int a:2;\nunsigned int b:6;\nunsigned int c:4;\nunsigned int d:4;\nunsigned int i;\n} data;\n注意：不能对位段成员取地址\n#include\u0026lt;stdio.h\u0026gt; struct packed_data{ unsigned int a:2; unsigned int b:6; unsigned int c:4; unsigned int d:4; unsigned int i; } data; int main() { printf(\u0026#34;%d\\n\u0026#34;,sizeof(data)); printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;data); printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;(data.i)); return 0; } 位段注意：\n1、对于位段成员的引用如下：\ndata.a =2\n赋值时，不要超出位段定义的范围;\n如段成员a定义为2位，最大值为3,即（11）2\n所以data.a =5，就会取5的低两位进行赋值 101\n2、位段成员的类型必须指定为整形或字符型\n3、一个位段必须存放在一个存储单元中，不能跨两个单元\n第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段。\n位段的存储单元：\n(1)：char型位段 存储单元是1个字节\n(2)：short int型的位段存储单元是2个字节\n(3)：int的位段，存储单元是4字节\n(4)：long int的位段，存储单元是4字节\nstruct stu{ char a:7; char b:7; char c:2; }temp;//占3字节，b不能跨 存储单元存储 #include\u0026lt;stdio.h\u0026gt; struct stu{ char a:7; char b:7; char c:2; }temp; int main() { printf(\u0026#34;%d\\n\u0026#34;,sizeof(temp)); return 0; } 结果为：3 ，证明位段不能跨其存储单元存储 注意：不能 取 temp.b的地址，因为b可能不够1字节，不能取地址。\n4、位段的长度不能大于存储单元的长度\n(1)：char型位段不能大于8位\n(2)：short int型位段不能大于16位\n(3)：int的位段，位段不能大于32位\n(4)：long int的位段，位段不能大于32位\n#include\u0026lt;stdio.h\u0026gt; struct stu{ char a:9; char b:7; char c:2; }temp; int main() { printf(\u0026#34;%d\\n\u0026#34;,sizeof(temp)); return 0; } 分析： 编译出错，位段a不能大于其存储单元的大小 5、如一个段要从另一个存储单元开始，可以定义：\nunsigned char a:1;\nunsigned char b:2;\nunsigned char :0;\nunsigned char c:3;(另一个单元)\n由于用了长度为0的位段，其作用是使下一个位段从下一个存储单元开始存放\n将a、b存储在一个存储单元中，c另存在下一个单元\n#include\u0026lt;stdio.h\u0026gt; struct m_type{ unsigned char a:1; unsigned char b:2; unsigned char :0; unsigned char c:3; }; int main() { struct m_type temp; printf(\u0026#34;%d\\n\u0026#34;,sizeof(temp)); return 0; } 6、可以定义无意义位段,如：\nunsigned a: 1;\nunsigned : 2;\nunsigned b: 3;\nstruct data{ char a:1; char b:1; char c:1; char d:1; char e:1; char f:1; char g:1; char h:1; }temp; int main() { char p0; //p0=0x01;// 0000 0001 temp.a=1; //p0=temp;//错的，类型不匹配 //p0=(char)temp;//错的，编译器不允许将结构体变量，强制转成基本类型的。 p0 = *((char *)(\u0026amp;temp)); } ​\n指定对齐原则：\n使用#pragma pack改变默认对其原则\n格式：\n#pragma pack (value)时的指定对齐值value。\n📢 这个部分可以先不学习，一般情况下都是用的默认对齐原则\n七、共用体 1：共用体和结构体类似，也是一种构造类型的数据结构。\n既然是构造类型的，咱们得先定义出类型，然后用类型定义变量。\n定义共用体类型的方法和结构体非常相似，把struct 改成union 就可以了。\n在进行某些算法的时候，需要使几种不同类型的变量存到同一段内存单元中，几个变量所使用空间相互重叠。\n这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作“共用体”类型结构\n共用体所有成员占有同一段地址空间\n共用体的大小是其占内存长度最大的成员的大小\n共用体的特点：\n1、同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用\n2、共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的\n成员的值会被覆盖\n3、共用体变量的地址和它的各成员的地址都是同一地址\n4、共用体变量的初始化union data a={123}; 初始化共用体为第一个成员\n#include \u0026lt;stdio.h\u0026gt; //定义一个共用体 union un{ int a; int b; int c; }; int main(int argc, char *argv[]) { //定义共用体变量 union un myun; myun.a = 100; myun.b = 200; myun.c = 300; printf(\u0026#34;a = %d, b = %d, c = %d\\n\u0026#34;, myun.a, myun.b, myun.c); return 0; } 执行结果\na = 300, b = 300, c = 300 八、枚举 将变量的值一一列举出来，变量的值只限于列举出来的值的范围内\n枚举类型也是个构造类型的\n1、枚举类型的定义\nenum 枚举类型名{ 枚举值列表； }; 在枚举值表中应列出所有可用值,也称为枚举元素\n枚举变量仅能取枚举值所列元素\n2、枚举变量的定义方法\nenum 枚举类型名 枚举变量名; ① 枚举值是常量,不能在程序中用赋值语句再对它赋值\n例如：sun=5; mon=2; sun=mon; 都是错误的.\n② 枚举元素本身由系统定义了一个表示序号的数值\n默认是从0开始顺序定义为0，1，2…\n如在week中，mon值为0，tue值为1， …,sun值为6\n③ 可以改变枚举值的默认值：如\nenum week //枚举类型 { mon=3，tue，wed，thu，fri=4，sat,sun }; mon=3 tue=4,以此类推 fri=4 以此类推 注意：在定义枚举类型的时候枚举元素可以用等号给它赋值，用来代表元素从几开始编号\n在程序中，不能再次对枚举元素赋值，因为枚举元素是常量。\n#include \u0026lt;stdio.h\u0026gt; //定义一个枚举类型 enum week { mon=8, tue, wed, thu=2, fri, sat, sun }; int main(int argc, char *argv[]) { //定义枚举类型的变量 enum week day = mon; printf(\u0026#34;day = %d\\n\u0026#34;, day); day = fri; printf(\u0026#34;day = %d\\n\u0026#34;, day); return 0; } 执行结果\nday = 8 day = 3 彩蛋🎁\n我时常想，做学问，做事业，在人生中都只能算是第二桩事。人生第一桩事是生活。我所谓的“生活”是“领略”，是“培养生机”。假若为学问为事业而忘却生活，那种学问，事业在人生中便失去其真正意义与价值。\n朱光潜《给青年的十二封信》 恭喜你🎉，完成了对第八章《结构体，共用体，枚举》部分的学习，下一章我们将学习链表。\n⏩第九章《链表》\n","permalink":"https://eddyblog.cn/posts/tech/embedded_high-level_c_programming_08_struct_common-body_enumeration/","summary":"第八章 结构体，共用体，枚举 一、结构体类型的概念及定义 1.1 基本概述 构造类型： 不是基本类型的数据结构也不是指针，它是若干个相同或不同类型的数据构成的集合 常用的构造类型有数组、结构体、共用体 数组用于保存多个相同类型的数据 结构体用于保存多个不同类型的数据 1.2 结构体的概念 结构体是一种构造类型的","title":"【嵌入式高级C编程】第八章 结构体，共用体，枚举"},{"content":"第六章 动态内存申请 一、动态分配内存的概 在数组一章中，介绍过数组的长度是预先定义好的，在整个程序中固定不变，但是在实际的编程中，往往会发生这种情况，即所需的内存空间取决于实际输入的数据，而无法预先确定 。\n为了解决上述问题，Ｃ语言提供了一些内存管理函数，这些内存管理函数可以按需要动态的分配内存空间，也可把不再使用的空间回收再次利用。\n动态分配内存就是在堆区开辟空间。\n二、静态分配、动态分配 静态分配\n1、 在程序编译或运行过程中，按事先规定大小分配内存空间的分配方式。int a [10]\n2、 必须事先知道所需空间的大小。\n3、 分配在栈区或全局变量区，一般以数组的形式。\n4、 按计划分配。\n动态分配\n1、在程序运行过程中，根据需要大小自由分配所需空间。\n2、按需分配。\n3、分配在堆区，一般使用特定的函数进行分配。\n三、动态分配函数 3.1 malloc #include \u0026lt;stdlib.h\u0026gt; void *malloc(unsigned int size); 功能：在堆区开辟指定长度的空间，并且空间是连续的 参数： size：要开辟的空间的大小 返回值： 成功：开辟好的空间的首地址 失败：NULL 注意\n1、在调用malloc之后，一定要判断一下，是否申请内存成功。\n2、如果多次malloc申请的内存，第1次和第2次申请的内存不一定是连续的\n3、使用malloc开辟空间需要保存开辟好的空间的首地址，但是由于不确定空间用于做什么，所以本身返回值类型为void *，所以在调用函数时根据接收者的类型对其进行强制类型转换\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; char *fun() { //char ch[100] = \u0026#34;hello world\u0026#34;; //静态全局区的空间只要开辟好，除非程序结束，否则不会释放，所以 //如果是临时使用，不建议使用静态全局区的空间 //static char ch[100] = \u0026#34;hello world\u0026#34;; //堆区开辟空间，手动申请手动释放，更加灵活 //使用malloc函数的时候一般要进行强转 char *str = (char *)malloc(100 * sizeof(char)); str[0] = \u0026#39;h\u0026#39;; str[1] = \u0026#39;e\u0026#39;; str[2] = \u0026#39;l\u0026#39;; str[3] = \u0026#39;l\u0026#39;; str[4] = \u0026#39;o\u0026#39;; str[5] = \u0026#39;\\0\u0026#39;; return str; } int main(int argc, char *argv[]) { char *p; p = fun(); printf(\u0026#34;p = %s\\n\u0026#34;, p); return 0; } 执行结果\np = hello 3.2 free #include \u0026lt;stdlib.h\u0026gt; void free(void *ptr) 功能：释放堆区的空间 参数： ptr：开辟后使用完毕的堆区的空间的首地址 返回值： 无 注意：\nfree函数只能释放堆区的空间，其他区域的空间无法使用free\nfree释放空间必须释放malloc或者calloc或者realloc的返回值对应的空间，不能说只释放一部分\nfree(p); 注意当free后，因为没有给p赋值，所以p还是指向原先动态申请的内存。但是内存已经不能再用了，p变成野指针了，所以一般为了放置野指针，会free完毕之后对p赋为NULL。\n一块动态申请的内存只能free一次，不能多次free\n3.3 calloc #include \u0026lt;stdlib.h\u0026gt; void * calloc(size_t nmemb,size_t size); 功能：在堆区申请指定大小的空间 参数： nmemb：要申请的空间的块数 size：每块的字节数 返回值： 成功：申请空间的首地址 失败：NULL 注意：\nmalloc和calloc函数都是用来申请内存的。\n区别：\n函数的名字不一样\n参数的个数不一样\nmalloc申请的内存，内存中存放的内容是随机的，不确定的，而calloc函数申请的内存中的内容为0\n例如：\nchar *p=(char *)calloc(3,100); 在堆中申请了3块，每块大小为100个字节，即300个字节连续的区域\n3.4 realloc #include \u0026lt;stdlib.h\u0026gt; void* realloc(void *s,unsigned int newsize); 功能：在原本申请好的堆区空间的基础上重新申请内存，新的空间大小为函数的第二个参数 如果原本申请好的空间的后面不足以增加指定的大小，系统会重新找一个足够大的位置开辟指定的空间，然后将原本空间中的数据拷贝过来，然后释放原本的空间 如果newsize比原先的内存小，则会释放原先内存的后面的存储空间，只留前面的newsize个字节 参数： s：原本开辟好的空间的首地址 newsize：重新开辟的空间的大小 返回值： 新的空间的首地址 增加空间：\nchar *p; p=(char *)malloc(100) //想在100个字节后面追加50个字节 p=(char *)realloc(p,150);//p指向的内存的新的大小为150个字节 减少空间:\nchar *p; p=(char *)malloc(100) //想重新申请内存,新的大小为50个字节 p=(char *)realloc(p,50);//p指向的内存的新的大小为50个字节,100个字节的后50个字节的存储空间就被释放了 注意:malloc calloc relloc 动态申请的内存，只有在free或程序结束的时候才释放。\n四、内存泄漏 内存泄露的概念：\n申请的内存，首地址丢了，找不了，再也没法使用了，也没法释放了，这块内存就被泄露了。\n内存泄漏案例1：\nint main() { char *p; p=(char *)malloc(100); //接下来，可以用p指向的内存了 p=\u0026#34;hello world\u0026#34;;//p指向别的地方了，保存字符串常量的首地址 //从此以后，再也找不到你申请的100个字节了。则动态申请的100个字节就被泄露了 return 0; } 内存泄漏案例2：\nvoid fun() { char *p; p=(char *)malloc(100); //接下来，可以用p指向的内存了 ... } int main() { //每调用一次fun泄露100个字节 fun(); fun(); return 0; } 解决方式1：\nvoid fun() { char *p; p=(char *)malloc(100); //接下来，可以用p指向的内存了 ... free(p); } int main() { fun(); fun(); return 0; } 解决方式2：\nchar * fun() { char *p; p=(char *)malloc(100); //接下来，可以用p指向的内存了 ... return p; } int main() { char *q; q=fun(); //可以通过q使用 ，动态申请的100个字节的内存了 //记得释放 free(q); //防止野指针 q = NULL; return 0; } 总结：申请的内存，一定不要把首地址给丢了，在不用的时候一定要释放内存。\n彩蛋🎁\n我默默地想，慢慢地写。看见冬阳下的骆驼队走过来，听见缓慢悦耳的铃声，童年重临于我的心头。\n林海音《城南旧事》 恭喜你🎉，完成了对第六章《动态内存申请》部分的学习，下一章我们将学习字符串处理函数。\n⏩第七章 《字符串处理函数》\n","permalink":"https://eddyblog.cn/posts/tech/embedded_high-level_c_programming_06dynamic_memory_request/","summary":"第六章 动态内存申请 一、动态分配内存的概 在数组一章中，介绍过数组的长度是预先定义好的，在整个程序中固定不变，但是在实际的编程中，往往会发生这种情况，即所需的内存空间取决于实际输入的数据，而无法预先确定 。 为了解决上述问题，Ｃ语言提供了一些内存管理函数，这些内存管理函数可以按需要动态的","title":"【嵌入式高级C编程】第六章 动态内存申请"},{"content":"第七章 字符串处理函数 一、获取字符串长度函数 #include \u0026lt;string.h\u0026gt; size_t strlen(const char *s); 功能：计算一个字符串的长度 参数： s：指定的字符串 返回值： 当前字符串的长度 注意：strlen获取的字符串长度遇到第一个\\0结束且\\0不算做字符串长度之中 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { //使用strlen函数获取字符串的长度 //strlen获取的字符串的长度遇到第一个\\0结束 char s1[100] = \u0026#34;hel\\0lo\u0026#34;; printf(\u0026#34;s1_len = %d\\n\u0026#34;, strlen(s1)); printf(\u0026#34;s1_size = %d\\n\u0026#34;, sizeof(s1)); char *s2 = \u0026#34;hello\u0026#34;; printf(\u0026#34;s2_len = %d\\n\u0026#34;, strlen(s2)); printf(\u0026#34;s2_size = %d\\n\u0026#34;, sizeof(s2)); return 0; } 执行结果\ns1_len = 3 s1_size = 100 s2_len = 5 s2_size = 4 二、字符串拷贝函数 #include \u0026lt;string.h\u0026gt; char *strcpy(char *dest, const char *src); 功能：将src复制给dest 参数： dest：目的字符串 src：源字符串 返回值： 保存dest字符串的首地址 注意： 使用strcpy函数复制字符串时必须保证dest足够大，否则会内存溢出 strcpy是将src字符串中第一个\\0之前包括\\0复制给dest char *strncpy(char *dest, const char *src, size_t n); 函数的说明： 将src指向的字符串前n个字节，拷贝到dest指向的内存中 返回值: 目的内存的首地址 注意： 1、strncpy不拷贝 ‘\\0’ 2、如果n大于src指向的字符串中的字符个数，则在dest后面填充n‐strlen(src)个’\\0’ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { //使用strcpy函数拷贝字符串 char s1[32] = \u0026#34;hello world\u0026#34;; //使用strcpy函数时，必须保证第一个参数的内存足够大 //char s1[5] = \u0026#34;abcd\u0026#34;; char s2[32] = \u0026#34;abcdefg\u0026#34;; strcpy(s1, s2); printf(\u0026#34;s1 = %s\\n\u0026#34;, s1); int i; for(i = 0; i \u0026lt; 32; i++) { printf(\u0026#34;[%c] ‐ %d\\n\u0026#34;, s1[i], s1[i]); } return 0; } 执行结果\ns1 = abcdefg [a] - 97 [b] - 98 [c] - 99 [d] - 100 [e] - 101 [f] - 102 [g] - 103 [] - 0 [r] - 114 [l] - 108 [d] - 100 [] - 0 [] - 0 三、字符串追加函数 #include \u0026lt;string.h\u0026gt; char *strcat(char *dest, const char *src); 功能：将src追加到dest的后面 参数： dest：目的字符串 src：源字符串 返回值： 保存dest字符串的首地址 char *strncat(char *dest, const char *src, size_t n); 追加src指向的字符串的前n个字符，到dest指向的字符串的后面。 注意如果n 大于src的字符个数，则只将src字符串追加到dest指向的字符串的后面 追加的时候会追加’\\0’ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { //使用strcat函数追加字符串 char s1[32] = \u0026#34;hello world\u0026#34;; char s2[32] = \u0026#34;abcdef\u0026#34;; //strcat是从s1的\\0的位置开始追加，直到s2的第一个\\0复制完毕后结束 strcat(s1, s2); printf(\u0026#34;s1 = %s\\n\u0026#34;, s1); return 0; } 执行结果\ns1 = hello worldabcdef 四、字符串比较函数 #include \u0026lt;string.h\u0026gt; int strcmp(const char *s1, const char *s2); int strncmp(const char *s1, const char *s2, size_t n); 功能：strcmp是比较两个字符串的内容，strncmp是比较两个字符串的前n个字节是否一样 参数： s1、s2：要比较的两个字符串 n：strncmp中的参数n表示要比较的字节数 返回值： 0 s1 = s2 \u0026gt;0 s1 \u0026gt; s2 \u0026lt;0 s1 \u0026lt; s2 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { //使用strcmp比较两个字符串的内容是否一致 //strcmp函数一个字符一个字符比较，只要出现不一样的，就会立即返回 char s1[] = \u0026#34;hello\u0026#34;; char s2[] = \u0026#34;w\u0026#34;; int ret = strcmp(s1, s2); if(ret == 0) { printf(\u0026#34;s1 = s2\\n\u0026#34;); } else if(ret \u0026gt; 0) { printf(\u0026#34;s1 \u0026gt; s2\\n\u0026#34;); } else { printf(\u0026#34;s1 \u0026lt; s2\\n\u0026#34;); } return 0; } 执行结果\ns1 \u0026lt; s2 五、字符查找函数 #include \u0026lt;string.h\u0026gt; char *strchr(const char *s, int c); 功能：在字符指针s指向的字符串中，找ascii 码为c的字符 参数： s：指定的字符串 c：要查找的字符 返回值： 成功：找到的字符的地址 失败：NULL 注意：s指向的字符串中有多个ASCII为c的字符，则找的是第1个字符 char *strrchr(const char *s, int c); 功能：在s指向的字符串中，找最后一次出现的ASCII为c的字符， #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { //使用strchr函数在一个字符串中查找字符 char s[] = \u0026#34;hel6lo wor6ld\u0026#34;; //找第一个匹配的字符 char *ret = strchr(s, \u0026#39;6\u0026#39;); //找最后一个匹配的字符 //char *ret = strrchr(s, \u0026#39;6\u0026#39;); if(ret == NULL) { printf(\u0026#34;没有找到\\n\u0026#34;); } else { printf(\u0026#34;找到了，在数组的第%d个位置\\n\u0026#34;, ret ‐ s); } return 0; } 执行结果\n找到了，在数组的第3个位置 六、字符串匹配函数 #include \u0026lt;string.h\u0026gt; char *strstr(const char *haystack, const char *needle); 函数说明： 在haystack指向的字符串中查找needle指向的字符串，也是首次匹配 返回值： 找到了：找到的字符串的首地址 没找到：返回NULL #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { //使用strstr函数在一个字符串中查找另一个字符串 char s[] = \u0026#34;1234:4567:666:789:666:7777\u0026#34;; //strstr查找的时候，查找的是第二个参数的第一个\\0之前的内容 char *ret = strstr(s, \u0026#34;666\u0026#34;); if(ret == NULL) { printf(\u0026#34;没找到\\n\u0026#34;); } else { printf(\u0026#34;找到了，在当前字符串的第%d个位置\\n\u0026#34;, ret ‐ s); } return 0; } 执行结果\n找到了，在当前字符串的第10个位置 七、字符串转换数值 #include \u0026lt;stdlib.h\u0026gt; int atoi(const char *nptr); 功能：将一个数字型字符串转化为整形数据 参数： nptr：指定的字符串 返回值： 获取到的整形数据 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]) { //使用atoi将数字型字符串转化为整形数据 char s1[] = \u0026#34;7856\u0026#34;; int ret1 = atoi(s1); printf(\u0026#34;ret1 = %d\\n\u0026#34;, ret1); //使用atof将浮点型的字符串转化为浮点型数据 char s2[] = \u0026#34;3.1415926\u0026#34;; double ret2 = atof(s2); printf(\u0026#34;ret2 = %lf\\n\u0026#34;, ret2); return 0; } 执行结果\nret1 = 7856 ret2 = 3.141593 八、字符串切割函数 #include \u0026lt;string.h\u0026gt; char *strtok(char *str, const char *delim); 功能：对字符串进行切割 参数： str：要切割的字符串 第一次切割，就传入指定的字符串，后面所有次的切割传NULL delim：标识符，要根据指定的delim进行切割，切割的结果不包含delim 返回值： 返回切割下来的字符串的首地址，如果都切割完毕，则返回NULL #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { //使用strtok函数切割字符串 char s[] = \u0026#34;111:22222:33:4444444444:5555555555555\u0026#34;; char *ret; //第一次切割 ret = strtok(s, \u0026#34;:\u0026#34;); printf(\u0026#34;ret = %s\\n\u0026#34;, ret); //后面所有切割时都要将strtok的第一个参数传NULL while((ret = strtok(NULL, \u0026#34;:\u0026#34;)) != NULL) { printf(\u0026#34;ret = %s\\n\u0026#34;, ret); } return 0; } 执行结果\nret = 111 ret = 22222 ret = 33 ret = 4444444444 ret = 5555555555555 九、格式化字符串操作函数 #include \u0026lt;stdio.h\u0026gt; int sprintf(char *str, const char *format, ...); 功能：将按照格式保存的字符串复制给str 参数： str：保存字符串 format：同printf 返回值： 保存的字符串的字节数 #include \u0026lt;stdio.h\u0026gt; int sscanf(const char *str, const char *format, ...); 功能：scanf是从终端读取数据并赋值给对应变量，而sscanf是从第一个参数中读取数据 参数： str：指定要获取内容的字符串 format：按照格式获取数据保存在变量中 返回值： 成功获取的个数 9.1 sprintf和sscanf的基本用法 //sprintf和sscanf的基本用法 void test1() { char buf[20]; int a, b, c; sprintf(buf,\u0026#34;%d:%d:%d\u0026#34;,2013,10,1); printf(\u0026#34;buf = %s\\n\u0026#34;,buf); sscanf(\u0026#34;2013:10:1\u0026#34;, \u0026#34;%d:%d:%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); printf(\u0026#34;a=%d,b=%d,c=%d\\n\u0026#34;,a,b,c); } 执行结果\nbuf = 2013:10:1 a=2013,b=10,c=1 9.2 sscanf高级用法 //sscanf高级用法 void test2() { //1、跳过数据：%*s或%*d char buf1[20]; sscanf(\u0026#34;1234 5678\u0026#34;,\u0026#34;%*d %s\u0026#34;,buf1); printf(\u0026#34;%s\\n\u0026#34;,buf1); //2、读指定宽度的数据：%[width]s char buf2[20]; sscanf(\u0026#34;12345678\u0026#34;,\u0026#34;%4s \u0026#34;,buf2); printf(\u0026#34;%s\\n\u0026#34;,buf2); //3、支持集合操作：只支持获取字符串 // %[a‐z] 表示匹配a到z中任意字符(尽可能多的匹配) // %[aBc] 匹配a、B、c中一员，贪婪性 // %[^aFc] 匹配非a、F、c的任意字符，贪婪性 // %[^a‐z] 表示读取除a‐z以外的所有字符 char buf3[20]; sscanf(\u0026#34;agcd32DajfDdFF\u0026#34;,\u0026#34;%[a‐z]\u0026#34;,buf3); printf(\u0026#34;%s\\n\u0026#34;,buf3); } 执行结果\n5678 1234 agcd 十、const #include \u0026lt;stdio.h\u0026gt; //const修饰全局变量 //此时全局变量只能使用但是不能修改， //如果直接拿全局变量修改值，编译直接报错 //如果使用全局变量的地址修改值，运行时程序异常结束 const int a = 100; void test1() { printf(\u0026#34;a = %d\\n\u0026#34;, a); //a = 666; //printf(\u0026#34;a = %d\\n\u0026#34;, a); int *p = \u0026amp;a; *p = 888; printf(\u0026#34;a = %d\\n\u0026#34;, a); } //const修饰普通局部变量 //可以读取变量的值 //不能直接通过变量进行修改值，编译报错 //可以通过变量的地址修改值 void test2() { const int b = 100; printf(\u0026#34;b = %d\\n\u0026#34;, b); //b = 666; //printf(\u0026#34;b = %d\\n\u0026#34;, b); int *p = \u0026amp;b; *p = 888; printf(\u0026#34;b = %d\\n\u0026#34;, b); } //const修饰指针变量 //如果const修饰指针变量的类型，无法通过指针变量修改地址里面的值 //如果const修饰指针变量，无法修改指针变量保存的地址 //如果const既修饰指针变量的类型，又修饰指针变量，则只能通过原本变量修改值 void test3() { int c = 100; //const修饰指针变量的类型 //const int * p = \u0026amp;c; //const修饰指针变量 //int * const p = \u0026amp;c; //const既修饰指针变量的类型，又修饰指针变量 const int * const p = \u0026amp;c; printf(\u0026#34;*p = %d\\n\u0026#34;, *p); c = 666; printf(\u0026#34;*p = %d\\n\u0026#34;, *p); *p = 777; printf(\u0026#34;*p = %d\\n\u0026#34;, *p); int d = 888; p = \u0026amp;d; printf(\u0026#34;*p = %d\\n\u0026#34;, *p); } int main(int argc, char *argv[]) { test3(); return 0; } 彩蛋🎁\n当你走在灿烂的阳光下，你会惊奇地发现，生命的一切及苦难，不过是在插满尖玻璃的墙头上行走。\n塞斯·诺特博姆《狐狸在夜晚来临》 恭喜你🎉，完成了对第七章《字符串处理函数》部分的学习，下一章我们将学习结构体，共用体，枚举。\n⏩第八章 《结构体，共用体，枚举》\n","permalink":"https://eddyblog.cn/posts/tech/embedded_high-level_c_programming_07string_manipulation_functions/","summary":"第七章 字符串处理函数 一、获取字符串长度函数 #include \u0026lt;string.h\u0026gt; size_t strlen(const char *s); 功能：计算一个字符串的长度 参数： s：指定的字符串 返回值： 当前字符串的长度 注意：strlen获取的字符串长度遇到第一个\\0结束且\\0不算做字符串长度之中 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { //使用strlen函数获取字符串的长度 //strlen","title":"【嵌入式高级C编程】第七章 字符串处理函数"},{"content":"第四章 预处理 一、C语言编译过程 C语言的编译过程：\n预处理、编译、汇编、链接\ngcc -E hello.c -o hello.i 1、预处理\ngcc -S hello.i –o hello.s 2、编译\ngcc -c hello.s -o hello.o 3、汇编\ngcc hello.o -o hello_elf 4、链接\n1：预编译\n将.c 中的头文件展开、宏展开\n生成的文件是.i文件\n2：编译\n将预处理之后的.i 文件生成 .s 汇编文件\n3、汇编\n将.s汇编文件生成.o 目标文件\n4、链接\n将.o 文件链接成目标文件\n二、include #include\u0026lt;\u0026gt; //用尖括号包含头文件，在系统指定的路径下找头文件\n#include \u0026quot;\u0026quot; //用双引号包含头文件，先在当前目录下找头文件，找不到，再到系统指定的路径下找。\n注意：include 经常用来包含头文件，可以包含 .c 文件，但是大家不要包含.c。\n因为include包含的文件会在预编译被展开，如果一个.c 被包含多次，展开多次，会导致函数重复定义。\n所以不要包含.c 文件\n注意：预处理只是对include 等预处理操作进行处理并不会进行语法检查。\n这个阶段有语法错误也不会报错，第二个阶段即编译阶段才进行语法检查。\n三、define 定义宏用define 去定义。\n宏是在预编译的时候进行替换。\n1、不带参宏 #define PI 3.14\n在预编译的时候如果代码中出现了PI 就用 3.14去替换。\n宏的好处：只要修改宏定义，其他地方在预编译的时候就会重新替换。\n注意：宏定义后边不要加分号。\n#include \u0026lt;stdio.h\u0026gt; //宏定义的好处是只要改变了定义是的常量表达式，则代码中只要使用这个宏定义的位置都会改变 #define PI 3.1415926 int main(int argc, char *argv[]) { printf(\u0026#34;PI = %lf\\n\u0026#34;, PI); double d = PI; printf(\u0026#34;d = %lf\\n\u0026#34;, d); return 0; } 执行结果\nPI = 3.141593 d = 3.141593 宏定义的作用范围，从定义的地方到本文件末尾。\n如果想在中间终止宏的定义范围\n#undef PI //终止PI的作用\n2、带参宏 #define S(a,b) a*b\n注意带参宏的形参 a和b没有类型名，\nS(2,4) 将来在预处理的时候替换成 实参替代字符串的形参，其他字符保留，2 * 4\n#include \u0026lt;stdio.h\u0026gt; //带参宏 //带参宏类似于一个简单的函数，将函数的参数进行设置，就可以传递给对应的表达式 //#define S(a, b) a*b #define S(a, b) ((a)*(b)) int main(int argc, char *argv[]) { printf(\u0026#34;%d\\n\u0026#34;, S(2, 4)); //注意：宏定义只是简单的替换，不会自动加括号 //带参宏1：2 + 8 * 4 = 34 //带参宏2：((2 + 8) * (4)) = 40 printf(\u0026#34;%d\\n\u0026#34;, S(2 + 8, 4)); return 0; } 3、带参宏和带参函数的区别 - 带参宏被调用多少次就会展开多少次，执行代码的时候没有函数调用的过程，不需要压栈弹栈。所以带参宏，是浪费了空间，因为被展开多次，节省时间。 - 带参函数，代码只有一份，存在代码段，调用的时候去代码段取指令，调用的时候要压栈弹栈。有个调用的过程。所以说，带参函数是浪费了时间，节省了空间。 - 带参函数的形参是有类型的，带参宏的形参没有类型名。 - 如果功能实现的代码相对简单，并且不需要开辟太多的空间，可以选择使用带参宏，但是大多数情况都会使用函数。 四、选择性编译 1、\n#ifdef AAA 代码段一 #else 代码段二 #endif 如果在当前.c ifdef 上边定义过AAA ，就编译代码段一，否则编译代码段二。\n注意和if else语句的区别，if else 语句都会被编译，通过条件选择性执行代码。\n而 选择性编译，只有一块代码被编译。\n#define AAA int main(int argc, char *argv[]) { #ifdef AAA printf(\u0026#34;hello kitty!!\\n\u0026#34;); #else printf(\u0026#34;hello 千锋edu\\n\u0026#34;); #endif return 0; } 2、\n#ifndef AAA 代码段一 #else 代码段二 #endif 和第一种互补。\n这种方法，经常用在防止头文件重复包含。\n常用于多文件编程中.h的第一行就是#ifndef，最后一行就是#endif\n3、\n#if 表达式 程序段一 #else 程序段二 #endif 如果表达式为真，编译第一段代码，否则编译第二段代码。\n这种形式一般用于注释多行代码。\n#if 0 ... #endif 选择性编译都是在预编译阶段干的事情。\n彩蛋🎁\n秋天的阳光醇厚，在建筑物顶端闪闪发光。河流，树林，软绵绵的草地，云絮从上面缓缓飘移。\n村上春树《有餐车多好》 恭喜你🎉，完成了对第四章《预处理》部分的学习，下一章我们将学习指针。\n⏩第五章 《指针》\n","permalink":"https://eddyblog.cn/posts/tech/embedded_high-level_c_programming_04preprocessing/","summary":"第四章 预处理 一、C语言编译过程 C语言的编译过程： 预处理、编译、汇编、链接 gcc -E hello.c -o hello.i 1、预处理 gcc -S hello.i –o hello.s 2、编译 gcc -c hello.s -o hello.o 3、汇编 gcc hello.o -o hello_elf 4、链接 1：预编译 将.c 中的头文件展开、宏展开 生成的文件是.i文件 2：编译 将预处理之后的.i 文件生成 .s 汇编文件 3、汇编 将.s汇编文件生成.o 目","title":"【嵌入式高级C编程】第四章 预处理"},{"content":"第五章 指针 一、关于内存那点事 存储器：存储数据器件\n外存\n外存又叫外部存储器，长期存放数据，掉电不丢失数据\n常见的外存设备：硬盘、flash、rom、u盘、光盘、磁带\n内存\n内存又叫内部存储器，暂时存放数据，掉电数据丢失\n常见的内存设备：ram、DDR\n物理内存：实实在在存在的存储设备\n虚拟内存：操作系统虚拟出来的内存，当一个进程被创建的时候，或者程序运行的时候都会\n分配虚拟内存，虚拟内存和物理内存之间存在映射关系。\n操作系统会在物理内存和虚拟内存之间做映射。\n在32位系统下，每个进程（运行着的程序）的寻址范围是4G,0x00 00 00 00 ~0xff ff ff ff\n在写应用程序的，咱们看到的都是虚拟地址。\n在运行程序的时候，操作系统会将 虚拟内存进行分区。\n1.堆\n在动态申请内存的时候，在堆里开辟内存。\n2.栈\n主要存放局部变量（在函数内部，或复合语句内部定义的变量）。\n3.静态全局区\n1）：未初始化的静态全局区\n静态变量（定义的时候，前面加static修饰），或全局变量 ，没有初始化的，存在此区\n2）：初始化的静态全局区\n全局变量、静态变量，赋过初值的，存放在此区\n4.代码区\n存放咱们的程序代码\n5.文字常量区\n存放常量的。\n内存以字节为单位来存储数据的，咱们可以将程序中的虚拟寻址空间，看成一个很大的一维的字符数组\n本章所接触的内容，涉及到的内存都是虚拟内存，更准确来说是虚拟内存的用户空间\n二、指针的相关概念 操作系统给每个存储单元分配了一个编号，从0x00 00 00 00 ~0xff ff ff ff\n这个编号咱们称之为地址。\n指针就是地址。\n指针变量：是个变量，是个指针变量，即这个变量用来存放一个地址编号\n在32位平台下，地址总线是32位的，所以地址是32位编号，所以指针变量是32位的即4个字节。\n注意：\n1：无论什么类型的地址，都是存储单元的编号，在32位平台下都是4个字节，即任何类型的指针变量都是4个字节大小\n2：对应类型的指针变量，只能存放对应类型的变量的地址\n举例：整型的指针变量，只能存放整型变量的地址\n扩展：\n字符变量 char ch; ch占1个字节，它有一个地址编号，这个地址编号就是ch的地址\n整型变量 int a; a占4个字节，它占有4个字节的存储单元，有4个地址编号。\nInt a=0x00 00 23 4f\n三、指针的定义方法 1.简单的指针\n数据类型 * 指针变量名;\nint * p; //定义了一个指针变量p\n在 定义指针变量的时候 * 是用来修饰变量的，说明变量p是个指针变量。\n变量名是 p\n2.关于指针的运算符\n\u0026amp; 取地址 、 *取值\n\u0026amp;：获取一个变量的地址\n*：在定义一个指针变量时，起到标识作用，标识定义的是一个指针变量\n除此之外其他地方都表示获取一个指针变量保存的地址里面的内容\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { //定义一个普通变量 int a = 100; //定义一个指针变量 int *p; //给指针变量赋值 //将a的地址保存在p中 p = \u0026amp;a; printf(\u0026#34;a = %d %d\\n\u0026#34;, a, *p); printf(\u0026#34;\u0026amp;a = %p %p\\n\u0026#34;, \u0026amp;a, p); return 0; } 执行结果\na = 100 100 \u0026amp;a = 0029FEA8 0029FEA8 扩展：如果在一行中定义多个指针变量，每个指针变量前面都需要加*来修饰\nint *p,*q; //定义了两个整型的指针变量p和q\nint * p,q; //定义了一个整型指针变量p，和整型的变量q\n3、指针大小\n在32位系统下，所有类型的指针都是4个字节。\n因为不管地址内的空间多大，但是地址编号的长度是一样的，所以在32位操作系统中，地址都是四个字节。\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { char *a; short *b; int *c; long *d; float *e; double *f; printf(\u0026#34;sizeof(a) = %d\\n\u0026#34;, sizeof(a)); printf(\u0026#34;sizeof(b) = %d\\n\u0026#34;, sizeof(b)); printf(\u0026#34;sizeof(c) = %d\\n\u0026#34;, sizeof(c)); printf(\u0026#34;sizeof(d) = %d\\n\u0026#34;, sizeof(d)); printf(\u0026#34;sizeof(e) = %d\\n\u0026#34;, sizeof(e)); printf(\u0026#34;sizeof(f) = %d\\n\u0026#34;, sizeof(f)); return 0; } 执行结果\nsizeof(a) = 4 sizeof(b) = 4 sizeof(c) = 4 sizeof(d) = 4 sizeof(e) = 4 sizeof(f) = 4 四、指针的分类 按指针指向的数据的类型来分。\n1:字符指针\n字符型数据的地址\nchar *p; //定义了一个字符指针变量，只能存放字符型数据的地址编号\nchar ch;\np= \u0026amp;ch;\n2：短整型指针\nshort int *p; //定义了一个短整型的指针变量p，只能存放短整型变量的地址\nshort int a;\np =\u0026amp;a;\n3：整型指针\nint *p; //定义了一个整型的指针变量p，只能存放整型变量的地址\nint a;\np =\u0026amp;a;\n注：多字节变量，占多个存储单元，每个存储单元都有地址编号，\nc语言规定，存储单元编号最小的那个编号，是多字节变量的地址编号。\n4：长整型指针\nlong int *p; //定义了一个长整型的指针变量p，只能存放长整型变量的地址\nlong int a;\np =\u0026amp;a;\n5：float 型的指针\nfloat *p; //定义了一个float型的指针变量p，只能存放float型变量的地址\nfloat a;\np =\u0026amp;a;\n6：double型的指针\ndouble *p; //定义了一个double型的指针变量p，只能存放double型变量的地址\ndouble a;\np =\u0026amp;a;\n7：函数指针\n8、结构体指针\n9、指针的指针\n10、数组指针\n总结:无论什么类型的指针变量，在32位系统下，都是4个字节，只能存放对应类型的变量的地址编号。\n五、指针和变量的关系 指针可以存放变量的地址编号\n在程序中，引用变量的方法\n1:直接通过变量的名称\nint a;\na = 100;\n2:可以通过指针变量来引用变量\nint * p; //在定义的时候，*不是取值的意思，而是修饰的意思，修饰p是个指针变量\np = \u0026amp;a; //取a的地址给p赋值，p保存了a的地址，也可以说p指向了a\n*p = 100; //在调用的时候*是取值的意思，*指针变量 等价于指针指向的变量\n注：指针变量在定义的时候可以初始化\nint a;\nint * p = \u0026amp;a; //用a的地址，给p赋值，因为p是指针变量\n指针就是用来存放变量的地址的。\n*+指针变量 就相当于指针指向的变量\n指针变量只能保存开辟好空间的地址，不能随意保存地址\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { int *p1,*p2,temp,a,b; p1=\u0026amp;a; p2=\u0026amp;b; printf(\u0026#34;请输入:a b的值:\\n\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, p1, p2); //给p1和p2指向的变量赋值 temp = *p1; //用p1指向的变量（a）给temp赋值 *p1 = *p2; //用p2指向的变量（b）给p1指向的变量（a）赋值 *p2 = temp; //temp给p2指向的变量（b）赋值 printf(\u0026#34;a=%d b=%d\\n\u0026#34;,a,b); printf(\u0026#34;*p1=%d *p2=%d\\n\u0026#34;,*p1,*p2); return 0; } 执行结果\n请输入:a b的值: 70 90 a=90 b=70 *p1=90 *p2=70 扩展：\n对应类型的指针，只能保存对应类型数据的地址，\n如果想让不同类型的指针相互赋值的时候，需要强制类型转换。\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { int a=0x1234,b=0x5678; char *p1,*p2; printf(\u0026#34;%#x %#x\\n\u0026#34;,a,b); p1=(char *)\u0026amp;a; p2=(char *)\u0026amp;b; printf(\u0026#34;%#x %#x\\n\u0026#34;,*p1,*p2); p1++; p2++; printf(\u0026#34;%#x %#x\\n\u0026#34;,*p1,*p2); return 0; } 彩蛋🎁\n如果你来访我，我不在，请和我门外的花坐一会儿，它们很温暖，我注视它们很多日子了。\n汪曾祺《人间草木》 恭喜你🎉，完成了对第五章《指针》部分的学习，下一章我们将学习动态内存申请。\n⏩第六章 《动态内存申请》\n","permalink":"https://eddyblog.cn/posts/tech/embedded_high-level_c_programming_05pointer/","summary":"第五章 指针 一、关于内存那点事 存储器：存储数据器件 外存 外存又叫外部存储器，长期存放数据，掉电不丢失数据 常见的外存设备：硬盘、flash、rom、u盘、光盘、磁带 内存 内存又叫内部存储器，暂时存放数据，掉电数据丢失 常见的内存设备：ram、DDR 物理内存：实实在在存在的存储设备 虚拟内存：","title":"【嵌入式高级C编程】第五章 指针"},{"content":" 本文总结摘录源自博主《熊的思考与行动》，仅作学习记录用途\n学习时：联系已知 深入感悟：读书与生活笔记的正确姿势 做真正有用的读书笔记\n你可能在做无用笔记，3个底层逻辑搞定读书。\n真正有用的读书笔记，具备一个特点：让自己重新会看。\n那么如何才能让自己有“回看”的动力呢？\n我总结了这三个底层逻辑：\n讨论特定问题\n记录阶段思考\n结合特定事件\n你是怎样做读书笔记的呢？\n复制粘贴原文书本折角，各种划线各种颜色加粗随手写笔记，你是这么做的吗？\n做的时候收获感满满，长久下来，却很少能感到实际作用。\n如果从功利角度出发，我们应该如何读书，才能收获多一点点呢？（当然，我不反对“读书只求感受”）\n有用的读书笔记应该怎么做？\n三个理想效果\n讨论特定问题：由浅入深：how，what，why\n记录阶段思考：认知行为：事件，认知，心态\n结合特定事件：世界与我：从大事到身边事\n核心1：用特定问题理解书中内容\n至于问题本身的质量，就是个人认知的体现。\n核心2：记录阶段思考\n不同阶段 不同感受 并无好坏 只是不同\n认知心理学有个著名理论 ：CBT （认知行为模式）\n大义是：认知决定行为，行为强化认知\n对于不同事情的不同认知，就是读书笔记需要记录的内容。\n核心3：结合特定事件\n“人只活几个瞬间。”读书笔记同理，结合特定事情才能铭刻记录。\n可是我们应该如何记录关键瞬间呢？【黄金圈模型】- 怎么样，是什么，为什么\n","permalink":"https://eddyblog.cn/posts/read/make_truly_useful_reading_notes/","summary":"本文总结摘录源自博主《熊的思考与行动》，仅作学习记录用途 学习时：联系已知 深入感悟：读书与生活笔记的正确姿势 做真正有用的读书笔记 你可能在做无用笔记，3个底层逻辑搞定读书。 真正有用的读书笔记，具备一个特点：让自己重新会看。 那么如何才能让自己有“回看”的动力呢？ 我总结了这三个底层逻辑：","title":"【(学习)系列笔记】-做真正有用的读书笔记"},{"content":"第二章 数组 一、数组的概念 数组是若干个相同类型的变量在内存中有序存储的集合。\n概念理解：\n数组用于存储一组数据\n数组里面存储的数据类型必须是相同的\n数组在内存中会开辟一块连续的空间\nint a[10];\n//定义了一个整型的数组a，a是数组的名字，数组中有10个元素，每个元素的类型都是int类型，而且在内存中连续存储。\n这十个元素分别是a[0] a[1] …. a[9]。\na[0]~a[9]在内存中连续的顺序存储。\n二、数组的分类 2.1 按元素的类型分类 1）字符数组\n即若干个字符变量的集合，数组中的每个元素都是字符型的变量\nchar s[10]; s[0],s[1]....s[9];\n2）短整型的数组\nshort int a[10]; a[0] ,a[9]; a[0]=4;a[9]=8;\n3）整型的数组\nint a[10]; a[0] a[9]; a[0]=3;a[0]=6;\n4） 长整型的数组\nlont int a[5];\n5）浮点型的数组（单、双）\nfloat a[6]; a[4]=3.14f;\ndouble a[8]; a[7]=3.115926;\n6）指针数组\nchar *a[10];\nint *a[10];\n7）结构体数组\nstruct stu boy[10];\n2.2 按维数分类 一维数组\nint a[30];\n类似于一排平房\n二维数组\nint a[2][30];\n可以看成一栋楼房 有多层，每层有多个房间，也类似于数学中的矩阵\n二维数组可以看成由多个一维数组构成的。\n有行，有列，\n多维数组\nint a[4][2][10];\n三维数组是由多个相同的二维数组构成的\nint a[5][4][2][10];\n三、数组的定义 3.1 一维数组的定义 格式：\n数据类型 数组名[数组元素个数];\n例如：\nint a[10];\n//定义了一个名为a的数组，数组中每一个元素都是int类型，一共有10个元素\n//每一个元素都保存在一个变量中，每一个变量都是有数组名和数组下标组成的\n//并且是从0开始的，分别是a[0] a[1] a[2]... a[9]\n注意：数组元素的个数在定义的时候也可以不写，但是如果不写，必须初始化（定义的时候赋值）\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { //定义一个一维数组 int a[10]; //通过sizeof关键字可以获取数组的大小 printf(\u0026#34;sizeof(a) = %d %d\\n\u0026#34;, sizeof(a), 10 * sizeof(int)); //如果定义数组的同时赋值（初始化），可以不指定数组元素的个数，系统会根据初始化元素的个数自动指定数组元素的个数 int b[] = {10, 20, 30}; printf(\u0026#34;sizeof(b) = %d\\n\u0026#34;, sizeof(b)); return 0; } 执行结果\nsizeof(a) = 40 40 sizeof(b) = 12 3.2 二维数组的定义 格式:\n数据类型 数组名[行的个数][列的个数];\n例如：\nint a[2][4];\n解释：\n定义一个名为a的二维数组，每一个元素都是int类型\n这个二维数组中包含两行四列的元素，一共有8个元素\n二维数组也是连续开辟空间，访问元素是行和列都是从0开始，分别是a[0][0] a[0][1] a[0][2] a[0][3] a[1][0] a[1][1] a[1][2] a[1][3]\n注意：二维数组的下标也是可以省略的，但是有条件，在初始化时行数可以省略，但是列数不能省略\n//定义一个二维数组 int c[2][4]; printf(\u0026#34;sizeof(c) = %d %d\\n\u0026#34;, sizeof(c), 2 * 4 * sizeof(int)); //二维数组的行数可以省略，但是列数不能省略，在初始化时可以这样操作 //系统会根据列数自动指定行数，最终得到的函数所得到得元素个数移动是列的整数倍 int d[][4] = {1, 2, 3, 4, 5}; printf(\u0026#34;sizeof(d) = %d\\n\u0026#34;, sizeof(d)); 执行结果\nsizeof(c) = 32 32 sizeof(d) = 32 为什么sizeof(d) = 32？\n假设 sizeof(int) 在您的系统上是4字节，通常情况下，int 类型需要按4字节对齐。因此，编译器会在数组 d 的每一行之后添加填充以确保每一行都满足对齐要求。\n所以，虽然数组中的实际数据只占用20字节（5个 int 值 * 4字节），但由于填充字节，sizeof(d) 返回32字节。\n这种情况下的内存布局可能如下所示：\n[1][2][3][4][5][0][0][0] 这些额外的0值字节是为了满足内存对齐要求而添加的，因此导致 sizeof(d) 返回32字节。不同的编译器和系统可能会有不同的对齐规则，因此结果可能会有所不同。\n四、定义并初始化 4.1 一维数组的初始化 #include\u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { //以一维数组的初始化 //如果不初始化，直接使用会是随机值 //int a[4]; //初始化方式1：全部初始化 //int a[4] = {123, 78, 666, 476}; //如果是全部 初始化，可以不指定数组元素的个数，系统会自动分配 //int a[] = {10, 20, 30, 40}; //初始化方式2：局部初始化 //未初始化的位置的元素自动赋值为0 int a[4] = {10, 20}; printf(\u0026#34;%d\\n\u0026#34;,a[0]); printf(\u0026#34;%d\\n\u0026#34;,a[1]); printf(\u0026#34;%d\\n\u0026#34;,a[2]); printf(\u0026#34;%d\\n\u0026#34;,a[3]); return 0; } 4.2 二维数组的初始化 按行初始化：\na、全部初始化\nint a[2][2]={{1,2},{4,5}};\na[0][0] =1; a[0][1] = 2; a[1][0] = 4,a[1][1]=5;\nb、部分初始化\nint a[3][3]={{1,2},{1}};\na[0][0] = 1;a[0][2] =0;\n逐个初始化：\n全部初始化：\nint a [2][3]={2,5,4,2,3,4};\n部分初始化：\nint a[2][3]={3,5,6,8};\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { //二维数组的初始化 //int a[2][3]; //初始化方式1：按行初始化 //全部初始化 //int a[2][3] = {{10, 20, 30}, {666, 777, 888}}; //局部初始化 //没有赋值的位置的元素自动为0 //int a[2][3] = {{10, 20}, {666}}; //初始化方式2：逐个初始化 //全部初始化 //int a[2][3] = {1, 2, 3, 4, 5, 6}; //局部初始化 //没有赋值的位置的元素自动为0 int a[2][3] = {1, 2, 3}; printf(\u0026#34;%d\\n\u0026#34;, a[0][0]); printf(\u0026#34;%d\\n\u0026#34;, a[0][1]); printf(\u0026#34;%d\\n\u0026#34;, a[0][2]); printf(\u0026#34;%d\\n\u0026#34;, a[1][0]); printf(\u0026#34;%d\\n\u0026#34;, a[1][1]); printf(\u0026#34;%d\\n\u0026#34;, a[1][2]); return 0; } 五、数组元素的引用方法 一维数组元素的引用方法\n数组名[下标]；//下标代表数组元素在数组中的位置，注意从0开始\nint a[10];\n二维数组元素的引用方法\n数组名[行下标][列下标];\nint a[3][4];\n#include\u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { //一维数组的引用以及一维数组的遍历 int a[6] = {111, 222, 333, 444, 555, 666}; a[3] = 10000; //一维数组的遍历 int i; for(i = 0; i \u0026lt; sizeof(a) / sizeof(int); i++) { printf(\u0026#34;a[%d] = %d\\n\u0026#34;, i, a[i]); } printf(\u0026#34;**********************\\n\u0026#34;); //二维数组的引用以及二维数组的遍历 int b[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; b[2][0] = 666; //二维数组的遍历 int m, n; //外层循环控制行数 for(m = 0; m \u0026lt; 3; m++) { //内层循环控制列数 for(n = 0; n \u0026lt; 4; n++) { printf(\u0026#34;%-4d\u0026#34;, b[m][n]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 执行结果\na[0] = 111 a[1] = 222 a[2] = 333 a[3] = 10000 a[4] = 555 a[5] = 666 ********************** 1 2 3 4 5 6 7 8 666 10 11 12 六、字符数组的定义和初始化问题 char c1[] ={'c','p','r','o','g'};\nchar c2[] = \u0026quot;c prog\u0026quot;;\nchar a[][5] = {\n{'B', 'A', 'S', 'I', 'C'},\n{'d', 'B', 'A', 'S', 'E'}\n};\nchar a[][6] = {\u0026quot;hello\u0026quot;,\u0026quot;world\u0026quot;};\n字符数组的引用\n1.用字符串方式赋值比用字符逐个赋值要多占1个字节,用于存放字符串结束标志‘\\0’;\n2.上面的数组c2在内存中的实际存放情况为：\n注：\u0026rsquo;\\0\u0026rsquo;是由C编译系统自动加上的3.由于采用了\u0026rsquo;\\0\u0026rsquo;标志，字符数组的输入输出将变得简单方便.\n3.由于采用了\u0026rsquo;\\0\u0026rsquo;标志，字符数组的输入输出将变得简单方便.\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { //定义一个字符数组，通过scanf函数输入字符串并输出结果 //通过赋值\u0026#34;\u0026#34;这样的方式可以清除字符数组中的垃圾字符，让每一个元素都是\\0 char ch[32] = \u0026#34;\u0026#34;; //数组名就是当前数组的首地址，所以scanf的第二个参数直接传数组名即可 scanf(\u0026#34;%s\u0026#34;, ch); printf(\u0026#34;ch = %s\\n\u0026#34;, ch); return 0; } 执行结果\nnihao ch = nihao 彩蛋🎁\n秋日薄暮，用菊花煮竹叶青，人与海棠俱醉。\n林清玄《温一壶月光下酒》 恭喜你🎉，完成了对第二章《数组》部分的学习，下一章我们将学习函数。\n⏩第三章 《函数》\n","permalink":"https://eddyblog.cn/posts/tech/embedded_high-level_c_programming_02array/","summary":"第二章 数组 一、数组的概念 数组是若干个相同类型的变量在内存中有序存储的集合。 概念理解： 数组用于存储一组数据 数组里面存储的数据类型必须是相同的 数组在内存中会开辟一块连续的空间 int a[10]; //定义了一个整型的数组a，a是数组的名字，数组中有10个元素，每个元素的类型都是int类型，而且在内存中","title":"【嵌入式高级C编程】第二章 数组"},{"content":"第三章 函数 一、函数的概念 函数是c语言的功能单位，实现一个功能可以封装一个函数来实现。\n定义函数的时候一切以功能为目的，根据功能去定函数的参数和返回值。\n函数就是讲特定功能的代码封装在一个函数内部，当要使用这些代码时，只需要通过函数名就可以使用，这样操作起来更加方便。\n二、函数的分类 1、从定义角度分类（即函数是谁实现的）\n1.库函数 (c库实现的)\n2.自定义函数 （程序员自己实现的函数）\n3.系统调用 (操作系统实现的函数)\n2、从参数角度分类\n1.有参函数\n函数有形参，可以是一个，或者多个，参数的类型随便完全取决于函数的功能\nint fun(int a,float b,double c) { } int max(int x,int y) { } 2.无参函数\n函数没有参数,在形参列表的位置写个void或什么都不写\nint fun(void) { } int fun() { } 3、从返回值角度分类\n(1).带返回值的函数\n在定义函数的时候，必须带着返回值类型，在函数体里，必须有return\n如果没有返回值类型，默认返回整型。\n例1：\nchar fun()//定义了一个返回字符数据的函数 { char b=\u0026#39;a\u0026#39;; return b; } 例2：\nfun() { return 1; } 如果把函数的返回值类型省略了，默认返回整型\n注：在定义函数的时候，函数的返回值类型，到底是什么类型的，取决于函数的功能。\n(2).没返回值的函数\n在定义函数的时候，函数名字前面加void\nvoid fun(形参表) { ; ; return ; ; } 在函数里不需要return\n如果想结束函数，返回到被调用的地方， return ;什么都不返回就可以了\n#include \u0026lt;stdio.h\u0026gt; int max(int x,int y) { int z; if(x\u0026gt;y) z=x; else z=y; return z; } void help(void) { printf(\u0026#34;*********************\\n\u0026#34;); printf(\u0026#34;********帮助信息*****\\n\u0026#34;); printf(\u0026#34;*********************\\n\u0026#34;); } int main(int argc, char *argv[]) { int num; help(); num = max(10,10+5); printf(\u0026#34;num=%d\\n\u0026#34;,num); return 0; } 三、函数的定义\n1、函数的定义方法\n返回值类型 函数名字(形参列表)\n{\n//函数体，函数的功能在函数体里实现\n}\n注意：\n函数名字是标识符，所以需要满足标识符的命名规则\n形参：可以有，也可以没有，也可以有多个，但是即使没有，函数名字后面也必须加括号\n函数体上下位置必须有大括号\n如果要返回函数执行的结果，也就是返回值，则return后面跟的变量或者值，必须与函数名左边的返回值类型一致\n形参必须带类型，而且以逗号分隔\n函数的定义不能嵌套，即不能在一个函数体内定义另外一个函数，所有的函数的定义是平行的。\n在一个程序中，相同的函数名只能出现一次。\n//定义一个没有参数也没有返回值的函数 void myfun1() { printf(\u0026#34;hello world\\n\u0026#34;); printf(\u0026#34;nihao beijing\\n\u0026#34;); printf(\u0026#34;welcome to 1000phone\\n\u0026#34;); return ; } //定义一个有参数的函数 void myfun2(int a, int b) { int sum; sum = a + b; printf(\u0026#34;%d + %d = %d\\n\u0026#34;, a, b, sum); } //定义一个有返回值的函数 int myfun3(int a, int b) { int sum; sum = a + b; return sum; } 四、函数的声明 1、概念\n对已经定义的函数，进行说明\n函数的声明可以声明多次。\n2、为什么要声明\n有些情况下，如果不对函数进行声明，编译器在编译的时候，可能不认识这个函数，因为编译器在编译c程序的时候，从上往下编译的。\n3、声明的方法\n什么时候需要声明\n1）主调函数和被调函数在同一个.c文件中的时候\n1] 被调函数在上，主调函数在下\nvoid fun(void) { printf(\u0026#34;hello world\\n\u0026#34;); } int main() { fun(); } 这种情况下不需要声明\n2] 被调函数在下，主调函数在上\nint main() { fun(); } void fun(void) { printf(\u0026#34;hello world\\n\u0026#34;); } 编译器从上往下编译，在main函数（主调函数），不认识fun，需要声明\n怎么声明 呢？\n1] 直接声明法（常用）\n将被调用的函数的第一行拷贝过去，后面加分号\n#include \u0026lt;stdio.h\u0026gt; //函数的声明：一般当子函数在主函数的下方时，需要在主函数的上方进行声明 void myfun1(); void myfun2(int a, int b); int myfun3(int a, int b); int main(int argc, char *argv[]) { myfun1(); return 0; } void myfun1() { printf(\u0026#34;hello world\\n\u0026#34;); printf(\u0026#34;nihao beijing\\n\u0026#34;); printf(\u0026#34;welcome to 1000phone\\n\u0026#34;); return ; } void myfun2(int a, int b) { int sum; sum = a + b; printf(\u0026#34;%d + %d = %d\\n\u0026#34;, a, b, sum); } int myfun3(int a, int b) { int sum; sum = a + b; return sum; } 2] 间接声明法\n将函数的声明放在头文件中，.c程序包含头文件即可\na.c #include”a.h” int main() { fun(); } void fun(void) { printf(\u0026#34;hello world\\n\u0026#34;); } a.h extern void fun(void); 2）主调函数和被调函数不在同一个.c文件中的时候\n一定要声明\n声明的方法：\n直接声明法\n将被调用的函数的第一行拷贝过去，后面加分号，前面加extern\n间接声明法（常用）\n将函数的声明放在头文件中，.c程序包含头文件即可\nmyfun.c #include \u0026#34;myfun.h\u0026#34; //此时包含的头文件要使用双引号，在当前目录下去找对应头文件 void myfun1() { printf(\u0026#34;hello world\\n\u0026#34;); printf(\u0026#34;nihao beijing\\n\u0026#34;); printf(\u0026#34;welcome to 1000phone\\n\u0026#34;); return ; } myfun.h #ifndef MYFUN_H #define MYFUN_H //函数的声明 void myfun1(); #endif // MYFUN_H main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;myfun.h\u0026#34; int main(int argc, char *argv[]) { myfun1(); return 0; } 五、函数的调用 函数的调用方法\n变量= 函数名(实参列表); //带返回值的\n函数名(实参列表); //不带返回值的\n#include \u0026lt;stdio.h\u0026gt; void myfun1(); void myfun2(int a, int b); int myfun3(int a, int b); int main(int argc, char *argv[]) { //函数的调用 //没有参数也没有返回值 //直接写函数名，并且要在后面加括号 myfun1(); printf(\u0026#34;**********************\\n\u0026#34;); //有参数，没有返回值 //需要在函数名右边括号中传入参数，参数可以是常量表达式，也可以是变量表达式 myfun2(100, 90); int x = 10, y = 20; //x、y：实参，实际参数，本质就是在函数调用的时候将实参的值传递给形参 myfun2(x, y); printf(\u0026#34;**********************\\n\u0026#34;); //有参数也有返回值 //可以使用一个变量接收函数执行结果（返回值），或者直接输出也可以 int n; n = myfun3(100, 90); printf(\u0026#34;n = %d\\n\u0026#34;, n); printf(\u0026#34;sum = %d\\n\u0026#34;, myfun3(90, 66)); return 0; } void myfun1() { printf(\u0026#34;hello world\\n\u0026#34;); printf(\u0026#34;nihao beijing\\n\u0026#34;); printf(\u0026#34;welcome to 1000phone\\n\u0026#34;); return ; } //a、b：形参，形式参数，主要用于保存实参传递的值，本质跟实参没有任何关系，只是值传递 void myfun2(int a, int b) { int sum; sum = a + b; printf(\u0026#34;%d + %d = %d\\n\u0026#34;, a, b, sum); } int myfun3(int a, int b) { int sum; sum = a + b; return sum; } 执行结果\nhello world nihao beijing welcome to 1000phone ********************** 100 + 90 = 190 10 + 20 = 30 ********************** n = 190 sum = 156 六、函数总结 定义函数的时候，关于函数的参数和返回值是什么情况，完全取决于函数的功能。\n当编写函数的时候，一开始不要想着函数如何传参和函数的返回值应该是什么\n而是当在编写代码的途中，要使用某些值，但是当前函数中不存在，此时就需要进行传参，这时候考虑怎么传参就是合适的时机\n当函数编写完毕后，考虑是否要将某些结果返回给其他函数去使用，此时需要考虑返回值\n使用函数的好处？\n1、定义一次，可以多次调用，减少代码的冗余度。\n2、使咱们代码，模块化更好，方便调试程序，而且阅读方便\n七、变量的存储类别 7.1 内存的分区 1、内存：物理内存、虚拟内存\n物理内存：实实在在存在的存储设备\n虚拟内存：操作系统虚拟出来的内存\n操作系统会在物理内存和虚拟内存之间做映射。\n在32位系统下，每个进程的寻址范围是4G,0x00 00 00 00 ~0xff ff ff ff\n在写应用程序的，咱们看到的都是虚拟地址。\n在32位操作系统中，虚拟内存被分为两个部分，3G的用户空间和1G内核空间，其中用户空间是当前进程所私有的，内核空间，是一个系统中所有的进程所公有的。\n2、在运行程序的时候，操作系统会将 虚拟内存进行分区\n1).堆\n在动态申请内存的时候，在堆里开辟内存。\n2).栈\n主要存放局部变量。\n3).静态全局区\n1：未初始化的静态全局区\n静态变量（定义变量的时候，前面加static修饰），或全局变量 ，没有初始化的，存在此区\n2：初始化的静态全局区\n全局变量、静态变量，赋过初值的，存放在此区\n4).代码区\n存放咱们的程序代码。\n5).文字常量区\n存放常量的。\n7.2 普通的全局变量 概念：\n在函数外部定义的变量\nint num = 100; //num就是一个全局变量 int main() { return 0; } 作用范围：\n全局变量的作用范围，是程序的所有地方。\n只不过用之前需要声明。声明方法 extern int num;\n注意声明的时候，不要赋值。\n生命周期：\n程序运行的整个过程，一直存在，直到程序结束。\n注意：定义普通的全局变量的时候，如果不赋初值，它的值默认为0\n#include \u0026lt;stdio.h\u0026gt; //定义一个普通全局变量 //只要是在main函数外（也在子函数外）的变量，就是全局变量 //如果全局变量没有进行初始化，则系统自动将其初始化为0 int num; //全局变量可以在程序的任意一个位置进行对其的操作 void myfun() { num = 888; } int main(int argc, char *argv[]) { printf(\u0026#34;num = %d\\n\u0026#34;, num); myfun(); printf(\u0026#34;num = %d\\n\u0026#34;, num); return 0; } 执行结果\nnum = 0 num = 888 7.3 静态全局变量 概念：\n定义全局变量的时候，前面用static 修饰。\nstatic int num=100; //num就是一个静态全局变量 int main() { return 0; } 作用范围：\nstatic 限定了静态全局变量的作用范围\n只能在它定义的.c（源文件）中有效\n生命周期：\n在程序的整个运行过程中，一直存在。\n注意：定义静态全局变量的时候，如果不赋初值，它的值默认为0\n#include \u0026lt;stdio.h\u0026gt; //定义一个静态全局变量 //静态全局变量只能在其定义的.c文件中任意位置使用，不能跨文件使用 static int num; void myfun() { num++; } int main(int argc, char *argv[]) { printf(\u0026#34;num = %d\\n\u0026#34;, num); myfun(); printf(\u0026#34;num = %d\\n\u0026#34;, num); return 0; } 执行结果\nnum = 0 num = 1 7.4 普通的局部变量 概念：\n在函数内部定义的，或者复合语句中定义的变量\nint main() { int num; //局部变量 { int a; //局部变量 } } 作用范围：\n在函数中定义的变量，在函数中有效。\n在复合语句中定义的，在复合语句中有效。\n生命周期：\n在函数调用之前，局部变量不占用空间，调用函数的时候，才为局部变量开辟空间，函数结束了，局部变量就释放了。\n在复合语句中定义的亦如此\n#include \u0026lt;stdio.h\u0026gt; //定义一个局部变量 //在函数内部定义的，不加任何修饰的变量都是局部变量 void myfun() { int num = 100; num++; printf(\u0026#34;num = %d\\n\u0026#34;, num); return ; } int main(int argc, char *argv[]) { //局部变量只能在定义的函数内部使用，声明周期相对较短，函数结束，局部变量就会释放 //printf(\u0026#34;num = %d\\n\u0026#34;, num); myfun(); myfun(); myfun(); return 0; } 执行结果\nnum = 101 num = 101 num = 101 7.5 静态的局部变量 概念：\n定义局部变量的时候，前面加static 修饰\n作用范围：\n在它定义的函数或复合语句中有效。\n生命周期：\n第一次调用函数的时候，开辟空间赋值，函数结束后，不释放，以后再调用函数的时候，就不再为其开辟空间，也不赋初值，用的是以前的那个变量。\n#include \u0026lt;stdio.h\u0026gt; //定义一个静态局部变量 //在函数内部定义的使用static修饰的变量就是静态局部变量 void myfun() { //如果普通局部变量不进行初始化，则默认是随机值 //如果静态局部变量不进行初始化，则默认是0 int a; //普通局部变量 static int num; //静态局部变量 printf(\u0026#34;a = %d\\n\u0026#34;, a); printf(\u0026#34;num = %d\\n\u0026#34;, num); } void myfun1() { //静态局部变量不会随着当前函数执行结束而释放空间，下次使用的函数之前的空间 //静态局部变量只会初始化一次 static int num1 = 100; num1++; printf(\u0026#34;num1 = %d\\n\u0026#34;, num1); } int main(int argc, char *argv[]) { myfun(); myfun1(); myfun1(); myfun1(); return 0; } 执行结果\na = 420043 num = 0 num1 = 101 num1 = 102 num1 = 103 注意：\n1：定义普通局部变量，如果不赋初值，它的值是随机的。\n定义静态局部变量，如果不赋初值，它的值是0\n2：普通全局变量，和静态全局变量如果不赋初值，它的值为0\n7.6 外部函数 咱们定义的普通函数，都是外部函数。\n即函数可以在程序的任何一个文件中调用。\n在分文件编程中，只需要将函数的实现过程写在指定的.c文件中，然后将其声明写在指定的.h文件中，其他文件只要包含了头文件，就可以使用外部函数。\n7.7 内部函数 内部函数也称之为静态函数，就是用static修饰的函数。\n在定义函数的时候，返回值类型前面加static 修饰。这样的函数被称为内部函数。\nstatic 限定了函数的作用范围，在定义的.c中有效。\n内部函数和外部函数的区别：\n外部函数，在所有地方都可以调用，\n内部函数，只能在所定义的.c中的函数调用。\n扩展：\n在同一作用范围内，不允许变量重名。\n作用范围不同的可以重名。\n局部范围内，重名的全局变量不起作用。（就近原则）\nint num = 100; //全局变量 int main() { //如果出现可以重名的情况，使用的时候满足向上就近原则 int num = 999; //局部变量 return 0; } 彩蛋🎁\n秋是第二个春，此时，每一片叶子都是一朵鲜花。\n阿尔贝 · 加缪《秋是第二个春》 恭喜你🎉，完成了对第三章《函数》部分的学习，下一章我们将学习预处理。\n⏩第四章 《预处理》\n","permalink":"https://eddyblog.cn/posts/tech/embedded_high-level_c_programming_03fun/","summary":"第三章 函数 一、函数的概念 函数是c语言的功能单位，实现一个功能可以封装一个函数来实现。 定义函数的时候一切以功能为目的，根据功能去定函数的参数和返回值。 函数就是讲特定功能的代码封装在一个函数内部，当要使用这些代码时，只需要通过函数名就可以使用，这样操作起来更加方便。 二、函数的分类 1、","title":"【嵌入式高级C编程】第三章 函数"},{"content":"常用的注释模板 C语言并没有一个官方的注释规范，但有一些常见的注释风格和最佳实践，可以帮助你编写清晰、易于理解的注释。以下是一些常用的高效注释模板，你可以根据需要进行自定义：\n文件头注释： 在每个源代码文件的顶部，包括以下信息：\n/* * 文件名: example.c * 作者: Your Name * 日期: 2023-09-07 * 描述: 这个文件包含了一个示例程序的源代码。 */ 这个注释用于标识文件的作者、日期和描述文件内容。\n函数注释： 在每个函数的开头，包括以下信息：\n/** * 函数名: add * 描述: 计算两个整数的和 * 参数: * a (int): 第一个整数 * b (int): 第二个整数 * 返回值: * int: 两个整数的和 */ int add(int a, int b) { return a + b; } 这个注释用于解释函数的目的、参数和返回值。\n重要注释： 对于代码中的关键部分或复杂算法，可以使用注释来解释其工作原理。这有助于其他人理解代码的核心逻辑。\n/* * 这是一个重要的算法 * 在这里解释算法的步骤和原理 * 可能还包括算法的时间复杂度等信息 */ TODO注释： 在代码中标记需要完成或修复的任务。\n// TODO: 这里需要添加错误处理代码 BUG注释： 在代码中标记已知的问题或bug。\n// BUG: 这里的逻辑有问题，需要修复 变更历史注释： 记录代码的变更历史，包括作者、日期和变更描述。\n/* * 变更历史: * 2023-09-07, Your Name: * - 添加新功能 * 2023-09-10, Another Developer: * - 修复了一个bug */ 注意事项注释： 提醒其他开发人员注意特殊情况或行为。\n// 注意: 这个函数不处理负数 示例注释： 在示例代码中提供使用示例和说明。\n/* * 示例用法: * int result = add(5, 3); * printf(\u0026#34;结果是 %d\\n\u0026#34;, result); */ 以上是一些常见的注释模板，你可以根据项目和团队的需要进行自定义。无论采用何种注释风格，重要的是要确保注释清晰、有用，并与代码保持同步。注释应该是代码的补充，帮助其他人理解你的代码逻辑和设计意图。\n案例说明 案例 为以下代码段添加注释 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello world\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 解决方案 在源代码文件的顶部添加了文件基本信息 /******************************************************************************** * @File name: Helloworld.cpp * @Author: EddyCliff * @Version: 1.1 * @Date: 2023-09-09 * @Description: This is a simple \u0026#34;Hello World\u0026#34; program in C++. * It demonstrates the basic structure of a C++ program. ********************************************************************************/ #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello world\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 管理代码版本号 管理版本号的方式通常根据项目的规模和需求而异。在小型项目中，可以根据需要灵活更新版本号，而在大型项目或团队中，可能需要更严格的版本管理策略。以下是一些常见的版本管理方法：\n语义版本号（Semantic Versioning）： 语义版本号是一种常用的版本管理约定，通常包括三个部分：主版本号、次版本号和修订版本号（例如，1.2.3）。根据语义版本号规则，版本号的更新应该遵循以下约定：\n主版本号：当进行不兼容的 API 变更时，增加主版本号。\n次版本号：当添加向后兼容的功能时，增加次版本号。\n修订版本号：当进行向后兼容的 bug 修复时，增加修订版本号。\n这种方法有助于用户了解每个版本的重要性和影响。\n按日期管理版本： 有些项目使用日期作为版本号，例如 \u0026ldquo;2023-09-09\u0026rdquo; 表示特定日期的版本。这对于追踪代码的时间演变很有用，但可能不够表达代码的重要性或功能变化。\n手动管理版本： 在小型项目中，你可以灵活地手动更新版本号。你可以根据项目的需求和重要性来决定何时增加版本号。\n自动化版本管理工具： 对于大型项目或需要更复杂版本管理的项目，可以考虑使用自动化版本管理工具，如Git标签、持续集成/持续交付（CI/CD）系统或版本管理工具（如Semver）。这些工具可以自动为你生成和管理版本号。\n无论你选择哪种版本管理方法，都要确保版本号能够反映代码的重要性和改变，并且清晰地传达给用户和其他开发人员。通常情况下，每次修改都不需要更新版本号，只有当发布了重要的功能、重大变更或修复了重要的问题时，才需要考虑增加版本号。最重要的是，版本号管理应该是有组织的，以便更好地理解和跟踪代码的变化。\n","permalink":"https://eddyblog.cn/posts/tech/c_language_comment_specification/","summary":"常用的注释模板 C语言并没有一个官方的注释规范，但有一些常见的注释风格和最佳实践，可以帮助你编写清晰、易于理解的注释。以下是一些常用的高效注释模板，你可以根据需要进行自定义： 文件头注释： 在每个源代码文件的顶部，包括以下信息： /* * 文件名: example.c * 作者: Your Name * 日期: 2023-09-07 * 描述: 这个文件包含了","title":"【C语言指南】代码注释规范"},{"content":"前言 在进行版本控制时，管理大文件是一个常见但棘手的问题。GitHub为了维护性能和资源，对大文件的存储有一些限制。本文将介绍如何使用Git LFS（Large File Storage）来高效管理大文件，以及如何应对可能遇到的问题并提供解决方案。\n问题阐述 你可能会遇到两种常见的问题：\n如何将大于GitHub默认50MB文件大小限制的大文件上传到仓库？\n如何处理大于Git LFS的100MB限制的大文件？\n本文将逐一回答这些问题，并帮助你了解如何优雅地处理大文件。\nGit LFS 简介 Git LFS（Large File Storage）是一种Git扩展，专门用于管理大文件。它的原理是将大文件存储在专门的外部存储服务器上，而不是将它们存储在Git仓库中。这可以显著减小Git仓库的大小，提高性能，并更好地管理大文件的版本控制。\n下面是使用Git LFS的最佳实践：\n1. 安装 Git LFS 首先，确保你已经安装了Git LFS。你可以在官方网站找到安装指南：Git LFS 官方网站\n2. 初始化 Git LFS 在你的Git仓库中，使用以下命令来初始化Git LFS：\ngit lfs install 这将在你的Git仓库中启用Git LFS。\n3. 跟踪大文件 选择需要跟踪的大文件，然后使用git lfs track命令告诉Git LFS要跟踪哪些文件。例如，如果你要跟踪所有.mp4和.zip文件，可以运行以下命令：\ngit lfs track \u0026#34;*.mp4\u0026#34; git lfs track \u0026#34;*.zip\u0026#34; 这会将这些文件类型的大文件添加到Git LFS的跟踪列表中。\n4. 提交和推送 现在，当你添加、提交和推送这些大文件时，Git LFS将会自动处理它们。大文件将被上传到Git LFS服务器，而不是存储在Git仓库中。\ngit add file.mp4 git commit -m \u0026#34;Add large video file\u0026#34; git push origin main 5. 下载大文件 其他团队成员或克隆你的仓库的人只需运行git clone命令即可获得仓库的大文件。Git LFS会自动下载这些大文件。\ngit clone \u0026lt;repository-url\u0026gt; 6. 管理存储库 你可以使用一些额外的Git LFS命令来管理存储库的大文件。例如，使用git lfs ls-files来查看当前跟踪的大文件列表。\ngit lfs ls-files 通过这些步骤，你可以更好地管理大文件，减小Git仓库的大小，并确保大文件的版本控制不会影响整个Git仓库的性能。请注意，为充分利用Git LFS的功能，你需要使用支持Git LFS的Git仓库托管服务，例如GitHub、GitLab等。\n常见问题解答 Question1: 大文件将被上传到Git LFS服务器，而不是存储在Git仓库中。这是不是意味着在我的仓库中这些大文件不可见？ 是的，使用Git LFS来管理大文件后，这些大文件不再以实际内容存储在Git仓库中。相反，Git LFS会将它们替换为指向Git LFS服务器上的指针文件。这些指针文件非常小，不包含大文件的实际数据。\n这个方法的好处是你的Git仓库变得更加轻量，克隆和拉取仓库的速度更快，因为不需要下载大文件的实际数据，而是需要时从Git LFS服务器上获取。另外，你可以更好地管理大文件的版本控制，而不会使Git仓库变得庞大和不稳定。\nQuestion2: 那么在之后git clone该仓库，包括这些大文件也会一键拉取到本地吗？ 是的，当你使用Git LFS来管理大文件的仓库时，其他人通过git clone命令克隆仓库时，大文件也会一并被拉取到本地。这是Git LFS的一个关键功能，它确保了大文件的可访问性。当你或其他人运行git clone命令时，Git LFS会自动检测仓库中跟踪的大文件，并从Git LFS服务器下载它们的实际数据。这意味着克隆的仓库会包括所有的大文件，以便你可以在本地工作和使用它们。\nQuestion3: 假如我这个文件有300MB，既超过了GitHub默认的50MB文件大小限制，也超过了Git LFS的100MB限制，那么该如何上传？ 如果你的文件大小为300MB，超过了GitHub默认的50MB限制和Git LFS的100MB限制，GitHub不会接受这个大文件。对于这种情况，你需要考虑其他方法来存储和共享它。\n以下是一些备选方案：\n云存储服务：将大文件上传至云存储服务（如Google Drive、Dropbox、OneDrive等），然后在您的GitHub仓库中添加链接到这些文件的URL。这样，您可以通过链接访问大文件，而不必将它们存储在GitHub仓库中。\n分割文件：如果可能的话，将大文件分割成多个小文件，每个小文件都在GitHub的文件大小限制内。然后将这些小文件上传到GitHub仓库，并在需要时重新组装它们。\nGit LFS托管：如果有访问Git LFS服务器的权限，可以将大文件上传到自己托管的Git LFS服务器上，并将这些大文件的Git LFS指针链接到GitHub仓库。这种情况下，您需要自行管理Git LFS服务器。\n使用其他存储服务：如果您的项目需要共享大文件，可能需要考虑使用专门用于存储大文件的服务，例如Amazon S3、Azure Blob存储等。这些服务通常可以更好地处理大文件。\n总之，对于超过GitHub和Git LFS限制的大文件，需要采取额外的措施来管理和共享它们，具体方法取决于您的项目需求和可用资源。\n","permalink":"https://eddyblog.cn/posts/tech/github_git_lfs/","summary":"前言 在进行版本控制时，管理大文件是一个常见但棘手的问题。GitHub为了维护性能和资源，对大文件的存储有一些限制。本文将介绍如何使用Git LFS（Large File Storage）来高效管理大文件，以及如何应对可能遇到的问题并提供解决方案。 问题阐述 你可能会遇到两种常见的问题： 如何将大于","title":"【GitHub 使用指南】解决大文件上传问题：Git LFS 最佳实践"},{"content":"问题描述 输入git push命令后报错\n$ git push -f origin main Enumerating objects: 149, done. Counting objects: 100% (149/149), done. Delta compression using up to 16 threads Compressing objects: 100% (144/144), done. error: RPC failed; HTTP 502 curl 22 The requested URL returned error: 502 Writing objects: 80% (119/148), 1.36 GiB | 237.00 KiB/ssend-pack: unexpected disconnect while reading sideband packet Writing objects: 100% (148/148), 1.39 GiB | 2.68 MiB/s, done. Total 148 (delta 3), reused 0 (delta 0), pack-reused 0 fatal: the remote end hung up unexpectedly 原因分析 这个错误表明在进行 git push 操作时，出现了HTTP 502错误，这通常是由于远程Git服务器出现问题或网络问题导致的。HTTP 502错误是一种\u0026quot;Bad Gateway\u0026quot;错误，意味着Git服务器无法正常处理你的请求。\n实际原因 我git push的这个文件夹有2.71G。\n非常大的Git提交（2.71GB）可能导致HTTP请求超时或服务器拒绝处理。Git服务器和Git托管服务通常对提交大小有一定的限制，以确保系统的稳定性和性能。\n针对大文件Git提交的解决方案 有一些可能的解决方法：\n压缩提交大小： 如果可能的话，尝试减小提交的大小。这可以通过删除不必要的大文件、使用Git LFS（Large File Storage）来管理大文件等方式来实现。\n分批次提交： 将大的提交拆分成多个小的提交，逐个推送。这样可以减少每个提交的大小，减少超时的可能性。\n使用Git LFS： 如果你处理大文件，考虑使用Git LFS来管理它们。Git LFS会将大文件存储在专门的存储服务器上，而不是将它们存储在Git仓库中。\n增加Git缓冲区大小： 如前所述，可以尝试增加Git的缓冲区大小，以容纳大提交。但这并不总是解决问题的最佳方法，因为它可能导致内存使用过多。\n使用SSH协议： 尝试使用SSH协议进行推送，因为它通常更稳定，不太容易受到HTTP请求大小的限制。\n联系Git仓库提供商： 如果你使用的是托管服务（如GitHub、GitLab等），请查看他们的文档以了解他们对提交大小的限制。如果需要，联系他们的支持团队以获取更多帮助。\n记住，处理大文件和大提交时需要格外小心，确保你的Git仓库不会变得过于庞大和不稳定。合理地管理大文件和提交对于维护一个高效的Git仓库非常重要。\n解决方案 有几种可能的解决方法：\n重试操作： 首先，尝试再次运行 git push 命令。有时这个错误只是临时的，重新尝试可能会成功。\n检查网络连接： 确保你的网络连接正常，没有断开或不稳定的问题。有时网络问题可能导致这个错误。\n等待一段时间： 如果这是远程Git服务器的问题，等待一段时间后再尝试可能会解决问题。远程服务器可能正在维护或遇到临时问题。\n联系Git仓库提供者： 如果你使用的是托管服务（如GitHub、GitLab等），可以查看该服务的状态页面，看是否有已知的故障或问题。如果是内部的Git服务器，联系系统管理员以获取支持。\n增加Git缓冲区大小： 在某些情况下，增加Git缓冲区大小可以解决问题。你可以使用以下命令来设置缓冲区大小：\ngit config http.postBuffer 524288000 这会将缓冲区大小设置为500 MB。你可以根据需要进行调整。\n使用SSH协议： 如果你当前使用的是HTTP协议，尝试使用SSH协议进行推送。SSH通常更稳定，不容易受到HTTP请求问题的影响。\n联系Git仓库提供商支持： 如果上述方法都无法解决问题，最好联系你使用的Git仓库提供商的支持部门，他们可能能够提供更详细的帮助。\n","permalink":"https://eddyblog.cn/posts/tech/github_git_push_502_bad_gateway/","summary":"问题描述 输入git push命令后报错 $ git push -f origin main Enumerating objects: 149, done. Counting objects: 100% (149/149), done. Delta compression using up to 16 threads Compressing objects: 100% (144/144), done. error: RPC failed; HTTP 502 curl 22 The requested URL returned error: 502 Writing objects: 80% (119/148), 1.36 GiB | 237.00 KiB/ssend-pack: unexpected disconnect while reading sideband packet Writing objects: 100% (148/148), 1.39 GiB | 2.68 MiB/s, done. Total 148 (delta 3), reused 0 (delta 0), pack-reused 0 fatal: the remote end hung up unexpectedly 原因分析 这个错误表明在进行 git push 操作时，出现了HTTP 502错误，这通常是由于远程","title":"【GitHub使用指南】解决Git Push错误 - 502 Bad Gateway"},{"content":"问题描述 当使用GitHub Actions执行工作流程时，有时会遇到错误消息，其中一个常见的错误是：Action failed with 'not found deploy key or tokens。这个错误通常表示GitHub Actions在执行过程中找不到有效的部署密钥或访问令牌。这篇博客将帮助你了解如何解决这个问题。\n错误原因分析 在GitHub Actions的工作流程中，有些操作需要使用密钥或令牌来访问GitHub存储库或执行其他敏感操作，例如推送更改到仓库。这些密钥或令牌通常存储在GitHub存储库的Secrets中。当出现not found deploy key or tokens错误时，这意味着GitHub Actions无法找到所需的密钥或令牌。\n解决步骤 以下是解决not found deploy key or tokens的步骤：\n1. 检查密钥或令牌是否存在 首先，确保你的个人访问令牌（Personal Access Token）或部署密钥已正确设置并存储在GitHub存储库的Secrets中。登录到GitHub，导航到你的存储库，然后点击右上角的Settings。在左侧导航栏中，选择Secrets。确保你需要的密钥或令牌存在于这里。\n2. 确保Secrets名称正确 在GitHub Actions配置文件中，你引用了一个Secrets，例如：\nPERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} 确保名称大小写正确，与存储库中的Secrets名称完全匹配。GitHub Actions对大小写敏感。\n3. 检查Secrets权限 确保你的个人访问令牌或部署密钥具有足够的权限来执行所需的操作。如果你需要推送更改到仓库，确保访问令牌有推送权限。不同操作可能需要不同的权限，因此要确保你的密钥或令牌拥有所需的权限。\n4. 检查工作流程配置 在GitHub Actions工作流程文件中，比如main.yml，你需要确保部分，比如uses部分，引用了正确的Secrets。检查配置文件中的这些引用，确保Secrets的名称与你在Secrets中设置的名称匹配。\n5. 检查工作流程触发条件 确保你的工作流程按照正确的触发条件运行。如果你的工作流程只应在某些条件下运行，请确保这些条件已正确配置。触发条件通常在工作流程文件的顶部定义。\n6. 监视GitHub Actions日志 在GitHub存储库中，转到\u0026quot;Actions\u0026quot;标签，然后选择你的工作流程。查看详细的日志以获取更多信息，以便确定错误发生的位置。日志通常会提供有关哪一步出现了问题的线索。\nGitHub Actions是一个强大的自动化工具，但需要小心处理密钥和令牌，以确保安全性。希望这些步骤能帮助你解决这个问题并顺利执行你的工作流程。\n","permalink":"https://eddyblog.cn/posts/tech/github_git_action_error/","summary":"问题描述 当使用GitHub Actions执行工作流程时，有时会遇到错误消息，其中一个常见的错误是：Action failed with 'not found deploy key or tokens。这个错误通常表示GitHub Actions在执行过程中找不到有效的部署密钥或访问令牌。这篇博客将帮助你了解如何解决这个问题。 错误原因分析 在Gi","title":"【GitHub使用指南】解决Git操作错误 - Github Action问题分析"},{"content":"前言 在本文中，我们将介绍如何通过GitHub Action自动化部署Hugo博客。如果你是一个博客作者，你可能已经熟悉了使用Hugo构建和管理你的博客。Hugo是一个快速且灵活的静态网站生成器，但是手动部署博客可能会变得繁琐。为了解决这个问题，我们可以利用GitHub Action，这是一个GitHub提供的持续集成和持续交付（CI/CD）工具，来自动构建和部署我们的博客。\n问题与挑战 在使用Hugo构建博客时，通常需要手动执行一系列命令来生成静态文件，然后将这些文件上传到托管博客的平台（如GitHub Pages）。这个过程可能会变得比较繁琐，特别是当你需要频繁更新博客内容时。\n另一个问题是，虽然我们可以管理生成的静态文件，但博客的Markdown源文件通常分散在不同的位置，难以备份和版本管理。\n为了解决这些问题，我们希望有一个简单且顺滑的方式来自动化博客的发布流程。\nGitHub Action简介 GitHub Action是GitHub提供的一项强大的自动化工具，它可以用于执行各种自动化任务，包括构建、测试和部署。你可以通过简单的配置文件来定义GitHub Action的工作流程。\n在我们的情况下，我们将使用GitHub Action来自动构建并部署Hugo博客。\n配置GitHub Action 要配置GitHub Action，首先需要在博客源文件的仓库中创建一个.github/workflows目录，并在该目录下创建一个.yml配置文件。我们将其命名为deploy.yml。\n以下是一个自动化部署Hugo博客的示例deploy.yml配置文件：\nname: deploy on: push: branches: - main # 或者是你的源代码分支 jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Set up Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build and Deploy run: | hugo -F --cleanDestinationDir # 生成静态文件 mkdir -p public # 确保public文件夹存在 cp -r public/* ./ # 复制生成的静态文件到仓库根目录 - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} # 你的个人访问令牌 EXTERNAL_REPOSITORY: username/username.github.io # 你的GitHub Pages仓库 PUBLISH_BRANCH: main # 或者是你的GitHub Pages分支 PUBLISH_DIR: ./ commit_message: ${{ github.event.head_commit.message }} 让我们来解释一下这个配置文件：\non 表示GitHub Action的触发条件。在这个配置中，我们设置了push，并指定了触发的分支为main（或者你的源代码分支）。\njobs 表示GitHub Action中的任务。我们定义了一个名为deploy的任务，其中runs-on指定了GitHub Action的运行环境，我们选择了ubuntu-latest。\nsteps 是任务中的具体步骤，包括：\nCheckout repository：用于检出博客源文件仓库，submodules配置为true可同步博客源仓库的子模块，即我们的主题模块。\nSet up Hugo：使用Hugo的GitHub Action，设置Hugo的版本。\nBuild and Deploy：运行hugo命令生成博客的静态文件，并将生成的静态文件复制到仓库根目录。\nDeploy to GitHub Pages：使用GitHub Pages的GitHub Action，将生成的静态文件发布到GitHub Pages仓库。\n最后，我们需要在GitHub账户的设置中生成一个Personal Access Token，并将其添加到博客源文件仓库的Settings -\u0026gt; Secrets -\u0026gt; Actions中，命名为PERSONAL_TOKEN，以便GitHub Action能够获取到Token权限。\n生成token 当您需要在GitHub Action中执行需要身份验证的操作时，例如推送到另一个仓库或访问私有仓库，您需要提供身份验证凭据。GitHub提供了一种安全的方式来存储这些凭据，即使用Personal Access Token（个人访问令牌）并将其添加到仓库的Secrets中。\n以下是如何生成Personal Access Token并将其添加到GitHub仓库的Secrets中的详细步骤：\n生成Personal Access Token：\n登录到您的GitHub账户。\n点击右上角的头像，然后选择Settings（设置）。\n在左侧导航栏中，点击Developer settings（开发者设置）。\n在下拉菜单中，选择Personal access tokens（个人访问令牌）。\n点击右上角的Generate token（生成令牌）按钮。\n配置Personal Access Token的权限：\n当您生成Personal Access Token时，需要为其分配适当的权限。根据您的需求，可以为其分配不同的权限，例如访问仓库、读取用户资料等。请谨慎选择权限，最小化所需的权限以提高安全性。\n生成令牌：\n在配置了权限后，滚动到页面底部，然后单击Generate token（生成令牌）。GitHub将生成一个令牌，并将其显示在屏幕上。请务必将此令牌复制到安全的地方，因为在生成后，您将无法再次查看完整的令牌。\n将令牌添加到GitHub仓库的Secrets：\n转到包含您的博客源文件的GitHub仓库。\n在仓库顶部导航栏中，单击Settings（设置）。\n在左侧导航栏中，选择Secrets（密码）。\n单击New repository secret（新存储库密码）按钮。\n在Name字段中，输入PERSONAL_TOKEN（或您选择的名称）。\n在Value字段中，粘贴您在第3步中生成的Personal Access Token。\n单击Add secret（添加密码）按钮。\n现在，您的Personal Access Token已经以安全的方式存储在GitHub仓库的Secrets中，并可以在GitHub Action的工作流程中使用。\n在上文中提到的PERSONAL_TOKEN将会被引用并传递给GitHub Action中的相关步骤，以便执行需要身份验证的操作。这个过程确保了敏感凭据的安全性，并且不会将它们直接硬编码到工作流程文件中，从而保护了您的GitHub仓库的安全性。\n通过遵循这些步骤，您可以轻松地配置GitHub Action以自动化部署Hugo博客，并确保了令牌和其他敏感信息的安全使用。\n实现自动发布 完成上述配置后，只需将博客的Markdown源文件编辑并推送到仓库，GitHub Action就会自动触发构建和部署过程。生成的博客页面将自动发布到GitHub Pages仓库。\n通过这个自动化流程，我们不仅解决了手动发布的繁琐问题，还能够更好地管理博客的Markdown源文件。现在，每当我们编辑博客内容后，只需推送代码，等待几分钟，就可以通过我们的自定义域名访问更新后的博客。\n这个自动化流程大大简化了博客的发布过程，让我们更专注于创作内容而不是繁杂的部署工作。\n希望这篇文章对你理解如何利用GitHub Action自动化部署Hugo博客有所帮助。自动化可以显著提高工作效率，同时也为博客作者提供了更好的创作体验。\n","permalink":"https://eddyblog.cn/posts/tech/github_action_hugo/","summary":"前言 在本文中，我们将介绍如何通过GitHub Action自动化部署Hugo博客。如果你是一个博客作者，你可能已经熟悉了使用Hugo构建和管理你的博客。Hugo是一个快速且灵活的静态网站生成器，但是手动部署博客可能会变得繁琐。为了解决这个问题，我们可以利用GitHub Action，","title":"【Hugo网站搭建】GitHub Action自动化部署Hugo博客"},{"content":"项目背景 项目背景：在使用 Hugo 构建网站的过程中，可能会遇到各种各样的问题。本篇博客记录了一次在重建 Hugo 网站时遇到的 YAML 解析错误问题，以及如何解决这个问题的过程。\n问题描述 在使用 hugo server 命令重新构建网站时，出现了以下错误信息：\nERROR 1 error building site: assemble: \u0026#34;D:\\myblog\\Eddy-hugo-papermod\\content\\posts\\tech\\PicGo.md:1:1\u0026#34;: failed to unmarshal YAML: yaml: did not find expected key 这个错误提示指向了文件 PicGo.md 的第 1 行，表明在解析该文件的 YAML 头部时出现了问题。\n--- title: \u0026#34;【图床工具】PicGo-bug日记\u0026#34;unable to verify the first certificate\u0026#34;\u0026#34; --- ERROR 2 ERROR Rebuild failed: assemble: \u0026#34;D:\\myblog\\Eddy-hugo-papermod\\content\\posts\\tech\\PicGo_bug.md:13:1\u0026#34;: failed to unmarshal YAML: yaml: line 13: did not find expected key 这个错误提示指向了文件 PicGo.md 的第 13行，表明在解析该文件的 YAML 头部时出现了问题。\n--- description: \u0026#34;解决 PicGo 图床工具中的 \u0026#34;unable to verify the first certificate\u0026#34; 错误\u0026#34; --- 原因分析 根据错误信息，这个问题是因为在 YAML头部中未找到预期的键（key）导致的。在 YAML 格式中，每个键都应该有对应的值，但在该文件的第 1 行 YAML 头部中，缺少了一个预期的键。\nHugo 使用 YAML 头部来存储文章的元信息，这些元信息用于配置文章的标题、日期、作者、标签等信息。如果 YAML 头部的格式不正确，Hugo 解析过程中就会出现问题，导致构建失败。\n解决方案 为了解决这个问题，需要检查并修复 PicGo.md 文件的 YAML 头部。正确的YAML头部应该以三个连续的短横线 --- 开始和结束，中间包含各个键值对。以下是一个示例的 YAML 头部：\n--- title: \u0026#34;文章标题\u0026#34; date: 2023-08-25T00:00:00+08:00 author: \u0026#34;作者\u0026#34; categories: - 技术 tags: - Hugo - Markdown --- 请确保 YAML 头部的格式正确，每个键都有对应的值。如果问题仍然存在，请提供 PicGo.md 文件的 YAML 头部内容，以便更好地帮助诊断和解决问题。\nERROR1 在标题中似乎包含了一个额外的引号。在标题 \u0026ldquo;【图床工具】PicGo-bug日记\u0026quot;unable to verify the first certificate\u0026rdquo;\u0026quot; 中，最后一个引号之后的内容似乎被认为是 YAML 内容的一部分，导致解析错误。\n--- title: \u0026#34;【图床工具】PicGo-bug日记\\\u0026#34;unable to verify the first certificate\\\u0026#34;\u0026#34; --- 请注意，我在标题中的引号前添加了反斜杠（\\），以便正确识别引号并避免引起 YAML 解析问题。同时，请确保标题格式正确，并且您的 Hugo 主题能够正确显示这样的标题。\nERROR2 根据您提供的信息，问题出现在 description 字段的内容中，这里使用了双引号，导致 YAML 解析失败。\n为了解决这个问题，您可以考虑以下两种方法：\n1.使用单引号： 将 description 字段的内容使用单引号括起来，这样就不会与双引号冲突。\ndescription: \u0026#39;解决 PicGo 图床工具中的 \u0026#34;unable to verify the first certificate\u0026#34; 错误。了解错误原因、网络加速工具可能引发的问题，并探讨关闭 fastgithub 解决方案。同时介绍 PicGo 官方文档中的常见问题和解决方法，确保图床上传稳定可靠。\u0026#39; 2.转义双引号： 在 description 字段的内容中，使用反斜杠（\\）来转义双引号，告诉解析器这些双引号不是表示字符串的边界。\ndescription: \u0026#34;解决 PicGo 图床工具中的 \\\u0026#34;unable to verify the first certificate\\\u0026#34; 错误。了解错误原因、网络加速工具可能引发的问题，并探讨关闭 fastgithub 解决方案。同时介绍 PicGo 官方文档中的常见问题和解决方法，确保图床上传稳定可靠。\u0026#34; 请根据您的偏好选择其中一种方法，并进行尝试。这应该可以解决 YAML 解析失败的问题。\n总结 在 Hugo 网站构建的过程中，准确的 YAML 头部格式至关重要。通过本文，您了解了在构建过程中可能遇到的 YAML 解析错误，以及如何通过检查和修复 YAML 头部来解决问题。确保您的 Hugo 网站的元信息格式正确，将有助于避免类似的问题，使构建过程更加顺利。\n","permalink":"https://eddyblog.cn/posts/tech/hugo_bug_yaml/","summary":"项目背景 项目背景：在使用 Hugo 构建网站的过程中，可能会遇到各种各样的问题。本篇博客记录了一次在重建 Hugo 网站时遇到的 YAML 解析错误问题，以及如何解决这个问题的过程。 问题描述 在使用 hugo server 命令重新构建网站时，出现了以下错误信息： ERROR 1 error building site: assemble: \u0026#34;D:\\myblog\\Eddy-hugo-papermod\\content\\posts\\tech\\PicGo.md:1:1\u0026#34;: failed to unmarshal YAML: yaml: did not find expected key 这个错误提示指向了文件 PicGo.md 的第 1 行，表","title":"【Hugo网站搭建】bug日志 - 解决 YAML 解析错误"},{"content":"项目场景： 在使用 PicGo 进行图床上传时，出现了一个错误，具体的错误信息如下：\n[PicGo ERROR] { \u0026#34;method\u0026#34;: \u0026#34;PUT\u0026#34;, \u0026#34;statusCode\u0026#34;: 0, \u0026#34;message\u0026#34;: \u0026#34;unable to verify the first certificate\u0026#34;, \u0026#34;stack\u0026#34;: \u0026#34;Error: unable to verify the first certificate\\n\u0026#34; } 这个错误让我对图床上传产生了困惑，于是我进行了一些分析和研究，尝试找出问题的原因，并寻求解决方案。\n问题描述： 在使用 PicGo 进行图床上传时，出现了一个与 SSL 证书验证相关的错误。具体的错误信息显示无法验证第一个证书，导致了上传失败。这个问题的发生使我无法顺利地上传图片到我所使用的图床，让我感到困扰。\n原因分析： 经过我的分析，我发现这个问题可能与网络加速工具有关。尤其是在使用类似 fastgithub 这样的网络加速工具时，可能会出现这种问题。尽管这些工具在一些情况下可以提高访问速度，但它们有时也可能引发一些网络通信问题，特别是涉及到 SSL 证书验证的情况。\n在网络通信中，SSL 证书是确保通信安全的关键组成部分。服务器使用 SSL 证书来证明其身份，并加密传输的数据，以防止第三方窃听或篡改。当访问一个使用 SSL（或其继任者 TLS）加密的网站或服务时，浏览器会验证服务器的 SSL 证书，确保连接安全。\n然而，某些网络加速工具可能会修改网络流量，甚至可能与 SSL证书验证机制发生冲突。这可能导致 SSL 证书验证失败，因为服务器的证书无法正常验证，从而出现类似 \u0026quot;unable to verify the first certificate\u0026quot; 的错误。\n解决方案： 根据我自己的实际尝试和一些资料的学习，我找到了一个解决方案来解决这个问题。在我的情况下，关闭 fastgithub 工具后，问题得到了解决。这可能是因为关闭该工具后，网络通信不再受到其影响，恢复了正常的 SSL 证书验证过程。\n要解决类似问题，您也可以尝试以下方法：\n更新工具： 如果您发现网络加速工具版本较旧，可能存在已知的问题，尝试更新到最新版本以获得修复。\n工具配置： 某些工具可能允许您自定义其操作和影响。检查工具的配置选项，看看是否可以调整它们的行为以避免与 SSL 证书验证冲突。\n备用加速工具： 如果一个工具存在问题，您可以尝试其他类似的网络加速工具，看看是否会更好地适应您的环境。\n不使用加速工具： 如果问题无法解决，可能最好的方法是不使用网络加速工具，以避免潜在的网络通信问题。\n最终，为了确保通信的安全和稳定，建议使用经过验证和可信赖的网络通信方式，避免引入可能的不稳定因素。\nPicGo 官方文档中的相关 FAQ 在 PicGo 官方文档的 FAQ 中，也提到了一些关于 GitHub 图床上传的常见问题和解决方案，您也可以参考这些内容：\n7. GitHub 图床有时能上传，有时上传失败 GitHub 图床不支持上传同名文件，如果有同名文件上传，会报错。建议开启 时间戳重命名 避免同名文件。\nGitHub 服务器和国内 GFW 的问题会导致有时上传成功，有时上传失败，无解。想要稳定请使用付费云存储，如阿里云、腾讯云等，价格也不会贵。\n9. 上传失败，或者是服务器出错 PicGo 自带的图床都经过测试，上传出错一般都不是 PicGo 自身的原因。如果您用的是 GitHub 图床，请参考 FAQ 中的相关内容。\n检查 PicGo 的日志（报错日志可以在 PicGo 设置 -\u0026gt; 设置日志文件 -\u0026gt; 点击打开 后找到），看看 [PicGo Error] 的报错信息里有什么关键信息：\n先自行搜索 error 里的报错信息，往往您可以通过搜索引擎找到问题的原因，不必立即提交问题。\n如果报错信息带有 401、403 等 40X 状态码字样，不用怀疑，很可能是配置信息有误，仔细检查配置，确保没有多余的空格等。\n如果报错信息带有 HttpError、RequestError、socket hang up 等字样，说明这是网络问题。在这种情况下，您需要检查自己的网络，是否存在代理、DNS 设置是否正常等。\n通常情况下，上传失败很可能是因为网络问题导致的。如果您开启了系统代理，建议同时在 PicGo 的代理设置中设置对应的 HTTP 代理，详情请参考相关文档。\n通过我的研究和实践，我找到了解决这个 \u0026quot;unable to verify the first certificate\u0026quot; 问题的方法，也了解了一些关于 PicGo 的官方文档中提供的解决方案。希望这些信息能够帮助到您解决类似问题，确保您能够顺利地使用 PicGo 进行图床上传。如果您遇到了类似问题，不妨尝试我的解决方案，也可以参考官方文档中的相关内容，找到适合您的解决方法。\n资料参考 ","permalink":"https://eddyblog.cn/posts/tech/picgo_bug/","summary":"项目场景： 在使用 PicGo 进行图床上传时，出现了一个错误，具体的错误信息如下： [PicGo ERROR] { \u0026#34;method\u0026#34;: \u0026#34;PUT\u0026#34;, \u0026#34;statusCode\u0026#34;: 0, \u0026#34;message\u0026#34;: \u0026#34;unable to verify the first certificate\u0026#34;, \u0026#34;stack\u0026#34;: \u0026#34;Error: unable to verify the first certificate\\n\u0026#34; } 这个错误让我对图床上传产生了困惑，于是我进行了一些分析和研究，尝试找出问题的原因，并寻求解决方案。 问题描述： 在使用 PicGo 进行图床上传时，出现了一个与 SSL 证书验证相关的错误","title":"【Hugo网站搭建】图床工具PicGo-bug日志"},{"content":"前言 在本篇教程中，我们将为你详细介绍如何使用 GitHub、jsDelivr 和 PicGo 这三大工具，快速搭建一个高效、稳定的博客图床。通过优化图片加载方式，你不仅可以提升博客内容的展示效果，还能够加速网页加载速度，为读者呈现更好的阅读体验。\n图床的重要性 博客作为信息传播的重要途径，常常需要插入图片来更生动地展示内容。然而，直接将图片嵌入博客文章中可能导致博客服务器负担加重，进而影响网页的加载速度。这时，一个稳定的图床就显得尤为必要。\nGitHub：稳定的存储平台 首先，我们将利用GitHub作为图床的存储平台。GitHub的稳定性和可靠性已被广泛认可，尤其是在被微软收购后。它不仅提供免费的存储空间，还能够通过版本控制管理图片，确保你的图像资源安全可控。\njsDelivr：快速CDN加速 为了加速图片加载，我们将使用jsDelivr作为内容分发网络（CDN）。jsDelivr可以在全球范围内提供快速的图像传输，减少用户访问博客时的加载时间，提升用户体验。通过将GitHub存储的图片链接转换为jsDelivr链接，你可以轻松地为博客内容加速。\nPicGo：便捷的上传工具 为了简化上传过程，我们将使用PicGo，一个强大的上传工具。PicGo具备许多有用的功能，其中最引人注目的是剪贴板图片上传。当你在QQ或微信截取了图片后，只需点击剪贴板图片上传按钮，PicGo会自动将剪贴板中的图片上传到配置的图床中，并生成图片外链。这个便利的功能大大提高了图片上传的效率。\n搭建步骤 第一步：注册 GitHub 账号 首先，你需要注册一个 GitHub 账号。如果你还没有账号，现在就前往 GitHub 官网进行注册。\n第二步：创建 GitHub 仓库 登录你的 GitHub 账号，点击页面右上角的+按钮，选择New repository来创建一个新的仓库。这个仓库将用于存储你的博客图片资源。\n第三步：生成 GitHub Token 为了让 PicGo 能够上传图片至 GitHub仓库，我们需要生成一个 Token。前往 GitHub Settings 页面，点击左侧菜单中的Developer settings，然后选择Personal access tokens。点击Generate new token，并为它授予repo权限，然后翻到页面最底部，点击Generate token的绿色按钮生成token。\n第四步：安装并配置 PicGo PicGo官方指南：https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here\nPicGo安装包：https://github.com/Molunerfinn/PicGo/releases\n64位电脑下载PicGo-Setup-2.4.0-beta.4-x64.exe，下载最新版本即可。\n下载并安装 PicGo 工具。打开 PicGo，进入左侧的图床设置，选择GitHub图床。填入你的 GitHub 用户名和仓库名，将刚才生成的 Token 粘贴到对应位置。默认的分支名是main。\n{ \u0026#34;repo\u0026#34;: \u0026#34;\u0026#34;, // 仓库名，格式是username/reponame \u0026#34;token\u0026#34;: \u0026#34;\u0026#34;, // github token \u0026#34;path\u0026#34;: \u0026#34;\u0026#34;, // 自定义存储路径，比如img/ \u0026#34;customUrl\u0026#34;: \u0026#34;\u0026#34;, // 自定义域名，注意要加http://或者https:// \u0026#34;branch\u0026#34;: \u0026#34;\u0026#34; // 分支名，默认是main } 第五步：使用自定义域名 为了优化图片加载速度，我们将使用 jsDelivr 提供的 CDN 服务。在 PicGo 的 GitHub 图床设置中，设置自定义域名为：https://cdn.jsdelivr.net/gh/你的GitHub用户名/仓库名。\n第六步：上传图片并获取外链 现在，你可以使用 PicGo 强大的功能了。通过快捷键或剪贴板图片上传，将图片上传到你的 GitHub 仓库。PicGo 将自动为你生成图片外链，方便你插入到博客文章中。\n总结 通过 GitHub+jsDelivr+PicGo 的组合，你可以快速搭建一个高效、稳定的博客图床，提升博客内容的展示效果。无论你是新手还是老手，在这个教程的指引下，你都能轻松实现图床的搭建，为你的博客增色不少。希望你能在博客创作中享受更顺畅的图片管理和展示体验！\n感谢 PicGo官方指南：https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here\n","permalink":"https://eddyblog.cn/posts/tech/github_jsdelivr_picgo/","summary":"前言 在本篇教程中，我们将为你详细介绍如何使用 GitHub、jsDelivr 和 PicGo 这三大工具，快速搭建一个高效、稳定的博客图床。通过优化图片加载方式，你不仅可以提升博客内容的展示效果，还能够加速网页加载速度，为读者呈现更好的阅读体验。 图床的重要性 博客作为信息传播的重要途径，常常需要插","title":"【Hugo网站搭建】GitHub+jsDelivr+PicGo搭建博客图床"},{"content":"在博客世界中，第一印象往往决定了读者是否愿意深入阅读您的内容。而一个引人注目的封面图像就是制造这一第一印象的关键因素之一。无论您是一个技术大牛、旅行爱好者还是美食达人，一个精心设计的博客封面能够吸引读者、传达主题，并增加博客的可信度。本篇博客将为您提供一些关于创意封面设计与选择的指南，帮助您在博客写作中脱颖而出。\n为什么封面重要？ 博客封面是您博文的门面，它是吸引读者点击、浏览和分享的第一视觉元素。一个精美的封面可以：\n吸引眼球： 鲜明的颜色、独特的构图和视觉冲击力能够在浩瀚的信息中脱颖而出，吸引潜在读者的关注。\n传达主题： 封面图像应与您的博文主题相关，通过视觉元素传达核心内容，让读者迅速了解博文内容。\n增加可信度： 一个精心设计的封面能够给读者留下良好印象，增加博客的专业感和可信度。\n创意封面设计与选择 1. 自己创作： 如果您具备设计技能，不妨尝试自己创作一个独特的封面。使用设计工具如Adobe Photoshop、Canva等，您可以完全按照自己的想法打造一个与博文主题相关的封面。\n2. 免费图片库： 免费图片库提供了大量高质量的照片，可以轻松找到适合的封面图像。常用的免费图片库包括：\nUnsplash: 提供精美的高分辨率照片，涵盖多种主题。网址：https://unsplash.com/\nPexels: 提供高质量的免费照片和视频素材。网址：https://www.pexels.com/\nPixabay: 提供数百万张免费照片、插图和矢量图形。网址：https://pixabay.com/\nFreepik: 提供免费矢量图、照片和PSD文件。网址：https://www.freepik.com/\n在这些网站上，您可以使用关键词搜索相关的图片，然后选择适合的封面图片。\n3.付费图片库： 如果您愿意花费一些费用，付费图片库也提供高质量的图片资源。一些知名的付费图片库包括：\nShutterstock: 提供广泛的高质量图片、视频和音频素材。网址：https://www.shutterstock.com/\nGetty Images: 提供丰富的专业摄影和插图。网址：https://www.gettyimages.com/\nAdobe Stock: Adobe公司提供的付费图片库，包含多种类型的创意素材。网址：https://stock.adobe.com/\n在付费图片库中，您可以购买适合的图片版权，然后将其用作博客封面。\n4.使用照片编辑工具： 您可以使用照片编辑工具来自定义、修改和编辑图片，以满足您的封面需求。工具如 Adobe Photoshop、GIMP（免费）、Canva 等都可以帮助您进行图片编辑和设计。通过调整颜色、排列和添加文字等方式，将图片打造成符合博客风格的封面。\n5.自己拍摄照片： 如果您拥有照相机或手机，您还可以自己拍摄照片，然后将其作为博客封面。自己拍摄的照片能够为博客增加独特性和个性化，确保封面与您的内容紧密匹配。\n6.模板库： 有些网站提供博客封面的模板，您可以在这些网站上找到合适的模板并进行自定义。例如，Canva 提供了许多博客封面模板，您可以根据模板进行编辑和修改，节省设计时间。\n封面设计要点 简洁明了： 封面不宜过于复杂，简洁明了的设计更容易引起读者兴趣。\n色彩搭配： 色彩能够传达情感和主题，选择与博文内容相符的色彩搭配。\n字体选择： 如有文字内容，选择清晰易读的字体，并注意字号和排版。\n符合主题： 封面图像应与博文主题相关，能够迅速传达核心内容。\n结语 博客封面是博文的门面，能够在瞬间吸引读者的关注。通过创意封面设计与选择，您可以增加博客的可读性和可信度。无论您是创业者、学者、摄影师还是美食家，一个精心设计的封面都能够让您的博客更加引人注目。从免费图片库到自己的创作，选择适合自己的方法，让您的博客在浩瀚的网络中脱颖而出。愿您的创意封面为您的博文增色不少，吸引更多读者的关注和喜爱。\n","permalink":"https://eddyblog.cn/posts/tech/creative_cover_design_and_selection/","summary":"在博客世界中，第一印象往往决定了读者是否愿意深入阅读您的内容。而一个引人注目的封面图像就是制造这一第一印象的关键因素之一。无论您是一个技术大牛、旅行爱好者还是美食达人，一个精心设计的博客封面能够吸引读者、传达主题，并增加博客的可信度。本篇博客将为您提供一些关于创意封面设计与选择的","title":"【Hugo网站搭建】博客写作指南-创意封面设计与选择"},{"content":"1.增添博客封面 可以将博客封面存放在static/img下,然后引用\n--- cover: image: \u0026#34;https://eddyblog.cn/img/hugo.png\u0026#34; #图片路径：static/img/hugo.png caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; relative: false --- 原本存放在static/img下的hugo.png经过hugo -F生成public目录后会存放在public/img下，所以这里的链接是https://eddyblog.cn/img/hugo.png\n原理分析：\n域名解析： 域名 eddyblog.cn 需要通过 DNS 解析将其映射到 GitHub Pages 的服务器 IP 地址。这样浏览器才能正确找到要请求的服务器。 GitHub Pages 服务器： 当浏览器发出请求时，DNS 解析后的请求会被路由到 GitHub Pages 的服务器。 资源请求： GitHub Pages 服务器接收到请求后，会寻找请求的资源。在这种情况下，服务器会尝试寻找 /img/hugo.png 路径下的图片资源。 资源响应： 如果服务器找到了请求的图片资源，它会将图片资源作为 HTTP 响应发送回浏览器。 渲染页面： 浏览器接收到图片资源的响应后，会将图片渲染到相应的位置，使其显示在您的博客页面中。 在这个过程中，您的博客域名需要正确解析到 GitHub Pages 的服务器，而您提供的图片链接则是相对于博客站点根目录的路径。这样，当浏览器加载页面时，它会根据提供的图片链接请求并显示相应的图片资源。 2.在博客正文中插入图片 利用自己的服务器加载图片 在 Hugo 的博客中，使用静态文件来存放图片并在 Markdown 中引用这些图片的方法如下：\n在 Hugo 博客源码的根目录下的 static 目录中创建一个名为 img 的子目录，用于存放需要引用的图片。这个目录结构应该类似于 static/img。\n将需要引用的图片放置在 static/img 目录下。\n在您的 Markdown 文件中，使用以下语法来引用本地图片：\n![](/img/1.png) 其中，/img/1.png 是图片在 static/img 目录下的相对路径。Hugo 在生成静态站点时会将 static 目录下的文件一并复制到最终生成的 public 文件夹中。\n这种方式确保您的图片会与生成的网页一同部署，并可以通过相对路径在 Markdown 文件中引用。\n利用图床加速加载图片 如何搭建图床请见该链接\n使用 GitHub、jsDelivr 和 PicGo 搭建博客图床是另一种常见的方式，它允许您将博客中使用的图片存储在 GitHub 仓库中，并通过 jsDelivr 加速服务来加载图片。\n以下是这种方式的一般步骤：\n创建 GitHub 仓库： 在 GitHub 上创建一个用于存储博客图片的仓库，您可以选择将仓库设置为公开或私有，根据您的需要。\n上传图片： 将博客中需要使用的图片上传到 GitHub 仓库中，您可以创建一个文件夹来组织图片。\n获取图片链接： 在 GitHub 仓库中，找到您上传的图片文件，点击文件查看，然后点击 \u0026ldquo;Download\u0026rdquo;（下载）按钮，复制浏览器地址栏中的链接。\n使用 jsDelivr 进行加速： 使用 jsDelivr 的 CDN 加速服务，将 GitHub 仓库中的图片链接进行加速。将 cdn.jsdelivr.net 加上 GitHub 仓库的用户名、仓库名和文件路径，形成类似以下的链接：\nhttps://cdn.jsdelivr.net/gh/用户名/仓库名/文件路径 这样就可以通过 jsDelivr 加速加载图片。\n使用 PicGo 进行上传： PicGo 是一个图床工具，可以帮助您批量上传图片到 GitHub 仓库，并自动生成图片链接。您可以在本地编辑 Markdown 文章时，使用 PicGo 快速上传图片并获取链接。\n在 Markdown 中引用图片： 使用获取到的加速链接，将图片引用插入到 Markdown 文件中。\n这种方式的优势在于，您可以将图片集中存储在 GitHub 仓库中，通过 CDN 加速服务来加载图片，提高图片加载速度。同时，使用 PicGo 可以简化图片上传和链接获取的过程。\n","permalink":"https://eddyblog.cn/posts/tech/hugo_insert_png/","summary":"1.增添博客封面 可以将博客封面存放在static/img下,然后引用 --- cover: image: \u0026#34;https://eddyblog.cn/img/hugo.png\u0026#34; #图片路径：static/img/hugo.png caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; relative: false --- 原本存放在static/img下的hugo.png经过hugo -F生成public目录后会存放在public/img下，所以这","title":"【Hugo网站搭建】博客写作指南-如何在Hugo博客中巧妙运用照片"},{"content":" 在今天的互联网时代，网站速度不仅仅关乎用户体验，更关乎业务的成功。本文将为您介绍如何利用Pingdom工具测试和提升网站速度，以实现更好的性能和用户满意度。\n为何网站速度至关重要？ 在一个信息传递迅速的世界中，用户对于网站速度的期待也不断增加。快速加载的网站不仅能够提供更好的用户体验，还有助于减少用户的流失率，提高页面的转化率。根据统计数据，用户通常只会等待2-3秒钟来加载网页，超过这个时间，他们可能就会离开。\n使用Pingdom测试网站速度 Pingdom是一个广泛使用的网站性能监测工具，它可以帮助您了解您的网站在全球不同地区的加载速度，并提供详细的性能报告。以下是使用Pingdom测试网站速度的步骤：\n访问Pingdom网站： 打开Pingdom的官方网站（https://www.pingdom.com）并注册一个账户。\n添加监测目标： 在Pingdom仪表板中，点击“Add New Check”按钮，输入您的网站URL以及测试的地区。\n运行测试： 点击“Start Test”按钮，Pingdom将会模拟不同地区的用户来测试您的网站加载速度，并生成详细的性能报告。\n分析报告： 在报告中，您可以看到各个地区的加载时间、性能分数以及建议的优化措施。\n网站速度优化实例 以下是一个实际案例，展示了如何利用Pingdom测试和提升网站速度的过程：\n案例：ABC在线商城\nABC在线商城是一个电子商务网站，用户抱怨加载速度较慢，导致页面反应迟缓，影响购物体验和转化率。通过Pingdom测试，发现网站在美国地区的加载时间较长。\n优化步骤：\n压缩图像： 优化网站中的图片，使用适当的压缩工具，以减少页面加载时间。\n启用浏览器缓存： 配置服务器以启用浏览器缓存，以减少重复加载的内容。\n使用CDN： 使用内容分发网络（CDN）来分发网站的静态资源，加速页面加载。\n减少HTTP请求： 合并和减少网站的HTTP请求，从而加快页面的加载速度。\n优化代码： 优化网站的HTML、CSS和JavaScript代码，减少不必要的代码和空格。\n移除不必要的插件： 移除不必要的第三方插件和工具，以减少页面加载的负担。\n结果： 经过优化后，ABC在线商城的网站加载速度在Pingdom测试中有了显著的提升。用户体验得到改善，页面加载时间缩短，转化率也有所增加。\n结论 通过利用Pingdom工具测试和提升网站速度，您可以获得关于网站性能的深入了解，并采取适当的措施来改进用户体验和业务成功。网站速度优化不仅仅是技术问题，更关乎用户满意度和业务增长，务必引起足够的重视。通过上述案例研究，我们可以看到网站速度优化的实际效果，这将为您在实践中提供有力的指导。\n","permalink":"https://eddyblog.cn/posts/tech/website_speed_optimization/","summary":"在今天的互联网时代，网站速度不仅仅关乎用户体验，更关乎业务的成功。本文将为您介绍如何利用Pingdom工具测试和提升网站速度，以实现更好的性能和用户满意度。 为何网站速度至关重要？ 在一个信息传递迅速的世界中，用户对于网站速度的期待也不断增加。快速加载的网站不仅能够提供更好的用户体验","title":"【Hugo网站搭建】网站速度优化-利用Pingdom测试与提升"},{"content":" 提升用户体验，优化网站性能，提高访问速度\n在当今数字化时代，网站性能对于吸引用户、提升用户体验以及搜索引擎排名至关重要。一个快速加载的网站不仅可以减少用户的等待时间，还能够增加转化率，降低跳失率，并为您的品牌树立积极的形象。但是，要实现高性能的网站，并不仅仅是优化代码和图像，更需要系统性地评估和改进。在本文中，我们将介绍如何使用 PageSpeed Insights 工具来评估网站性能，并提供一些改进策略，帮助您优化网站加载速度。\n什么是 PageSpeed Insights？ PageSpeed Insights 是由 Google 提供的一款免费工具，用于评估网站的性能并提供改进建议。该工具会分析网站的页面加载速度，并根据不同的指标为网站打分，同时还会提供详细的性能优化建议。这些建议可以帮助您发现潜在的性能瓶颈，改进加载速度，从而提升用户体验。\n如何使用 PageSpeed Insights？ 使用 PageSpeed Insights 非常简单，您只需前往其官方网站（https://developers.google.com/speed/pagespeed/insights/），输入您要评估的网站 URL，然后点击“分析”按钮即可。PageSpeed Insights 将对您的网站进行分析，然后为您提供两个关键指标的分数：移动设备性能和桌面设备性能。每个指标的分数范围从 0 到 100，分数越高表示性能越好。\n优化建议与策略 PageSpeed Insights 不仅会给出分数，还会提供详细的优化建议和策略。以下是一些常见的优化策略，可帮助您改进网站性能：\n1. 图片优化 图像是网站加载速度的主要因素之一。使用适当的图片格式（如 WebP）并进行压缩，可以显著减少加载时间。另外，使用响应式图像，根据不同设备加载不同分辨率的图像，可以进一步优化性能。\n2. 延迟加载 采用延迟加载（Lazy Loading）技术，只加载当前用户可见区域的内容，而不是一次性加载整个页面。这可以加速页面的首次加载，尤其对于长页面或包含大量图像的页面特别有效。\n3. 浏览器缓存 启用浏览器缓存可以减少重复加载已访问过的资源，从而提高页面加载速度。通过设置适当的缓存策略，可以使用户在再次访问页面时能够从本地缓存加载资源，而不必再次下载。\n4. 压缩代码 压缩 HTML、CSS 和 JavaScript 代码可以减小文件大小，从而加快文件传输速度。许多服务器和工具都提供代码压缩功能，您只需将压缩后的文件上传到服务器即可。\n5. 移除不必要的资源 定期审查您的网站，移除不再使用的资源，如无用的插件、样式表或脚本。减少请求的资源数量可以显著减少页面加载时间。\n真实案例：XYZ 公司的网站性能优化 为了更好地理解如何使用 PageSpeed Insights 进行网站性能优化，让我们看一个真实案例。XYZ 公司的网站在使用 PageSpeed Insights 后，发现移动设备性能分数\n仅为 50，而桌面设备性能分数为 75。经过分析，他们发现以下问题和改进方案：\n图片未经优化： 网站中的图片过大，没有经过压缩和优化。他们采用了图片压缩工具，将图片大小减小了 50%，从而提高了页面加载速度。\n缺少延迟加载： 网站一次性加载了所有图片，导致页面加载时间较长。他们引入了延迟加载技术，只加载用户可见区域的图片，从而减少了首次加载时间。\n缺少浏览器缓存： 网站未启用浏览器缓存，导致用户每次访问都需要重新下载资源。他们设置了适当的缓存策略，使用户能够从本地缓存加载资源，加快了页面加载速度。\n通过以上改进，XYZ 公司的网站性能得到了显著提升，移动设备性能分数达到了 85，桌面设备性能分数达到了 90。用户体验得到了明显改善，页面加载速度大幅提升。\n案例研究：ABC 博客的性能优化之路 ABC 博客是一个知名的技术博客，但近期用户抱怨网站加载速度较慢。博客团队使用 PageSpeed Insights 进行了评估，并发现移动设备性能分数仅为 40，桌面设备性能分数为 60。为了改进性能，他们采取了以下措施：\n压缩资源： 博客中存在大量的 CSS 和 JavaScript 文件，占用了大量带宽。他们对这些文件进行了压缩，并启用了 Gzip 压缩，从而减小了文件大小。\n使用 CDN： 为了加速资源加载，他们将静态资源（如图片、样式表和脚本）托管到了 CDN 上，减少了服务器的负载，加快了资源传输速度。\n减少重定向： 博客中存在多个重定向链接，导致额外的网络请求。他们对重定向链接进行了优化，减少了网络请求次数。\n通过以上改进，ABC 博客的性能得到了显著提升，移动设备性能分数达到了 70，桌面设备性能分数达到了 85。用户体验得到了显著改善，网站加载速度明显加快。\n总结 优化网站性能是提升用户体验、提高转化率以及提升搜索引擎排名的关键步骤。通过使用 PageSpeed Insights 评估网站性能，并采取针对性的优化策略，您可以显著提升网站的加载速度，为用户创造更好的访问体验。通过真实案例和案例研究，我们可以看到优化策略如何在实际中产生积极影响，帮助网站实现高性能和优异的用户体验。\n小提示： 不断关注网站性能，定期使用 PageSpeed Insights 进行评估和改进，是确保网站保持高性能状态的关键。通过不断优化，您可以为用户提供更快、更流畅的访问体验，从而提升网站的价值和竞争力。\n","permalink":"https://eddyblog.cn/posts/tech/optimize_website_performance/","summary":"提升用户体验，优化网站性能，提高访问速度 在当今数字化时代，网站性能对于吸引用户、提升用户体验以及搜索引擎排名至关重要。一个快速加载的网站不仅可以减少用户的等待时间，还能够增加转化率，降低跳失率，并为您的品牌树立积极的形象。但是，要实现高性能的网站，并不仅仅是优化代码和图像，更需要","title":"【Hugo网站搭建】优化网站性能-使用PageSpeed Insights评估与改进"},{"content":"前言 利用windows系统的tree命令生成文件夹目录下的树形结构，并倒入至markdown。\n一、tree是什么？ 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。\n二、使用步骤 1.在想要生成树形结构的文件夹目录下运行powershell，输入命令tree 输入命令tree生成树形目录（示例）：\n卷 Data 的文件夹 PATH 列表 卷序列号为 E84E-7569 D:. ├─.idea ├─archetypes ├─assets │ ├─css │ │ └─extended │ └─js ├─content │ ├─posts │ │ ├─art │ │ ├─projects │ │ └─tech │ │ └─tech1 │ └─tags ├─data ├─i18n ├─layouts │ ├─partials │ │ └─templates │ ├─shortcodes │ └─_default │ └─_markup ├─public │ ├─assets │ │ ├─css │ │ └─js │ ├─en │ │ ├─about │ │ ├─archives │ │ ├─categories │ │ ├─posts │ │ │ ├─art │ │ │ │ ├─art │ │ │ │ └─page │ │ │ │ └─1 │ │ │ ├─page │ │ │ │ └─1 │ │ │ ├─projects │ │ │ │ ├─page │ │ │ │ │ └─1 │ │ │ │ └─projects │ │ │ └─tech │ │ │ ├─page │ │ │ │ └─1 │ │ │ ├─tech │ │ │ └─tech1 │ │ ├─search │ │ ├─series │ │ └─tags │ │ ├─art │ │ │ └─page │ │ │ └─1 │ │ ├─projects │ │ │ └─page │ │ │ └─1 │ │ └─tech │ │ └─page │ │ └─1 │ ├─fonts │ └─img ├─resources │ └─_gen │ ├─assets │ └─images ├─static │ ├─fonts │ └─img └─themes └─hugo-PaperMod ├─.github │ ├─ISSUE_TEMPLATE │ └─workflows ├─assets │ ├─css │ │ ├─common │ │ ├─core │ │ ├─extended │ │ ├─hljs │ │ └─includes │ └─js ├─i18n ├─images └─layouts ├─partials │ └─templates ├─shortcodes └─_default └─_markup 2.输入命令tree \u0026gt; tree.txt保存生成的树形目录至当前文件夹目录下的tree.txt 3.复制粘贴至markdown文件 在markdown使用```开启代码块，将复制的树形目录粘贴在代码块处\n├─.idea ├─archetypes ├─assets │ ├─css │ │ └─extended │ └─js ├─content │ ├─posts │ │ ├─art │ │ ├─projects │ │ └─tech │ │ └─tech1 │ └─tags ├─data ├─i18n ├─layouts │ ├─partials │ │ └─templates │ ├─shortcodes │ └─_default │ └─_markup ├─public │ ├─assets │ │ ├─css │ │ └─js │ ├─en │ │ ├─about │ │ ├─archives │ │ ├─categories │ │ ├─posts │ │ │ ├─art │ │ │ │ ├─art │ │ │ │ └─page │ │ │ │ └─1 │ │ │ ├─page │ │ │ │ └─1 │ │ │ ├─projects │ │ │ │ ├─page │ │ │ │ │ └─1 │ │ │ │ └─projects │ │ │ └─tech │ │ │ ├─page │ │ │ │ └─1 │ │ │ ├─tech │ │ │ └─tech1 │ │ ├─search │ │ ├─series │ │ └─tags │ │ ├─art │ │ │ └─page │ │ │ └─1 │ │ ├─projects │ │ │ └─page │ │ │ └─1 │ │ └─tech │ │ └─page │ │ └─1 │ ├─fonts │ └─img ├─resources │ └─_gen │ ├─assets │ └─images ├─static │ ├─fonts │ └─img └─themes └─hugo-PaperMod ├─.github │ ├─ISSUE_TEMPLATE │ └─workflows ├─assets │ ├─css │ │ ├─common │ │ ├─core │ │ ├─extended │ │ ├─hljs │ │ └─includes │ └─js ├─i18n ├─images └─layouts ├─partials │ └─templates ├─shortcodes └─_default └─_markup 总结 本文简单介绍了windows系统下tree命令的使用，tree命令可以生成文件夹目录下的树形结构，并倒入至markdown。\n","permalink":"https://eddyblog.cn/posts/tech/hugo_introduce_a_tree_directory/","summary":"前言 利用windows系统的tree命令生成文件夹目录下的树形结构，并倒入至markdown。 一、tree是什么？ 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。 二、使用步骤 1.在想要生成树形结构的文件夹目录下运行powershell，输入命令","title":"【Hugo网站搭建】实现post-markdown引入树状目录"},{"content":"前言 下载哪种架构的安装包取决于你的计算机处理器架构。通常，大多数桌面和笔记本电脑使用的是x86_64或简称为amd64架构，因此你应该下载针对该架构的安装包\nAMD 如果你的电脑使用的是x86_64或amd64架构，那么下载x86_64或amd64架构的安装包。\nARM 如果你的计算机是ARM设备，例如某些Raspberry Pi设别或其他ARM架构的计算机，那么你应该下载适用于ARM架构的安装包\n确定处理器架构 要确定你的计算机的处理器架构，可以执行一些操作，例如在命令行中输入uname -m（对于大多数Linux系统），或者在Windows上通过\u0026quot;系统信息\u0026quot;来查看处理器信息。\n总之，下载与你计算机处理器架构匹配的安装包是确保软件能够正常运行的重要一步。\n","permalink":"https://eddyblog.cn/posts/tech/github_amd_arm/","summary":"前言 下载哪种架构的安装包取决于你的计算机处理器架构。通常，大多数桌面和笔记本电脑使用的是x86_64或简称为amd64架构，因此你应该下载针对该架构的安装包 AMD 如果你的电脑使用的是x86_64或amd64架构，那么下载x86_64或amd64架构的安装包。 ARM 如果你的计算机是ARM设","title":"【Github使用指南】release上的安装包amd和arm的选择"},{"content":"项目场景 Hugo\n问题描述 在本地博客源码目录下进行hugo server 失败，无法进入 http://localhost:1313/\n原因分析 假如修改过\u0026quot;themes\\hugo-PaperMod\u0026quot;的话，那么可能是\u0026quot;themes\\hugo-PaperMod\u0026quot;出现了问题\n解决方案 将\u0026quot;themes\\hugo-PaperMod\u0026quot;删除，在hugo-PaperMod的Github主页重新下载一次主题并放在\u0026quot;themes\\\u0026quot;目录下，重新hugo server一次\n建议对PaperMod主题做自定义修改的话，最好在博客源码目录下修改，而不是在\u0026quot;themes\\hugo-PaperMod\u0026quot;修改\n这是博客源码目录：\n卷 Data 的文件夹 PATH 列表 卷序列号为 E84E-7569 D:. ├─.idea ├─archetypes ├─assets │ ├─css │ │ └─extended │ └─js ├─content │ ├─posts │ │ ├─art │ │ ├─projects │ │ └─tech │ │ └─tech1 │ └─tags ├─data ├─i18n ├─layouts │ ├─partials │ │ └─templates │ ├─shortcodes │ └─_default │ └─_markup ├─public │ ├─assets │ │ ├─css │ │ └─js │ ├─en │ │ ├─about │ │ ├─archives │ │ ├─categories │ │ ├─posts │ │ │ ├─art │ │ │ │ ├─art │ │ │ │ └─page │ │ │ │ └─1 │ │ │ ├─page │ │ │ │ └─1 │ │ │ ├─projects │ │ │ │ ├─page │ │ │ │ │ └─1 │ │ │ │ └─projects │ │ │ └─tech │ │ │ ├─page │ │ │ │ └─1 │ │ │ ├─tech │ │ │ └─tech1 │ │ ├─search │ │ ├─series │ │ └─tags │ │ ├─art │ │ │ └─page │ │ │ └─1 │ │ ├─projects │ │ │ └─page │ │ │ └─1 │ │ └─tech │ │ └─page │ │ └─1 │ ├─fonts │ └─img ├─resources │ └─_gen │ ├─assets │ └─images ├─static │ ├─fonts │ └─img └─themes └─hugo-PaperMod ├─.github │ ├─ISSUE_TEMPLATE │ └─workflows ├─assets │ ├─css │ │ ├─common │ │ ├─core │ │ ├─extended │ │ ├─hljs │ │ └─includes │ └─js ├─i18n ├─images └─layouts ├─partials │ └─templates ├─shortcodes └─_default └─_markup ","permalink":"https://eddyblog.cn/posts/tech/hugo_server_failed/","summary":"项目场景 Hugo 问题描述 在本地博客源码目录下进行hugo server 失败，无法进入 http://localhost:1313/ 原因分析 假如修改过\u0026quot;themes\\hugo-PaperMod\u0026quot;的话，那么可能是\u0026quot;themes\\hugo-PaperMod\u0026quot;出现了问题 解决方案 将\u0026quot;themes\\hu","title":"【Hugo网站搭建】bug日志-hugo server失败"},{"content":"前言 VMware自带的VMware Tools复制粘贴功能失败，所以安装open-vm-tools以使用复制粘贴功能。\n一、open-vm-tools是什么？ open-vm-tools 是一组用于 VMware 虚拟机中的开源工具，它们提供了一些与虚拟机操作和管理相关的功能。这些工具与 VMware 虚拟化平台集成，可以在虚拟机中提供更好的性能和功能。以下是一些 open-vm-tools 提供的功能：\n虚拟机增强功能： open-vm-tools 提供了与 VMware 虚拟化平台集成的增强功能，例如拖放文件、共享剪贴板、虚拟机自适应大小等。\n虚拟机信息获取： 这些工具可以提供有关虚拟机配置、硬件和操作系统的信息，使你可以更好地监控和管理虚拟机。\n时钟同步： open-vm-tools 可以帮助虚拟机与虚拟化主机进行时钟同步，确保虚拟机时间与主机时间保持一致。\n电源管理： 这些工具允许你在虚拟机中进行电源管理操作，如重启、关机等。\n性能优化： open-vm-tools 可以与虚拟化平台一起工作，优化虚拟机的性能，提供更好的资源管理和协作。\n注意，open-vm-tools 适用于许多 Linux 发行版，并提供了虚拟机操作和管理方面的许多便利功能。如果你在 VMware 虚拟机中运行 Linux 操作系统，可以考虑安装和使用这些工具来提升虚拟机的性能和功能。安装 open-vm-tools 的方法可能会因你使用的 Linux 发行版而有所不同，通常你可以在操作系统的软件仓库中找到它。\n二、操作步骤 删除VMware-tools 判断自己的VMware是否安装了VMware tools\n如图，显示“重新安装VMware tools”则说明已经安装了VMware tools，然后执行以下命令删除VMware tools\nsudo vmware-uninstall-tools.pl sudo rm -rf /usr/lib/vmware-tools sudo apt-get autoremove open-vm-tools --purge 如果没安装过VMware tools则忽略第一步，直接进入第二步。\n安装 open-vm-tools sudo apt-get install open-vm-tools sudo apt-get install open-vm-tools-desktop 安装完成后，重启虚拟机即可使用复制粘贴功能。\nWindows系统中复制粘贴快捷键是 ctrl+c ctrl+v\nLinux系统中复制粘贴快捷键是 shift+ctrl+c shift+ctrl+v\n文件复制粘贴功能需使用鼠标右键，而不能直接使用快捷键。\n","permalink":"https://eddyblog.cn/posts/tech/linux_vmware_copy_and_paste/","summary":"前言 VMware自带的VMware Tools复制粘贴功能失败，所以安装open-vm-tools以使用复制粘贴功能。 一、open-vm-tools是什么？ open-vm-tools 是一组用于 VMware 虚拟机中的开源工具，它们提供了一些与虚拟机操作和管理相关的功能。这些工具与 VMware 虚拟化平台集成，可以在虚拟机中提供更","title":"【Linux应用开发指南】vmware实现复制粘贴功能"},{"content":"前言 Hugo博客源码根目录下的static目录是用来存放一些静态文件的（包括图片），执行hugo -F生成的public文件夹，会将static目录下的文件一并导入至public文件夹，并最终呈现至服务器网页上。\n所以想要在markdown里引用本地图片，那么就在根目录的static目录下存放图片，并在mardown里引用就可以了。\n操作步骤 1.在static目录下创建img子目录 将需要引用的图片都放在static/img下。\n2.在markdown里引用本地图片 如想在markdown里引用1.png，那么就在markdown里输入\n![](/img/1.png) ","permalink":"https://eddyblog.cn/posts/tech/hugo_referencing_local_images/","summary":"前言 Hugo博客源码根目录下的static目录是用来存放一些静态文件的（包括图片），执行hugo -F生成的public文件夹，会将static目录下的文件一并导入至public文件夹，并最终呈现至服务器网页上。 所以想要在markdown里引用本地图片，那么就在根目录的static","title":"【Hugo网站搭建】实现post-markdown引用本地图片"},{"content":"前言 建议将博客源码和构建的静态页面分别放在两个仓库里。\n操作步骤 1.博客源码（Github仓库） 私有仓库Yourname-Blog（注意Github仓库命名规范）存放博客源码。（也可以是一个公开的仓库，相当于为他人提供了一个博客模板）\n├─.idea ├─archetypes ├─assets │ ├─css │ │ └─extended │ └─js ├─content │ ├─posts │ │ ├─art │ │ ├─projects │ │ └─tech │ │ └─cover │ └─tags ├─data ├─i18n ├─layouts │ ├─partials │ │ └─templates │ ├─shortcodes │ └─_default │ └─_markup ├─public │ ├─assets │ │ ├─css │ │ └─js │ ├─en │ │ ├─about │ │ ├─archives │ │ ├─categories │ │ ├─posts │ │ │ ├─art │ │ │ │ ├─art │ │ │ │ └─page │ │ │ │ └─1 │ │ │ ├─page │ │ │ │ └─1 │ │ │ ├─projects │ │ │ │ ├─page │ │ │ │ │ └─1 │ │ │ │ └─projects │ │ │ └─tech │ │ │ ├─page │ │ │ │ └─1 │ │ │ ├─tech │ │ │ └─tech1 │ │ ├─search │ │ ├─series │ │ └─tags │ │ ├─art │ │ │ └─page │ │ │ └─1 │ │ ├─projects │ │ │ └─page │ │ │ └─1 │ │ └─tech │ │ └─page │ │ └─1 │ ├─fonts │ └─img ├─resources │ └─_gen │ ├─assets │ └─images ├─static │ ├─fonts │ └─img └─themes └─hugo-PaperMod ├─.github │ ├─ISSUE_TEMPLATE │ └─workflows ├─assets │ ├─css │ │ ├─common │ │ ├─core │ │ ├─extended │ │ ├─hljs │ │ └─includes │ └─js ├─i18n ├─images └─layouts ├─partials │ └─templates ├─shortcodes └─_default └─_markup 2.静态页面（Github仓库） 公有仓库yourname.github.io存放构建的静态页面。\n将构建的静态页面，即public/目录下的内容上传到仓库yourname.github.io ，yourname.github.io会自动绑定Github pages , 就可以通过网址yourname.github.io访问部署好的博客。\n├─assets │ ├─css │ └─js ├─en │ ├─about │ ├─archives │ ├─categories │ ├─posts │ │ ├─art │ │ │ ├─art │ │ │ └─page │ │ │ └─1 │ │ ├─page │ │ │ └─1 │ │ ├─projects │ │ │ ├─page │ │ │ │ └─1 │ │ │ └─projects │ │ └─tech │ │ ├─page │ │ │ └─1 │ │ ├─tech │ │ └─tech1 │ ├─search │ ├─series │ └─tags │ ├─art │ │ └─page │ │ └─1 │ ├─projects │ │ └─page │ │ └─1 │ └─tech │ └─page │ └─1 ├─fonts └─img 总结 本文简单介绍了Hugo框架下在Github仓库分别储存博客源码和静态页面的操作步骤和方法。\n","permalink":"https://eddyblog.cn/posts/tech/hugo_saving_source_code/","summary":"前言 建议将博客源码和构建的静态页面分别放在两个仓库里。 操作步骤 1.博客源码（Github仓库） 私有仓库Yourname-Blog（注意Github仓库命名规范）存放博客源码。（也可以是一个公开的仓库，相当于为他人提供了一个博客模板） ├─.idea ├─archetypes ├─ass","title":"【Hugo网站搭建】在Github仓库分别储存博客源码和静态页面"},{"content":"项目场景： Git bash\n问题描述1： 在错误的目录使用git init初始化了一个仓库，此时应该将该仓库删除\n解决方案1： 使用ls -a 命令显示隐藏文件夹和文件，检查该目录下是否有.git文件夹\n发现该目录下含有.git文件夹，使用rm -rf .git删除.git文件夹，同时本地仓库也会被销毁\n问题描述2： 将本地仓库关联到错误的远程仓库，此时应该将该关联删除\n解决方案2： 查看本地仓库关联的远程仓库名称及URL git remote -v 确认关联的错误远程仓库之后，删除关联 git remote remove \u0026lt;远程仓库名称\u0026gt; ","permalink":"https://eddyblog.cn/posts/tech/github_delete_wrong_repository/","summary":"项目场景： Git bash 问题描述1： 在错误的目录使用git init初始化了一个仓库，此时应该将该仓库删除 解决方案1： 使用ls -a 命令显示隐藏文件夹和文件，检查该目录下是否有.git文件夹 发现该目录下含有.git文件夹，使用rm -rf .git删除.git文件夹，同时本地仓库也会被销毁 问题描述2： 将","title":"【Github使用指南】bug日志-删除本地仓库/错误的远程仓库关联"},{"content":"hello\nD:. ├─.idea ├─archetypes ├─assets │ ├─css │ │ └─extended │ └─js ├─content │ ├─posts │ │ ├─art │ │ ├─blog │ │ ├─life │ │ ├─projects │ │ ├─read │ │ └─tech │ │ └─tech1 │ └─tags ├─data ├─i18n ├─layouts │ ├─partials │ │ └─templates │ ├─shortcodes │ └─_default │ └─_markup ├─resources │ └─_gen │ ├─assets │ └─images ├─static │ ├─fonts │ └─img └─themes └─hugo-PaperMod ├─.github │ ├─ISSUE_TEMPLATE │ └─workflows ├─assets │ ├─css │ │ ├─common │ │ ├─core │ │ ├─extended │ │ ├─hljs │ │ └─includes │ └─js ├─i18n ├─images └─layouts ├─partials │ └─templates ├─shortcodes └─_default └─_markup ","permalink":"https://eddyblog.cn/posts/art/art/","summary":"hello D:. ├─.idea ├─archetypes ├─assets │ ├─css │ │ └─extended │ └─js ├─content │ ├─posts │ │ ├─art │ │ ├─blog │ │ ├─life │ │ ├─projects │ │ ├─read │ │ └─tech │ │ └─tech1 │ └─tags ├─da","title":"Art"},{"content":"","permalink":"https://eddyblog.cn/posts/projects/projects/","summary":"","title":"Projects"},{"content":"项目场景： Git bash\n问题描述： 进行git remote add origin https://github.com/你的用户名/你的用户名.github.io.git命令时\n出现错误：error: remote origin already exists\n原因分析： 与本地仓库关联的远程仓库已经存在，无法进行新的关联\n解决方案： 删除已关联的远程库 git remote rm origin 关联正确的远程仓库 git remote add origin https://github.com/你的用户名/你的用户名.github.io.git 推送到正确的仓库 git push -f origin main ","permalink":"https://eddyblog.cn/posts/tech/github_error_remote_origin_already_exists/","summary":"项目场景： Git bash 问题描述： 进行git remote add origin https://github.com/你的用户名/你的用户名.github.io.git命令时 出现错误：error: remote origin already exists 原因分析： 与本地仓库关联的远程仓库已经存在，无法进行新的关联 解决方案： 删除已关联的远程库 git remote rm origin 关联正确的远程仓库 git","title":"【Github使用指南】bug日志-git remote"},{"content":"前言 Hugo添加不蒜子Busuanzi页面浏览次数与阅读数据统计\n一、Busuanzi是什么？ Busuanzi是一个用于统计网站访问量的工具。它通常嵌入到网页中，可以追踪页面的浏览次数，方可数量积极其他一些基本的访问数据。这个工具可以帮助网站管理员了解他们的网站受欢迎程度和流量情况。\n二、使用步骤 在head.html，footer.html，single.html，config.yml进行修改\nhead.html 我的papermod的路径为themes/Hugo-PaperMod/layouts/partials/head.html\n添加以下代码\n\u0026lt;!-- busuanzi --\u0026gt; {{- if .Site.Params.busuanzi.enable -}} \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;no-referrer-when-downgrade\u0026#34;\u0026gt; {{- end -}} footer.html 用于在站点底部显示总访问量与访客数\n我的PaperMod路径为themes/Hugo-PaperMod/layouts/partials/footer.html\n添加以下代码，注意添加在\u0026lt;footer\u0026gt;代码块里\n\u0026lt;!-- busuanzi --\u0026gt; {{ if .Site.Params.busuanzi.enable -}} \u0026lt;div class=\u0026#34;busuanzi-footer\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_pv\u0026#34;\u0026gt; 本站总访问量\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次 \u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_uv\u0026#34;\u0026gt; 本站访客数\u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;人次 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} single.html 用于显示每篇文章阅读量\n我的papermod路径为themes/Hugo-PaperMod/layouts/_default/single.html\n添加以下代码，加在\u0026lt;header\u0026gt;代码块内\n\u0026lt;!-- busuanzi --\u0026gt; {{ if .Site.Params.busuanzi.enable -}} \u0026lt;div class=\u0026#34;meta-item\u0026#34;\u0026gt;\u0026amp;nbsp·\u0026amp;nbsp \u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34;\u0026gt;本文阅读量\u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{- end }} config.yml 回到根目录的config.yml，在params里加上busuanzi:功能\n显示统计即为true\nparams: busuanzi: enable: true 不想显示统计即为false\nparams: busuanzi: enable: false 总结 本文简单介绍了Hugo添加不蒜子Busuanzi站点访问量与阅读量统计的操作步骤和方法。\n","permalink":"https://eddyblog.cn/posts/tech/hugo_busuanzi/","summary":"前言 Hugo添加不蒜子Busuanzi页面浏览次数与阅读数据统计 一、Busuanzi是什么？ Busuanzi是一个用于统计网站访问量的工具。它通常嵌入到网页中，可以追踪页面的浏览次数，方可数量积极其他一些基本的访问数据。这个工具可以帮助网站管理员了解他们的网站受欢迎程度和流量情况","title":"【Hugo网站搭建】添加不蒜子Busuanzi页面浏览次数与阅读数据统计"},{"content":"项目场景： Git bash\n问题描述： 进行git push -f origin master命令\n出现错误：fatal: unable to access ' 我的库的http路径 ': OpenSSL SSL_read: Connection was reset, errno 10054\n原因分析： 无法关联github的远程库,SSL连接被重置\n解决方案： 使用命令行解除SSL认证\ngit config --global http.sslVerify \u0026#34;false\u0026#34; git config --global https.sslVerify \u0026#34;false\u0026#34; ","permalink":"https://eddyblog.cn/posts/tech/gitub_error1/","summary":"项目场景： Git bash 问题描述： 进行git push -f origin master命令 出现错误：fatal: unable to access ' 我的库的http路径 ': OpenSSL SSL_read: Connection was reset, errno 10054 原因分析： 无法关联github的远程库,SSL连接被重置 解决方案： 使用命令行解除SSL认证 git config --global http.sslVerify \u0026#34;false\u0026#34; git config --global https.sslVerify \u0026#34;false\u0026#34;","title":"【Github使用指南】bug日志-OpenSSL SSL_read"},{"content":"前言： Git bash本地常用指令是默认上传到远程仓库的master分支，而实际上我们应该将文件传入到main主分支\n使用步骤： 假如是将远程库master分支合并到main分支，那么要先将远程仓库克隆到本地\ngit clone xxx.git 将本地的master分支合并到远程的main分支，则上个步骤不用做\n在本地master分支的文件夹目录，创建并切换至main分支 git checkout -b main 推送至main主分支 git push origin main 删除本地master分支（假如本地仓库还要使用的话，最好先不要删除） git branch -d master 删除远程master分支 git push origin :master ","permalink":"https://eddyblog.cn/posts/tech/github_merge_the_master_branch_into_the_main_branch/","summary":"前言： Git bash本地常用指令是默认上传到远程仓库的master分支，而实际上我们应该将文件传入到main主分支 使用步骤： 假如是将远程库master分支合并到main分支，那么要先将远程仓库克隆到本地 git clone xxx.git 将本地的master分支合并到远程的main分支，则上个步骤不用做 在本地ma","title":"【Github使用指南】将仓库中的master分支合并到main分支"},{"content":"前言： Hugo使用Chroma插件进行代码高亮。\nChroma: Hugo 在 v0.65.0 版本之后使用了 Chroma 代码高亮插件，它是一个 Go 语言实现的非常漂亮并能快速生成的代码高亮工具。\n操作步骤： 默认的代码高亮配置文件如下，你可以复制到你的配置文件config.yml内进行修改：\nyaml 格式的配置文件：\nmarkup: highlight: codeFences: true guessSyntax: false hl_Lines: \u0026#34;\u0026#34; lineNoStart: 1 lineNos: false lineNumbersInTable: true noClasses: true style: monokai tabWidth: 4 toml 格式的配置文件：\n[markup] [markup.highlight] anchorLineNos = false codeFences = true guessSyntax = true hl_Lines = \u0026#34;\u0026#34; lineAnchors = \u0026#34;\u0026#34; lineNoStart =1 lineNos = true lineNumbersInTable = true noClasses = true style = \u0026#34;monokai\u0026#34; tabWidth = 4 json 格式的配置文件：\n{ \u0026#34;markup\u0026#34;:{ \u0026#34;highlight\u0026#34;:{ \u0026#34;codeFences\u0026#34;:true, \u0026#34;guessSyntax\u0026#34;:false, \u0026#34;hl_Lines\u0026#34;:\u0026#34;\u0026#34;, \u0026#34;lineNoStart\u0026#34;:1, \u0026#34;lineNos\u0026#34;:false, \u0026#34;lineNumbersInTable\u0026#34;:true, \u0026#34;noClasses\u0026#34;:true, \u0026#34;style\u0026#34;:\u0026#34;monokai\u0026#34;, \u0026#34;tabWidth\u0026#34;:4 } } } 配置文件中各个设置项的含义如下：\ncodeFences：代码围栏功能，这个功能一般都要设为 true 的，不然很难看，就是干巴巴的-代码文字，没有颜色。\nguessSyntax：猜测语法，这个功能建议设置为 true, 如果你没有设置要显示的语言则会自动匹配。\nhl_Lines：高亮的行号，一般这个不设置，因为每个代码块我们可能希望让高亮的地方不一样。\nlineNoStart：行号从编号几开始，一般从 1 开始。\nlineNos：是否显示行号\nlineNumbersInTable：使用表来格式化行号和代码,而不是 标签。这个属性一般设置为 true.\nnoClasses：使用 class 标签，而不是内嵌的内联样式\n关于\u0026quot;style\u0026quot; https://xyproto.github.io/splash/docs/all.html\n这个网页呈现了所有markup的style样式，如下图所示\n","permalink":"https://eddyblog.cn/posts/tech/hugo_code_highlight/","summary":"前言： Hugo使用Chroma插件进行代码高亮。 Chroma: Hugo 在 v0.65.0 版本之后使用了 Chroma 代码高亮插件，它是一个 Go 语言实现的非常漂亮并能快速生成的代码高亮工具。 操作步骤： 默认的代码高亮配置文件如下，你可以复制到你的配置文件config.yml内进行修改： yaml 格式的配置文件： markup: highlight: codeFences: true guessSyntax: false hl_Lines: \u0026#34;\u0026#34; lineNoStart: 1 lineNos: false lineNumbersInTable:","title":"【Hugo网站搭建】实现代码高亮"},{"content":"前言 hugo主题美化-添加emoji\n一、emoji表情符号素材网站（链接来源于网络资源） https://www.lovelyemoji.com/emoji-biaoqing/\nhttps://www.emojipedia.org/zh/\nhttps://www.emojiall.com/zh-hans\n二、使用步骤 1.在emoji素材网站复制emoji 2.在config.yml进行粘贴emoji （也可以在自己想改的相应文件进行修改） 代码如下（示例）：\nmenu: main: - identifier: search name: 🔍 搜索 url: search weight: 1 - identifier: home name: 🏠 主页 url: / weight: 2 - identifier: posts name: 📚 文章 url: posts weight: 3 - identifier: tags name: 🧩 标签 url: tags weight: 15 - identifier: archives name: ⏱️ 时间轴 url: archives/ weight: 20 - identifier: about name: 🙋🏻‍♂️ 关于 url: about weight: 50 3.效果图 总结 本文仅仅简单介绍了hugo主题美化-添加emoji。\n","permalink":"https://eddyblog.cn/posts/tech/hugo_emoji/","summary":"前言 hugo主题美化-添加emoji 一、emoji表情符号素材网站（链接来源于网络资源） https://www.lovelyemoji.com/emoji-biaoqing/ https://www.emojipedia.org/zh/ https://www.emojiall.com/zh-hans 二、使用步骤 1.在emoji素材网站复制emoji 2.在config.yml进行粘贴emoji （也可以在自己想改的相应文件进行修改） 代码如下（示例）： menu: main: - identifier: search name: 🔍 搜索 url: search weight: 1 - identifier: home name: 🏠","title":"【Hugo网站搭建】主题美化-添加emoji"},{"content":"项目场景： Hugo\n问题描述 在本地使用Hugo 构建网站并在本地服务器上正常运行，但在将网站部署到 GitHub 远程仓库时出现了错误\n解决方案： 检查 GitHub 仓库代码： 首先，确保你将正确的代码推送到了 GitHub 远程仓库。在本地使用 git status 和 git diff 命令来检查是否有未提交的更改，并使用 git push 命令将代码推送到远程仓库。 （假如发现Github远程仓库里的文件污染严重，修改难度很大，可以在Github页面将username.github.io该仓库删除，然后重新创建一次username.github.io仓库，不过要确保本地有文件备份再删除远程仓库，远程仓库删除后无法恢复） 检查主题和模板： 如果你使用了主题或模板，确保它们在 GitHub 上也是最新的版本，并与本地使用的版本相同。有时候，在不同环境中使用不同的主题或模板版本可能导致不一致。\n检查配置文件： Hugo 使用配置文件来指定网站的设置和参数。确保在 GitHub 仓库中的配置文件与本地一致，并且没有不一致之处\n","permalink":"https://eddyblog.cn/posts/tech/hugo_error1/","summary":"项目场景： Hugo 问题描述 在本地使用Hugo 构建网站并在本地服务器上正常运行，但在将网站部署到 GitHub 远程仓库时出现了错误 解决方案： 检查 GitHub 仓库代码： 首先，确保你将正确的代码推送到了 GitHub 远程仓库。在本地使用 git status 和 git diff 命令来检查是否有未提交的更改，并使用 git push 命令将代码推送到远程仓库。 （假如发现Gi","title":"【Hugo网站搭建】bug日志-将网站部署到GitHub远程仓库时出现了错误"},{"content":"前言 Githubpages对应仓库username.github.io删除之后,重新创建一次仍然可以匹配到Githubpages\n操作步骤 如果你删除了之前的 GitHub Pages 仓库（例如 username.github.io），然后重新创建了同名的仓库，并将该仓库的内容推送到 main 分支（或其他指定的分支），GitHub Pages 会自动重新启用，并根据新的仓库内容生成你的个人网站。\n以下是你需要做的步骤：\n删除旧的仓库： 删除之前的 username.github.io 仓库。\n创建新的仓库： 在 GitHub 上创建一个新的 username.github.io 仓库。\n将网站内容推送到新仓库： 将你的网站内容（包括 HTML、CSS、JavaScript 文件等）推送到新仓库的 main 分支（或其他指定的分支）中。\n等待 GitHub Pages 构建： 一旦你推送了内容，GitHub Pages 将会开始自动构建你的个人网站。\n访问个人网站： 在一段时间后，你可以通过浏览器访问 https://username.github.io 来查看你的个人网站。GitHub Pages 将使用新的仓库内容来生成网站。\n重要提示：可能需要一些时间来让 GitHub Pages 更新并生成你的新网站。这通常需要几分钟到几个小时的时间。此外，如果你之前使用了自定义域名（如 username.com）来指向 GitHub Pages，你可能需要重新设置域名解析以确保它与新的仓库匹配。\n总之，删除并重新创建一个同名的 GitHub Pages 仓库后，只要你推送了新内容，GitHub Pages 将重新构建你的个人网站。\n","permalink":"https://eddyblog.cn/posts/tech/hugo_githubpages/","summary":"前言 Githubpages对应仓库username.github.io删除之后,重新创建一次仍然可以匹配到Githubpages 操作步骤 如果你删除了之前的 GitHub Pages 仓库（例如 username.github.io），然后重新创建了同名的仓库，并将该仓库的内容推送到 main 分支（或其他指定的分支","title":"【Hugo网站搭建】githubpages对应仓库username.github.io"},{"content":"前言 Hugo设置主页头像\n操作步骤 1.制作圆形头像：在线网站 （链接来源于网络资源） 网站如下（示例）：\nhttps://crop-circle.imageonline.co/cn/#google_vignette\nhttps://bigimage.11zon.com/zh-cn/crop-circle-image/\n2.config.yml更改 languages: en: params: languageName: \u0026#34;English\u0026#34; weight: 1 profileMode: enabled: true title: Eddy - blog subtitle: # subtitle: imageUrl: \u0026#34;img/logo3.png\u0026#34; #图片放在static/img/logo3.png imageTitle: imageWidth: 150 # 设置图像尺寸 imageHeight: 150 # 设置图像尺寸 主页头像 image 即为下图中圆形图像\n总结 本文简单介绍了Hugo设置主页头像的操作步骤和方法。\n","permalink":"https://eddyblog.cn/posts/tech/hugo_homepage_avatar/","summary":"前言 Hugo设置主页头像 操作步骤 1.制作圆形头像：在线网站 （链接来源于网络资源） 网站如下（示例）： https://crop-circle.imageonline.co/cn/#google_vignette https://bigimage.11zon.com/zh-cn/crop-circle-image/ 2.config.yml更改 languages: en: params: languageName: \u0026#34;English\u0026#34; weight: 1 profileMode: enabled: true title: Eddy - blog subtitle: # subtitle: imageUrl: \u0026#34;img/logo3.png\u0026#34; #图片放在static/img/logo3.png imageTitle: imageWidth: 150 # 设置图像尺寸 imageHeight: 150 # 设置图像尺寸 主页头像 image 即为下图中圆形","title":"【Hugo网站搭建】设置主页头像"},{"content":"前言 Hugo添加icon/socialIcons\nsocialIcons 以添加socialIcons为例\nHugo本身是自带了很多支持的socialIcons的\n如:twitter，ins，github，email等等，写下如下代码，则会自动匹配对应icon\nparams: socialIcons: - name = \u0026#34;twitter\u0026#34; url = \u0026#34;https://twitter.com\u0026#34; 添加icon操作步骤 而假如想添加额外的socialIcons，那么需要自己添加svg代码，才能匹配到合适的icon图标\n下面是添加socialIcons：csdn的具体教程\nparams: socialIcons: - name: csdn url: \u0026#34;https://www.csdn.net/\u0026#34; 进入svg图库网站，以https://www.iconfont.cn/阿里巴巴矢量库为例\n搜索你需要的网站icon，以csdn为例\n选定合适的icon 点击图像，添加入库 添加至项目，创建项目Hugo，加入至项目Hugo 点击图像，对尺寸进行编辑（假如不知道怎么把握尺寸的话，可以先不编辑） 点击下载，复制图像的svg代码 进入layouts\\partials\\svg.html，添加刚刚复制的代码（我是直接在博客源码进行更改的，而不是themes文件夹） \u0026lt;svg t=\u0026#34;1691595802782\u0026#34; class=\u0026#34;icon\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34; version=\u0026#34;1.1\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; p-id=\u0026#34;894\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34;\u0026gt;\u0026lt;path d=\u0026#34;M512 1024C229.2224 1024 0 794.7776 0 512 0 229.2224 229.2224 0 512 0c282.7776 0 512 229.2224 512 512 0 282.7776-229.2224 512-512 512z m17.066667-413.525333c34.850133 4.352 68.778667 5.12 102.741333 2.0992 23.04-2.048 44.817067-8.362667 64.170667-21.9136 38.212267-26.794667 49.783467-85.1968 24.251733-123.050667-14.626133-21.7088-36.8128-30.344533-60.757333-35.498667-35.054933-7.543467-70.4512-5.751467-105.847467-3.413333-5.666133 0.3584-6.7584 3.072-7.236267 8.209067-3.072 32.682667-6.536533 65.314133-9.813333 97.962666-2.5088 24.814933-4.932267 49.629867-7.509333 75.605334z m53.4016-33.928534c1.962667-20.906667 3.6352-39.338667 5.4272-57.770666 1.553067-15.906133 3.413333-31.778133 4.727466-47.701334 0.3584-4.283733 1.553067-6.656 5.956267-6.382933 15.616 1.041067 31.709867 0.034133 46.728533 3.652267 36.488533 8.823467 48.725333 54.306133 23.3472 83.029333-15.8208 17.902933-36.7616 23.586133-59.255466 25.088-8.465067 0.546133-17.015467 0.085333-26.9312 0.085333zM512 434.295467c-2.184533-0.648533-3.5328-1.1776-4.932267-1.4336-37.717333-6.877867-75.690667-8.328533-113.646933-2.816-20.974933 3.037867-41.0112 9.489067-57.480533 23.330133-22.9888 19.319467-21.640533 46.848 4.4032 62.0032 13.056 7.594667 28.023467 12.509867 42.5984 17.288533 14.08 4.608 28.996267 6.826667 43.144533 11.264 12.5952 3.925333 14.011733 14.318933 3.584 22.306134-3.345067 2.56-7.441067 5.085867-11.537067 5.751466-11.195733 1.826133-22.698667 4.386133-33.826133 3.566934-24.098133-1.774933-48.042667-5.461333-72.5504-8.430934-1.365333 10.615467-2.935467 23.0912-4.5568 35.9424 4.181333 1.365333 7.68 2.730667 11.264 3.618134 33.9456 8.4992 68.386133 9.608533 102.912 5.12 20.087467-2.6112 39.4752-7.901867 56.695467-19.029334 28.603733-18.4832 36.693333-57.1904-4.676267-75.383466-14.506667-6.382933-30.190933-10.410667-45.482667-15.086934-11.4176-3.4816-23.313067-5.614933-34.525866-9.5232-9.7792-3.413333-11.144533-12.202667-3.037867-18.397866 4.6592-3.549867 10.717867-6.997333 16.384-7.3728a480.853333 480.853333 0 0 1 53.384533-0.853334c15.377067 0.699733 30.651733 3.549867 46.4896 5.5296L512 434.295467z m257.143467 2.048L750.933333 614.2976h54.152534c4.778667-45.636267 9.710933-90.7264 14.062933-135.8848 0.6144-6.365867 2.3552-8.840533 8.686933-9.0112 11.434667-0.273067 22.8864-1.979733 34.286934-1.570133 23.722667 0.853333 42.3936 9.728 38.4 43.264-2.901333 24.2688-5.597867 48.571733-8.2432 72.874666-1.092267 10.069333-1.826133 20.189867-2.730667 30.4128h55.330133c3.584-35.259733 7.9872-70.058667 10.496-104.994133 3.413333-47.4624-17.7664-73.3184-64.682666-80.213333-40.96-6.007467-81.339733-0.341333-121.5488 7.133866z m-483.498667 134.6048c-8.738133 1.297067-16.384 2.798933-24.098133 3.4816-25.6512 2.235733-51.319467 3.9424-76.305067-4.266667-13.909333-4.590933-24.6784-12.578133-29.7984-25.9584-7.901867-20.701867 0.887467-47.104 19.831467-60.3136 17.373867-12.117333 37.717333-15.9232 58.453333-15.9232 22.545067-0.017067 45.090133 2.423467 68.232533 3.84L307.2 432.298667c-15.069867-1.723733-29.4912-3.925333-43.997867-4.9152-41.0112-2.798933-80.64 2.6112-117.469866 20.462933-30.020267 14.557867-52.053333 36.010667-58.6752 68.130133-7.850667 38.144 11.537067 69.495467 51.7632 85.845334 19.1488 7.765333 39.287467 12.509867 60.0064 12.5952 24.746667 0.1024 49.493333-1.570133 74.205866-2.952534 3.106133-0.170667 8.311467-2.901333 8.669867-5.034666 1.979733-11.554133 2.730667-23.278933 3.9424-35.464534z\u0026#34; fill=\u0026#34;#DD1700\u0026#34; p-id=\u0026#34;895\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt; \u0026lt;/svg\u0026gt; --\u0026gt; {{- else if (eq $icon_name \u0026#34;csdn\u0026#34;) -}} \u0026lt;svg t = ..............................这是刚刚复制的svg代码\u0026gt; \u0026lt;!-- \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34;\u0026gt; \u0026lt;path transform=\u0026#34;scale(0.04) translate(75 40)\u0026#34; stroke-width=\u0026#34;50\u0026#34; d=\u0026#34;M433.754 420.445c-11.526 1.393-44.86-52.741-44.86-52.741 0 31.345-16.136 72.247-51.051 101.786 16.842 5.192 54.843 19.167 45.803 34.421-7.316 12.343-125.51 7.881-159.632 4.037-34.122 3.844-152.316 8.306-159.632-4.037-9.045-15.25 28.918-29.214 45.783-34.415-34.92-29.539-51.059-70.445-51.059-101.792 0 0-33.334 54.134-44.859 52.741-5.37-.65-12.424-29.644 9.347-99.704 10.261-33.024 21.995-60.478 40.144-105.779C60.683 98.063 108.982.006 224 0c113.737.006 163.156 96.133 160.264 214.963 18.118 45.223 29.912 72.85 40.144 105.778 21.768 70.06 14.716 99.053 9.346 99.704z\u0026#34;\u0026gt; \u0026lt;/path\u0026gt; 示意图如下：\n最后在config.yml加入 params: socialIcons: - name: csdn url: \u0026#34;https://www.csdn.net/\u0026#34; ","permalink":"https://eddyblog.cn/posts/tech/hugo_icon/","summary":"前言 Hugo添加icon/socialIcons socialIcons 以添加socialIcons为例 Hugo本身是自带了很多支持的socialIcons的 如:twitter，ins，github，email等等，写下如下代码，则会自动匹配对应icon params: socialIcons: - name = \u0026#34;twitter\u0026#34; url = \u0026#34;https://twitter.com\u0026#34; 添加icon操作步骤 而假如想添","title":"【Hugo网站搭建】添加icon+socialIcons"},{"content":"关于我\n英文名: EddyCliff 职业: 大学生 兴趣: 音乐、电影 ","permalink":"https://eddyblog.cn/about/","summary":"关于我 英文名: EddyCliff 职业: 大学生 兴趣: 音乐、电影","title":"🙋🏻‍♂️关于"}]